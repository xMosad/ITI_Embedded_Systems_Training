
35-FreeRTOS_Queue.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000588e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  0000588e  00005922  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045e  0080006e  0080006e  00005930  2**0
                  ALLOC
  3 .stab         00006fa8  00000000  00000000  00005930  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000040a7  00000000  00000000  0000c8d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  0001097f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00010adf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  00010c6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00012cb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  00013db4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00014d38  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00014eb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  0001517a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00015a08  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d2 0a 	jmp	0x15a4	; 0x15a4 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e8       	ldi	r30, 0x8E	; 142
      68:	f8 e5       	ldi	r31, 0x58	; 88
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 3c       	cpi	r26, 0xCC	; 204
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7b 2b 	call	0x56f6	; 0x56f6 <main>
      8a:	0c 94 45 2c 	jmp	0x588a	; 0x588a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 05 2c 	jmp	0x580a	; 0x580a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 21 2c 	jmp	0x5842	; 0x5842 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 11 2c 	jmp	0x5822	; 0x5822 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 2d 2c 	jmp	0x585a	; 0x585a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 11 2c 	jmp	0x5822	; 0x5822 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 2d 2c 	jmp	0x585a	; 0x585a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 05 2c 	jmp	0x580a	; 0x580a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 21 2c 	jmp	0x5842	; 0x5842 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 0d 2c 	jmp	0x581a	; 0x581a <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	65 e6       	ldi	r22, 0x65	; 101
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 29 2c 	jmp	0x5852	; 0x5852 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 11 2c 	jmp	0x5822	; 0x5822 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 2d 2c 	jmp	0x585a	; 0x585a <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 11 2c 	jmp	0x5822	; 0x5822 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 2d 2c 	jmp	0x585a	; 0x585a <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 11 2c 	jmp	0x5822	; 0x5822 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 2d 2c 	jmp	0x585a	; 0x585a <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 15 2c 	jmp	0x582a	; 0x582a <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 31 2c 	jmp	0x5862	; 0x5862 <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	00 d0       	rcall	.+0      	; 0xca4 <pvPortMalloc+0x6>
     ca4:	00 d0       	rcall	.+0      	; 0xca6 <pvPortMalloc+0x8>
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
     caa:	9c 83       	std	Y+4, r25	; 0x04
     cac:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     cae:	1a 82       	std	Y+2, r1	; 0x02
     cb0:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     cb2:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     cb6:	80 91 70 00 	lds	r24, 0x0070
     cba:	90 91 71 00 	lds	r25, 0x0071
     cbe:	00 97       	sbiw	r24, 0x00	; 0
     cc0:	31 f4       	brne	.+12     	; 0xcce <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     cc2:	83 e7       	ldi	r24, 0x73	; 115
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	90 93 71 00 	sts	0x0071, r25
     cca:	80 93 70 00 	sts	0x0070, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     cce:	80 91 6e 00 	lds	r24, 0x006E
     cd2:	90 91 6f 00 	lds	r25, 0x006F
     cd6:	2b 81       	ldd	r18, Y+3	; 0x03
     cd8:	3c 81       	ldd	r19, Y+4	; 0x04
     cda:	82 0f       	add	r24, r18
     cdc:	93 1f       	adc	r25, r19
     cde:	23 e0       	ldi	r18, 0x03	; 3
     ce0:	87 3e       	cpi	r24, 0xE7	; 231
     ce2:	92 07       	cpc	r25, r18
     ce4:	38 f5       	brcc	.+78     	; 0xd34 <pvPortMalloc+0x96>
     ce6:	20 91 6e 00 	lds	r18, 0x006E
     cea:	30 91 6f 00 	lds	r19, 0x006F
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	28 0f       	add	r18, r24
     cf4:	39 1f       	adc	r19, r25
     cf6:	80 91 6e 00 	lds	r24, 0x006E
     cfa:	90 91 6f 00 	lds	r25, 0x006F
     cfe:	82 17       	cp	r24, r18
     d00:	93 07       	cpc	r25, r19
     d02:	c0 f4       	brcc	.+48     	; 0xd34 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d04:	20 91 70 00 	lds	r18, 0x0070
     d08:	30 91 71 00 	lds	r19, 0x0071
     d0c:	80 91 6e 00 	lds	r24, 0x006E
     d10:	90 91 6f 00 	lds	r25, 0x006F
     d14:	82 0f       	add	r24, r18
     d16:	93 1f       	adc	r25, r19
     d18:	9a 83       	std	Y+2, r25	; 0x02
     d1a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     d1c:	20 91 6e 00 	lds	r18, 0x006E
     d20:	30 91 6f 00 	lds	r19, 0x006F
     d24:	8b 81       	ldd	r24, Y+3	; 0x03
     d26:	9c 81       	ldd	r25, Y+4	; 0x04
     d28:	82 0f       	add	r24, r18
     d2a:	93 1f       	adc	r25, r19
     d2c:	90 93 6f 00 	sts	0x006F, r25
     d30:	80 93 6e 00 	sts	0x006E, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     d34:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     d38:	89 81       	ldd	r24, Y+1	; 0x01
     d3a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d3c:	0f 90       	pop	r0
     d3e:	0f 90       	pop	r0
     d40:	0f 90       	pop	r0
     d42:	0f 90       	pop	r0
     d44:	cf 91       	pop	r28
     d46:	df 91       	pop	r29
     d48:	08 95       	ret

00000d4a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d4a:	df 93       	push	r29
     d4c:	cf 93       	push	r28
     d4e:	00 d0       	rcall	.+0      	; 0xd50 <vPortFree+0x6>
     d50:	cd b7       	in	r28, 0x3d	; 61
     d52:	de b7       	in	r29, 0x3e	; 62
     d54:	9a 83       	std	Y+2, r25	; 0x02
     d56:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     d58:	0f 90       	pop	r0
     d5a:	0f 90       	pop	r0
     d5c:	cf 91       	pop	r28
     d5e:	df 91       	pop	r29
     d60:	08 95       	ret

00000d62 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     d62:	df 93       	push	r29
     d64:	cf 93       	push	r28
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     d6a:	10 92 6f 00 	sts	0x006F, r1
     d6e:	10 92 6e 00 	sts	0x006E, r1
}
     d72:	cf 91       	pop	r28
     d74:	df 91       	pop	r29
     d76:	08 95       	ret

00000d78 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     d78:	df 93       	push	r29
     d7a:	cf 93       	push	r28
     d7c:	cd b7       	in	r28, 0x3d	; 61
     d7e:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     d80:	20 91 6e 00 	lds	r18, 0x006E
     d84:	30 91 6f 00 	lds	r19, 0x006F
     d88:	87 ee       	ldi	r24, 0xE7	; 231
     d8a:	93 e0       	ldi	r25, 0x03	; 3
     d8c:	82 1b       	sub	r24, r18
     d8e:	93 0b       	sbc	r25, r19
}
     d90:	cf 91       	pop	r28
     d92:	df 91       	pop	r29
     d94:	08 95       	ret

00000d96 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     d96:	df 93       	push	r29
     d98:	cf 93       	push	r28
     d9a:	00 d0       	rcall	.+0      	; 0xd9c <vListInitialise+0x6>
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	9a 83       	std	Y+2, r25	; 0x02
     da2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     da4:	89 81       	ldd	r24, Y+1	; 0x01
     da6:	9a 81       	ldd	r25, Y+2	; 0x02
     da8:	03 96       	adiw	r24, 0x03	; 3
     daa:	e9 81       	ldd	r30, Y+1	; 0x01
     dac:	fa 81       	ldd	r31, Y+2	; 0x02
     dae:	92 83       	std	Z+2, r25	; 0x02
     db0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     db2:	e9 81       	ldd	r30, Y+1	; 0x01
     db4:	fa 81       	ldd	r31, Y+2	; 0x02
     db6:	8f ef       	ldi	r24, 0xFF	; 255
     db8:	9f ef       	ldi	r25, 0xFF	; 255
     dba:	94 83       	std	Z+4, r25	; 0x04
     dbc:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dbe:	89 81       	ldd	r24, Y+1	; 0x01
     dc0:	9a 81       	ldd	r25, Y+2	; 0x02
     dc2:	03 96       	adiw	r24, 0x03	; 3
     dc4:	e9 81       	ldd	r30, Y+1	; 0x01
     dc6:	fa 81       	ldd	r31, Y+2	; 0x02
     dc8:	96 83       	std	Z+6, r25	; 0x06
     dca:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dcc:	89 81       	ldd	r24, Y+1	; 0x01
     dce:	9a 81       	ldd	r25, Y+2	; 0x02
     dd0:	03 96       	adiw	r24, 0x03	; 3
     dd2:	e9 81       	ldd	r30, Y+1	; 0x01
     dd4:	fa 81       	ldd	r31, Y+2	; 0x02
     dd6:	90 87       	std	Z+8, r25	; 0x08
     dd8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     dda:	e9 81       	ldd	r30, Y+1	; 0x01
     ddc:	fa 81       	ldd	r31, Y+2	; 0x02
     dde:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     de0:	0f 90       	pop	r0
     de2:	0f 90       	pop	r0
     de4:	cf 91       	pop	r28
     de6:	df 91       	pop	r29
     de8:	08 95       	ret

00000dea <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     dea:	df 93       	push	r29
     dec:	cf 93       	push	r28
     dee:	00 d0       	rcall	.+0      	; 0xdf0 <vListInitialiseItem+0x6>
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	9a 83       	std	Y+2, r25	; 0x02
     df6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     df8:	e9 81       	ldd	r30, Y+1	; 0x01
     dfa:	fa 81       	ldd	r31, Y+2	; 0x02
     dfc:	11 86       	std	Z+9, r1	; 0x09
     dfe:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	cf 91       	pop	r28
     e06:	df 91       	pop	r29
     e08:	08 95       	ret

00000e0a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e0a:	df 93       	push	r29
     e0c:	cf 93       	push	r28
     e0e:	00 d0       	rcall	.+0      	; 0xe10 <vListInsertEnd+0x6>
     e10:	00 d0       	rcall	.+0      	; 0xe12 <vListInsertEnd+0x8>
     e12:	00 d0       	rcall	.+0      	; 0xe14 <vListInsertEnd+0xa>
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
     e18:	9c 83       	std	Y+4, r25	; 0x04
     e1a:	8b 83       	std	Y+3, r24	; 0x03
     e1c:	7e 83       	std	Y+6, r23	; 0x06
     e1e:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     e20:	eb 81       	ldd	r30, Y+3	; 0x03
     e22:	fc 81       	ldd	r31, Y+4	; 0x04
     e24:	81 81       	ldd	r24, Z+1	; 0x01
     e26:	92 81       	ldd	r25, Z+2	; 0x02
     e28:	9a 83       	std	Y+2, r25	; 0x02
     e2a:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e2c:	ed 81       	ldd	r30, Y+5	; 0x05
     e2e:	fe 81       	ldd	r31, Y+6	; 0x06
     e30:	89 81       	ldd	r24, Y+1	; 0x01
     e32:	9a 81       	ldd	r25, Y+2	; 0x02
     e34:	93 83       	std	Z+3, r25	; 0x03
     e36:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e38:	e9 81       	ldd	r30, Y+1	; 0x01
     e3a:	fa 81       	ldd	r31, Y+2	; 0x02
     e3c:	84 81       	ldd	r24, Z+4	; 0x04
     e3e:	95 81       	ldd	r25, Z+5	; 0x05
     e40:	ed 81       	ldd	r30, Y+5	; 0x05
     e42:	fe 81       	ldd	r31, Y+6	; 0x06
     e44:	95 83       	std	Z+5, r25	; 0x05
     e46:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e48:	e9 81       	ldd	r30, Y+1	; 0x01
     e4a:	fa 81       	ldd	r31, Y+2	; 0x02
     e4c:	04 80       	ldd	r0, Z+4	; 0x04
     e4e:	f5 81       	ldd	r31, Z+5	; 0x05
     e50:	e0 2d       	mov	r30, r0
     e52:	8d 81       	ldd	r24, Y+5	; 0x05
     e54:	9e 81       	ldd	r25, Y+6	; 0x06
     e56:	93 83       	std	Z+3, r25	; 0x03
     e58:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     e5a:	e9 81       	ldd	r30, Y+1	; 0x01
     e5c:	fa 81       	ldd	r31, Y+2	; 0x02
     e5e:	8d 81       	ldd	r24, Y+5	; 0x05
     e60:	9e 81       	ldd	r25, Y+6	; 0x06
     e62:	95 83       	std	Z+5, r25	; 0x05
     e64:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     e66:	ed 81       	ldd	r30, Y+5	; 0x05
     e68:	fe 81       	ldd	r31, Y+6	; 0x06
     e6a:	8b 81       	ldd	r24, Y+3	; 0x03
     e6c:	9c 81       	ldd	r25, Y+4	; 0x04
     e6e:	91 87       	std	Z+9, r25	; 0x09
     e70:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e72:	eb 81       	ldd	r30, Y+3	; 0x03
     e74:	fc 81       	ldd	r31, Y+4	; 0x04
     e76:	80 81       	ld	r24, Z
     e78:	8f 5f       	subi	r24, 0xFF	; 255
     e7a:	eb 81       	ldd	r30, Y+3	; 0x03
     e7c:	fc 81       	ldd	r31, Y+4	; 0x04
     e7e:	80 83       	st	Z, r24
}
     e80:	26 96       	adiw	r28, 0x06	; 6
     e82:	0f b6       	in	r0, 0x3f	; 63
     e84:	f8 94       	cli
     e86:	de bf       	out	0x3e, r29	; 62
     e88:	0f be       	out	0x3f, r0	; 63
     e8a:	cd bf       	out	0x3d, r28	; 61
     e8c:	cf 91       	pop	r28
     e8e:	df 91       	pop	r29
     e90:	08 95       	ret

00000e92 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e92:	df 93       	push	r29
     e94:	cf 93       	push	r28
     e96:	cd b7       	in	r28, 0x3d	; 61
     e98:	de b7       	in	r29, 0x3e	; 62
     e9a:	28 97       	sbiw	r28, 0x08	; 8
     e9c:	0f b6       	in	r0, 0x3f	; 63
     e9e:	f8 94       	cli
     ea0:	de bf       	out	0x3e, r29	; 62
     ea2:	0f be       	out	0x3f, r0	; 63
     ea4:	cd bf       	out	0x3d, r28	; 61
     ea6:	9e 83       	std	Y+6, r25	; 0x06
     ea8:	8d 83       	std	Y+5, r24	; 0x05
     eaa:	78 87       	std	Y+8, r23	; 0x08
     eac:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     eae:	ef 81       	ldd	r30, Y+7	; 0x07
     eb0:	f8 85       	ldd	r31, Y+8	; 0x08
     eb2:	80 81       	ld	r24, Z
     eb4:	91 81       	ldd	r25, Z+1	; 0x01
     eb6:	9a 83       	std	Y+2, r25	; 0x02
     eb8:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     eba:	89 81       	ldd	r24, Y+1	; 0x01
     ebc:	9a 81       	ldd	r25, Y+2	; 0x02
     ebe:	2f ef       	ldi	r18, 0xFF	; 255
     ec0:	8f 3f       	cpi	r24, 0xFF	; 255
     ec2:	92 07       	cpc	r25, r18
     ec4:	39 f4       	brne	.+14     	; 0xed4 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     ec6:	ed 81       	ldd	r30, Y+5	; 0x05
     ec8:	fe 81       	ldd	r31, Y+6	; 0x06
     eca:	87 81       	ldd	r24, Z+7	; 0x07
     ecc:	90 85       	ldd	r25, Z+8	; 0x08
     ece:	9c 83       	std	Y+4, r25	; 0x04
     ed0:	8b 83       	std	Y+3, r24	; 0x03
     ed2:	18 c0       	rjmp	.+48     	; 0xf04 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     ed4:	8d 81       	ldd	r24, Y+5	; 0x05
     ed6:	9e 81       	ldd	r25, Y+6	; 0x06
     ed8:	03 96       	adiw	r24, 0x03	; 3
     eda:	9c 83       	std	Y+4, r25	; 0x04
     edc:	8b 83       	std	Y+3, r24	; 0x03
     ede:	06 c0       	rjmp	.+12     	; 0xeec <vListInsert+0x5a>
     ee0:	eb 81       	ldd	r30, Y+3	; 0x03
     ee2:	fc 81       	ldd	r31, Y+4	; 0x04
     ee4:	82 81       	ldd	r24, Z+2	; 0x02
     ee6:	93 81       	ldd	r25, Z+3	; 0x03
     ee8:	9c 83       	std	Y+4, r25	; 0x04
     eea:	8b 83       	std	Y+3, r24	; 0x03
     eec:	eb 81       	ldd	r30, Y+3	; 0x03
     eee:	fc 81       	ldd	r31, Y+4	; 0x04
     ef0:	02 80       	ldd	r0, Z+2	; 0x02
     ef2:	f3 81       	ldd	r31, Z+3	; 0x03
     ef4:	e0 2d       	mov	r30, r0
     ef6:	20 81       	ld	r18, Z
     ef8:	31 81       	ldd	r19, Z+1	; 0x01
     efa:	89 81       	ldd	r24, Y+1	; 0x01
     efc:	9a 81       	ldd	r25, Y+2	; 0x02
     efe:	82 17       	cp	r24, r18
     f00:	93 07       	cpc	r25, r19
     f02:	70 f7       	brcc	.-36     	; 0xee0 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     f04:	eb 81       	ldd	r30, Y+3	; 0x03
     f06:	fc 81       	ldd	r31, Y+4	; 0x04
     f08:	82 81       	ldd	r24, Z+2	; 0x02
     f0a:	93 81       	ldd	r25, Z+3	; 0x03
     f0c:	ef 81       	ldd	r30, Y+7	; 0x07
     f0e:	f8 85       	ldd	r31, Y+8	; 0x08
     f10:	93 83       	std	Z+3, r25	; 0x03
     f12:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     f14:	ef 81       	ldd	r30, Y+7	; 0x07
     f16:	f8 85       	ldd	r31, Y+8	; 0x08
     f18:	02 80       	ldd	r0, Z+2	; 0x02
     f1a:	f3 81       	ldd	r31, Z+3	; 0x03
     f1c:	e0 2d       	mov	r30, r0
     f1e:	8f 81       	ldd	r24, Y+7	; 0x07
     f20:	98 85       	ldd	r25, Y+8	; 0x08
     f22:	95 83       	std	Z+5, r25	; 0x05
     f24:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     f26:	ef 81       	ldd	r30, Y+7	; 0x07
     f28:	f8 85       	ldd	r31, Y+8	; 0x08
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	9c 81       	ldd	r25, Y+4	; 0x04
     f2e:	95 83       	std	Z+5, r25	; 0x05
     f30:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     f32:	eb 81       	ldd	r30, Y+3	; 0x03
     f34:	fc 81       	ldd	r31, Y+4	; 0x04
     f36:	8f 81       	ldd	r24, Y+7	; 0x07
     f38:	98 85       	ldd	r25, Y+8	; 0x08
     f3a:	93 83       	std	Z+3, r25	; 0x03
     f3c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     f3e:	ef 81       	ldd	r30, Y+7	; 0x07
     f40:	f8 85       	ldd	r31, Y+8	; 0x08
     f42:	8d 81       	ldd	r24, Y+5	; 0x05
     f44:	9e 81       	ldd	r25, Y+6	; 0x06
     f46:	91 87       	std	Z+9, r25	; 0x09
     f48:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f4a:	ed 81       	ldd	r30, Y+5	; 0x05
     f4c:	fe 81       	ldd	r31, Y+6	; 0x06
     f4e:	80 81       	ld	r24, Z
     f50:	8f 5f       	subi	r24, 0xFF	; 255
     f52:	ed 81       	ldd	r30, Y+5	; 0x05
     f54:	fe 81       	ldd	r31, Y+6	; 0x06
     f56:	80 83       	st	Z, r24
}
     f58:	28 96       	adiw	r28, 0x08	; 8
     f5a:	0f b6       	in	r0, 0x3f	; 63
     f5c:	f8 94       	cli
     f5e:	de bf       	out	0x3e, r29	; 62
     f60:	0f be       	out	0x3f, r0	; 63
     f62:	cd bf       	out	0x3d, r28	; 61
     f64:	cf 91       	pop	r28
     f66:	df 91       	pop	r29
     f68:	08 95       	ret

00000f6a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     f6a:	df 93       	push	r29
     f6c:	cf 93       	push	r28
     f6e:	00 d0       	rcall	.+0      	; 0xf70 <uxListRemove+0x6>
     f70:	00 d0       	rcall	.+0      	; 0xf72 <uxListRemove+0x8>
     f72:	cd b7       	in	r28, 0x3d	; 61
     f74:	de b7       	in	r29, 0x3e	; 62
     f76:	9c 83       	std	Y+4, r25	; 0x04
     f78:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     f7a:	eb 81       	ldd	r30, Y+3	; 0x03
     f7c:	fc 81       	ldd	r31, Y+4	; 0x04
     f7e:	80 85       	ldd	r24, Z+8	; 0x08
     f80:	91 85       	ldd	r25, Z+9	; 0x09
     f82:	9a 83       	std	Y+2, r25	; 0x02
     f84:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     f86:	eb 81       	ldd	r30, Y+3	; 0x03
     f88:	fc 81       	ldd	r31, Y+4	; 0x04
     f8a:	a2 81       	ldd	r26, Z+2	; 0x02
     f8c:	b3 81       	ldd	r27, Z+3	; 0x03
     f8e:	eb 81       	ldd	r30, Y+3	; 0x03
     f90:	fc 81       	ldd	r31, Y+4	; 0x04
     f92:	84 81       	ldd	r24, Z+4	; 0x04
     f94:	95 81       	ldd	r25, Z+5	; 0x05
     f96:	15 96       	adiw	r26, 0x05	; 5
     f98:	9c 93       	st	X, r25
     f9a:	8e 93       	st	-X, r24
     f9c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     f9e:	eb 81       	ldd	r30, Y+3	; 0x03
     fa0:	fc 81       	ldd	r31, Y+4	; 0x04
     fa2:	a4 81       	ldd	r26, Z+4	; 0x04
     fa4:	b5 81       	ldd	r27, Z+5	; 0x05
     fa6:	eb 81       	ldd	r30, Y+3	; 0x03
     fa8:	fc 81       	ldd	r31, Y+4	; 0x04
     faa:	82 81       	ldd	r24, Z+2	; 0x02
     fac:	93 81       	ldd	r25, Z+3	; 0x03
     fae:	13 96       	adiw	r26, 0x03	; 3
     fb0:	9c 93       	st	X, r25
     fb2:	8e 93       	st	-X, r24
     fb4:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     fb6:	e9 81       	ldd	r30, Y+1	; 0x01
     fb8:	fa 81       	ldd	r31, Y+2	; 0x02
     fba:	21 81       	ldd	r18, Z+1	; 0x01
     fbc:	32 81       	ldd	r19, Z+2	; 0x02
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
     fc0:	9c 81       	ldd	r25, Y+4	; 0x04
     fc2:	28 17       	cp	r18, r24
     fc4:	39 07       	cpc	r19, r25
     fc6:	41 f4       	brne	.+16     	; 0xfd8 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     fc8:	eb 81       	ldd	r30, Y+3	; 0x03
     fca:	fc 81       	ldd	r31, Y+4	; 0x04
     fcc:	84 81       	ldd	r24, Z+4	; 0x04
     fce:	95 81       	ldd	r25, Z+5	; 0x05
     fd0:	e9 81       	ldd	r30, Y+1	; 0x01
     fd2:	fa 81       	ldd	r31, Y+2	; 0x02
     fd4:	92 83       	std	Z+2, r25	; 0x02
     fd6:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     fd8:	eb 81       	ldd	r30, Y+3	; 0x03
     fda:	fc 81       	ldd	r31, Y+4	; 0x04
     fdc:	11 86       	std	Z+9, r1	; 0x09
     fde:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     fe0:	e9 81       	ldd	r30, Y+1	; 0x01
     fe2:	fa 81       	ldd	r31, Y+2	; 0x02
     fe4:	80 81       	ld	r24, Z
     fe6:	81 50       	subi	r24, 0x01	; 1
     fe8:	e9 81       	ldd	r30, Y+1	; 0x01
     fea:	fa 81       	ldd	r31, Y+2	; 0x02
     fec:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     fee:	e9 81       	ldd	r30, Y+1	; 0x01
     ff0:	fa 81       	ldd	r31, Y+2	; 0x02
     ff2:	80 81       	ld	r24, Z
}
     ff4:	0f 90       	pop	r0
     ff6:	0f 90       	pop	r0
     ff8:	0f 90       	pop	r0
     ffa:	0f 90       	pop	r0
     ffc:	cf 91       	pop	r28
     ffe:	df 91       	pop	r29
    1000:	08 95       	ret

00001002 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1002:	df 93       	push	r29
    1004:	cf 93       	push	r28
    1006:	cd b7       	in	r28, 0x3d	; 61
    1008:	de b7       	in	r29, 0x3e	; 62
    100a:	28 97       	sbiw	r28, 0x08	; 8
    100c:	0f b6       	in	r0, 0x3f	; 63
    100e:	f8 94       	cli
    1010:	de bf       	out	0x3e, r29	; 62
    1012:	0f be       	out	0x3f, r0	; 63
    1014:	cd bf       	out	0x3d, r28	; 61
    1016:	9c 83       	std	Y+4, r25	; 0x04
    1018:	8b 83       	std	Y+3, r24	; 0x03
    101a:	7e 83       	std	Y+6, r23	; 0x06
    101c:	6d 83       	std	Y+5, r22	; 0x05
    101e:	58 87       	std	Y+8, r21	; 0x08
    1020:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1022:	eb 81       	ldd	r30, Y+3	; 0x03
    1024:	fc 81       	ldd	r31, Y+4	; 0x04
    1026:	81 e1       	ldi	r24, 0x11	; 17
    1028:	80 83       	st	Z, r24
	pxTopOfStack--;
    102a:	8b 81       	ldd	r24, Y+3	; 0x03
    102c:	9c 81       	ldd	r25, Y+4	; 0x04
    102e:	01 97       	sbiw	r24, 0x01	; 1
    1030:	9c 83       	std	Y+4, r25	; 0x04
    1032:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1034:	eb 81       	ldd	r30, Y+3	; 0x03
    1036:	fc 81       	ldd	r31, Y+4	; 0x04
    1038:	82 e2       	ldi	r24, 0x22	; 34
    103a:	80 83       	st	Z, r24
	pxTopOfStack--;
    103c:	8b 81       	ldd	r24, Y+3	; 0x03
    103e:	9c 81       	ldd	r25, Y+4	; 0x04
    1040:	01 97       	sbiw	r24, 0x01	; 1
    1042:	9c 83       	std	Y+4, r25	; 0x04
    1044:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1046:	eb 81       	ldd	r30, Y+3	; 0x03
    1048:	fc 81       	ldd	r31, Y+4	; 0x04
    104a:	83 e3       	ldi	r24, 0x33	; 51
    104c:	80 83       	st	Z, r24
	pxTopOfStack--;
    104e:	8b 81       	ldd	r24, Y+3	; 0x03
    1050:	9c 81       	ldd	r25, Y+4	; 0x04
    1052:	01 97       	sbiw	r24, 0x01	; 1
    1054:	9c 83       	std	Y+4, r25	; 0x04
    1056:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1058:	8d 81       	ldd	r24, Y+5	; 0x05
    105a:	9e 81       	ldd	r25, Y+6	; 0x06
    105c:	9a 83       	std	Y+2, r25	; 0x02
    105e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1060:	89 81       	ldd	r24, Y+1	; 0x01
    1062:	eb 81       	ldd	r30, Y+3	; 0x03
    1064:	fc 81       	ldd	r31, Y+4	; 0x04
    1066:	80 83       	st	Z, r24
	pxTopOfStack--;
    1068:	8b 81       	ldd	r24, Y+3	; 0x03
    106a:	9c 81       	ldd	r25, Y+4	; 0x04
    106c:	01 97       	sbiw	r24, 0x01	; 1
    106e:	9c 83       	std	Y+4, r25	; 0x04
    1070:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1072:	89 81       	ldd	r24, Y+1	; 0x01
    1074:	9a 81       	ldd	r25, Y+2	; 0x02
    1076:	89 2f       	mov	r24, r25
    1078:	99 27       	eor	r25, r25
    107a:	9a 83       	std	Y+2, r25	; 0x02
    107c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    107e:	89 81       	ldd	r24, Y+1	; 0x01
    1080:	eb 81       	ldd	r30, Y+3	; 0x03
    1082:	fc 81       	ldd	r31, Y+4	; 0x04
    1084:	80 83       	st	Z, r24
	pxTopOfStack--;
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	9c 81       	ldd	r25, Y+4	; 0x04
    108a:	01 97       	sbiw	r24, 0x01	; 1
    108c:	9c 83       	std	Y+4, r25	; 0x04
    108e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1090:	eb 81       	ldd	r30, Y+3	; 0x03
    1092:	fc 81       	ldd	r31, Y+4	; 0x04
    1094:	10 82       	st	Z, r1
	pxTopOfStack--;
    1096:	8b 81       	ldd	r24, Y+3	; 0x03
    1098:	9c 81       	ldd	r25, Y+4	; 0x04
    109a:	01 97       	sbiw	r24, 0x01	; 1
    109c:	9c 83       	std	Y+4, r25	; 0x04
    109e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    10a0:	eb 81       	ldd	r30, Y+3	; 0x03
    10a2:	fc 81       	ldd	r31, Y+4	; 0x04
    10a4:	80 e8       	ldi	r24, 0x80	; 128
    10a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	9c 81       	ldd	r25, Y+4	; 0x04
    10ac:	01 97       	sbiw	r24, 0x01	; 1
    10ae:	9c 83       	std	Y+4, r25	; 0x04
    10b0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    10b2:	eb 81       	ldd	r30, Y+3	; 0x03
    10b4:	fc 81       	ldd	r31, Y+4	; 0x04
    10b6:	10 82       	st	Z, r1
	pxTopOfStack--;
    10b8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ba:	9c 81       	ldd	r25, Y+4	; 0x04
    10bc:	01 97       	sbiw	r24, 0x01	; 1
    10be:	9c 83       	std	Y+4, r25	; 0x04
    10c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    10c2:	eb 81       	ldd	r30, Y+3	; 0x03
    10c4:	fc 81       	ldd	r31, Y+4	; 0x04
    10c6:	82 e0       	ldi	r24, 0x02	; 2
    10c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ca:	8b 81       	ldd	r24, Y+3	; 0x03
    10cc:	9c 81       	ldd	r25, Y+4	; 0x04
    10ce:	01 97       	sbiw	r24, 0x01	; 1
    10d0:	9c 83       	std	Y+4, r25	; 0x04
    10d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    10d4:	eb 81       	ldd	r30, Y+3	; 0x03
    10d6:	fc 81       	ldd	r31, Y+4	; 0x04
    10d8:	83 e0       	ldi	r24, 0x03	; 3
    10da:	80 83       	st	Z, r24
	pxTopOfStack--;
    10dc:	8b 81       	ldd	r24, Y+3	; 0x03
    10de:	9c 81       	ldd	r25, Y+4	; 0x04
    10e0:	01 97       	sbiw	r24, 0x01	; 1
    10e2:	9c 83       	std	Y+4, r25	; 0x04
    10e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    10e6:	eb 81       	ldd	r30, Y+3	; 0x03
    10e8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ea:	84 e0       	ldi	r24, 0x04	; 4
    10ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ee:	8b 81       	ldd	r24, Y+3	; 0x03
    10f0:	9c 81       	ldd	r25, Y+4	; 0x04
    10f2:	01 97       	sbiw	r24, 0x01	; 1
    10f4:	9c 83       	std	Y+4, r25	; 0x04
    10f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    10f8:	eb 81       	ldd	r30, Y+3	; 0x03
    10fa:	fc 81       	ldd	r31, Y+4	; 0x04
    10fc:	85 e0       	ldi	r24, 0x05	; 5
    10fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1100:	8b 81       	ldd	r24, Y+3	; 0x03
    1102:	9c 81       	ldd	r25, Y+4	; 0x04
    1104:	01 97       	sbiw	r24, 0x01	; 1
    1106:	9c 83       	std	Y+4, r25	; 0x04
    1108:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    110a:	eb 81       	ldd	r30, Y+3	; 0x03
    110c:	fc 81       	ldd	r31, Y+4	; 0x04
    110e:	86 e0       	ldi	r24, 0x06	; 6
    1110:	80 83       	st	Z, r24
	pxTopOfStack--;
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	9c 81       	ldd	r25, Y+4	; 0x04
    1116:	01 97       	sbiw	r24, 0x01	; 1
    1118:	9c 83       	std	Y+4, r25	; 0x04
    111a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    111c:	eb 81       	ldd	r30, Y+3	; 0x03
    111e:	fc 81       	ldd	r31, Y+4	; 0x04
    1120:	87 e0       	ldi	r24, 0x07	; 7
    1122:	80 83       	st	Z, r24
	pxTopOfStack--;
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
    1126:	9c 81       	ldd	r25, Y+4	; 0x04
    1128:	01 97       	sbiw	r24, 0x01	; 1
    112a:	9c 83       	std	Y+4, r25	; 0x04
    112c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    112e:	eb 81       	ldd	r30, Y+3	; 0x03
    1130:	fc 81       	ldd	r31, Y+4	; 0x04
    1132:	88 e0       	ldi	r24, 0x08	; 8
    1134:	80 83       	st	Z, r24
	pxTopOfStack--;
    1136:	8b 81       	ldd	r24, Y+3	; 0x03
    1138:	9c 81       	ldd	r25, Y+4	; 0x04
    113a:	01 97       	sbiw	r24, 0x01	; 1
    113c:	9c 83       	std	Y+4, r25	; 0x04
    113e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1140:	eb 81       	ldd	r30, Y+3	; 0x03
    1142:	fc 81       	ldd	r31, Y+4	; 0x04
    1144:	89 e0       	ldi	r24, 0x09	; 9
    1146:	80 83       	st	Z, r24
	pxTopOfStack--;
    1148:	8b 81       	ldd	r24, Y+3	; 0x03
    114a:	9c 81       	ldd	r25, Y+4	; 0x04
    114c:	01 97       	sbiw	r24, 0x01	; 1
    114e:	9c 83       	std	Y+4, r25	; 0x04
    1150:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1152:	eb 81       	ldd	r30, Y+3	; 0x03
    1154:	fc 81       	ldd	r31, Y+4	; 0x04
    1156:	80 e1       	ldi	r24, 0x10	; 16
    1158:	80 83       	st	Z, r24
	pxTopOfStack--;
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	9c 81       	ldd	r25, Y+4	; 0x04
    115e:	01 97       	sbiw	r24, 0x01	; 1
    1160:	9c 83       	std	Y+4, r25	; 0x04
    1162:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1164:	eb 81       	ldd	r30, Y+3	; 0x03
    1166:	fc 81       	ldd	r31, Y+4	; 0x04
    1168:	81 e1       	ldi	r24, 0x11	; 17
    116a:	80 83       	st	Z, r24
	pxTopOfStack--;
    116c:	8b 81       	ldd	r24, Y+3	; 0x03
    116e:	9c 81       	ldd	r25, Y+4	; 0x04
    1170:	01 97       	sbiw	r24, 0x01	; 1
    1172:	9c 83       	std	Y+4, r25	; 0x04
    1174:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1176:	eb 81       	ldd	r30, Y+3	; 0x03
    1178:	fc 81       	ldd	r31, Y+4	; 0x04
    117a:	82 e1       	ldi	r24, 0x12	; 18
    117c:	80 83       	st	Z, r24
	pxTopOfStack--;
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	01 97       	sbiw	r24, 0x01	; 1
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1188:	eb 81       	ldd	r30, Y+3	; 0x03
    118a:	fc 81       	ldd	r31, Y+4	; 0x04
    118c:	83 e1       	ldi	r24, 0x13	; 19
    118e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1190:	8b 81       	ldd	r24, Y+3	; 0x03
    1192:	9c 81       	ldd	r25, Y+4	; 0x04
    1194:	01 97       	sbiw	r24, 0x01	; 1
    1196:	9c 83       	std	Y+4, r25	; 0x04
    1198:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    119a:	eb 81       	ldd	r30, Y+3	; 0x03
    119c:	fc 81       	ldd	r31, Y+4	; 0x04
    119e:	84 e1       	ldi	r24, 0x14	; 20
    11a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11a2:	8b 81       	ldd	r24, Y+3	; 0x03
    11a4:	9c 81       	ldd	r25, Y+4	; 0x04
    11a6:	01 97       	sbiw	r24, 0x01	; 1
    11a8:	9c 83       	std	Y+4, r25	; 0x04
    11aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    11ac:	eb 81       	ldd	r30, Y+3	; 0x03
    11ae:	fc 81       	ldd	r31, Y+4	; 0x04
    11b0:	85 e1       	ldi	r24, 0x15	; 21
    11b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    11b4:	8b 81       	ldd	r24, Y+3	; 0x03
    11b6:	9c 81       	ldd	r25, Y+4	; 0x04
    11b8:	01 97       	sbiw	r24, 0x01	; 1
    11ba:	9c 83       	std	Y+4, r25	; 0x04
    11bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    11be:	eb 81       	ldd	r30, Y+3	; 0x03
    11c0:	fc 81       	ldd	r31, Y+4	; 0x04
    11c2:	86 e1       	ldi	r24, 0x16	; 22
    11c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    11c6:	8b 81       	ldd	r24, Y+3	; 0x03
    11c8:	9c 81       	ldd	r25, Y+4	; 0x04
    11ca:	01 97       	sbiw	r24, 0x01	; 1
    11cc:	9c 83       	std	Y+4, r25	; 0x04
    11ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    11d0:	eb 81       	ldd	r30, Y+3	; 0x03
    11d2:	fc 81       	ldd	r31, Y+4	; 0x04
    11d4:	87 e1       	ldi	r24, 0x17	; 23
    11d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11d8:	8b 81       	ldd	r24, Y+3	; 0x03
    11da:	9c 81       	ldd	r25, Y+4	; 0x04
    11dc:	01 97       	sbiw	r24, 0x01	; 1
    11de:	9c 83       	std	Y+4, r25	; 0x04
    11e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    11e2:	eb 81       	ldd	r30, Y+3	; 0x03
    11e4:	fc 81       	ldd	r31, Y+4	; 0x04
    11e6:	88 e1       	ldi	r24, 0x18	; 24
    11e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    11ea:	8b 81       	ldd	r24, Y+3	; 0x03
    11ec:	9c 81       	ldd	r25, Y+4	; 0x04
    11ee:	01 97       	sbiw	r24, 0x01	; 1
    11f0:	9c 83       	std	Y+4, r25	; 0x04
    11f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    11f4:	eb 81       	ldd	r30, Y+3	; 0x03
    11f6:	fc 81       	ldd	r31, Y+4	; 0x04
    11f8:	89 e1       	ldi	r24, 0x19	; 25
    11fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1200:	01 97       	sbiw	r24, 0x01	; 1
    1202:	9c 83       	std	Y+4, r25	; 0x04
    1204:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1206:	eb 81       	ldd	r30, Y+3	; 0x03
    1208:	fc 81       	ldd	r31, Y+4	; 0x04
    120a:	80 e2       	ldi	r24, 0x20	; 32
    120c:	80 83       	st	Z, r24
	pxTopOfStack--;
    120e:	8b 81       	ldd	r24, Y+3	; 0x03
    1210:	9c 81       	ldd	r25, Y+4	; 0x04
    1212:	01 97       	sbiw	r24, 0x01	; 1
    1214:	9c 83       	std	Y+4, r25	; 0x04
    1216:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1218:	eb 81       	ldd	r30, Y+3	; 0x03
    121a:	fc 81       	ldd	r31, Y+4	; 0x04
    121c:	81 e2       	ldi	r24, 0x21	; 33
    121e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1220:	8b 81       	ldd	r24, Y+3	; 0x03
    1222:	9c 81       	ldd	r25, Y+4	; 0x04
    1224:	01 97       	sbiw	r24, 0x01	; 1
    1226:	9c 83       	std	Y+4, r25	; 0x04
    1228:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    122a:	eb 81       	ldd	r30, Y+3	; 0x03
    122c:	fc 81       	ldd	r31, Y+4	; 0x04
    122e:	82 e2       	ldi	r24, 0x22	; 34
    1230:	80 83       	st	Z, r24
	pxTopOfStack--;
    1232:	8b 81       	ldd	r24, Y+3	; 0x03
    1234:	9c 81       	ldd	r25, Y+4	; 0x04
    1236:	01 97       	sbiw	r24, 0x01	; 1
    1238:	9c 83       	std	Y+4, r25	; 0x04
    123a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    123c:	eb 81       	ldd	r30, Y+3	; 0x03
    123e:	fc 81       	ldd	r31, Y+4	; 0x04
    1240:	83 e2       	ldi	r24, 0x23	; 35
    1242:	80 83       	st	Z, r24
	pxTopOfStack--;
    1244:	8b 81       	ldd	r24, Y+3	; 0x03
    1246:	9c 81       	ldd	r25, Y+4	; 0x04
    1248:	01 97       	sbiw	r24, 0x01	; 1
    124a:	9c 83       	std	Y+4, r25	; 0x04
    124c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    124e:	8f 81       	ldd	r24, Y+7	; 0x07
    1250:	98 85       	ldd	r25, Y+8	; 0x08
    1252:	9a 83       	std	Y+2, r25	; 0x02
    1254:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1256:	89 81       	ldd	r24, Y+1	; 0x01
    1258:	eb 81       	ldd	r30, Y+3	; 0x03
    125a:	fc 81       	ldd	r31, Y+4	; 0x04
    125c:	80 83       	st	Z, r24
	pxTopOfStack--;
    125e:	8b 81       	ldd	r24, Y+3	; 0x03
    1260:	9c 81       	ldd	r25, Y+4	; 0x04
    1262:	01 97       	sbiw	r24, 0x01	; 1
    1264:	9c 83       	std	Y+4, r25	; 0x04
    1266:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1268:	89 81       	ldd	r24, Y+1	; 0x01
    126a:	9a 81       	ldd	r25, Y+2	; 0x02
    126c:	89 2f       	mov	r24, r25
    126e:	99 27       	eor	r25, r25
    1270:	9a 83       	std	Y+2, r25	; 0x02
    1272:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1274:	89 81       	ldd	r24, Y+1	; 0x01
    1276:	eb 81       	ldd	r30, Y+3	; 0x03
    1278:	fc 81       	ldd	r31, Y+4	; 0x04
    127a:	80 83       	st	Z, r24
	pxTopOfStack--;
    127c:	8b 81       	ldd	r24, Y+3	; 0x03
    127e:	9c 81       	ldd	r25, Y+4	; 0x04
    1280:	01 97       	sbiw	r24, 0x01	; 1
    1282:	9c 83       	std	Y+4, r25	; 0x04
    1284:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1286:	eb 81       	ldd	r30, Y+3	; 0x03
    1288:	fc 81       	ldd	r31, Y+4	; 0x04
    128a:	86 e2       	ldi	r24, 0x26	; 38
    128c:	80 83       	st	Z, r24
	pxTopOfStack--;
    128e:	8b 81       	ldd	r24, Y+3	; 0x03
    1290:	9c 81       	ldd	r25, Y+4	; 0x04
    1292:	01 97       	sbiw	r24, 0x01	; 1
    1294:	9c 83       	std	Y+4, r25	; 0x04
    1296:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1298:	eb 81       	ldd	r30, Y+3	; 0x03
    129a:	fc 81       	ldd	r31, Y+4	; 0x04
    129c:	87 e2       	ldi	r24, 0x27	; 39
    129e:	80 83       	st	Z, r24
	pxTopOfStack--;
    12a0:	8b 81       	ldd	r24, Y+3	; 0x03
    12a2:	9c 81       	ldd	r25, Y+4	; 0x04
    12a4:	01 97       	sbiw	r24, 0x01	; 1
    12a6:	9c 83       	std	Y+4, r25	; 0x04
    12a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    12aa:	eb 81       	ldd	r30, Y+3	; 0x03
    12ac:	fc 81       	ldd	r31, Y+4	; 0x04
    12ae:	88 e2       	ldi	r24, 0x28	; 40
    12b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12b2:	8b 81       	ldd	r24, Y+3	; 0x03
    12b4:	9c 81       	ldd	r25, Y+4	; 0x04
    12b6:	01 97       	sbiw	r24, 0x01	; 1
    12b8:	9c 83       	std	Y+4, r25	; 0x04
    12ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    12bc:	eb 81       	ldd	r30, Y+3	; 0x03
    12be:	fc 81       	ldd	r31, Y+4	; 0x04
    12c0:	89 e2       	ldi	r24, 0x29	; 41
    12c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12c4:	8b 81       	ldd	r24, Y+3	; 0x03
    12c6:	9c 81       	ldd	r25, Y+4	; 0x04
    12c8:	01 97       	sbiw	r24, 0x01	; 1
    12ca:	9c 83       	std	Y+4, r25	; 0x04
    12cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    12ce:	eb 81       	ldd	r30, Y+3	; 0x03
    12d0:	fc 81       	ldd	r31, Y+4	; 0x04
    12d2:	80 e3       	ldi	r24, 0x30	; 48
    12d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    12d6:	8b 81       	ldd	r24, Y+3	; 0x03
    12d8:	9c 81       	ldd	r25, Y+4	; 0x04
    12da:	01 97       	sbiw	r24, 0x01	; 1
    12dc:	9c 83       	std	Y+4, r25	; 0x04
    12de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    12e0:	eb 81       	ldd	r30, Y+3	; 0x03
    12e2:	fc 81       	ldd	r31, Y+4	; 0x04
    12e4:	81 e3       	ldi	r24, 0x31	; 49
    12e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ea:	9c 81       	ldd	r25, Y+4	; 0x04
    12ec:	01 97       	sbiw	r24, 0x01	; 1
    12ee:	9c 83       	std	Y+4, r25	; 0x04
    12f0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    12f6:	28 96       	adiw	r28, 0x08	; 8
    12f8:	0f b6       	in	r0, 0x3f	; 63
    12fa:	f8 94       	cli
    12fc:	de bf       	out	0x3e, r29	; 62
    12fe:	0f be       	out	0x3f, r0	; 63
    1300:	cd bf       	out	0x3d, r28	; 61
    1302:	cf 91       	pop	r28
    1304:	df 91       	pop	r29
    1306:	08 95       	ret

00001308 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1308:	df 93       	push	r29
    130a:	cf 93       	push	r28
    130c:	cd b7       	in	r28, 0x3d	; 61
    130e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1310:	0e 94 76 0a 	call	0x14ec	; 0x14ec <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1314:	a0 91 5a 04 	lds	r26, 0x045A
    1318:	b0 91 5b 04 	lds	r27, 0x045B
    131c:	cd 91       	ld	r28, X+
    131e:	cd bf       	out	0x3d, r28	; 61
    1320:	dd 91       	ld	r29, X+
    1322:	de bf       	out	0x3e, r29	; 62
    1324:	ff 91       	pop	r31
    1326:	ef 91       	pop	r30
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	bf 91       	pop	r27
    132e:	af 91       	pop	r26
    1330:	9f 91       	pop	r25
    1332:	8f 91       	pop	r24
    1334:	7f 91       	pop	r23
    1336:	6f 91       	pop	r22
    1338:	5f 91       	pop	r21
    133a:	4f 91       	pop	r20
    133c:	3f 91       	pop	r19
    133e:	2f 91       	pop	r18
    1340:	1f 91       	pop	r17
    1342:	0f 91       	pop	r16
    1344:	ff 90       	pop	r15
    1346:	ef 90       	pop	r14
    1348:	df 90       	pop	r13
    134a:	cf 90       	pop	r12
    134c:	bf 90       	pop	r11
    134e:	af 90       	pop	r10
    1350:	9f 90       	pop	r9
    1352:	8f 90       	pop	r8
    1354:	7f 90       	pop	r7
    1356:	6f 90       	pop	r6
    1358:	5f 90       	pop	r5
    135a:	4f 90       	pop	r4
    135c:	3f 90       	pop	r3
    135e:	2f 90       	pop	r2
    1360:	1f 90       	pop	r1
    1362:	0f 90       	pop	r0
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1368:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    136a:	81 e0       	ldi	r24, 0x01	; 1
}
    136c:	cf 91       	pop	r28
    136e:	df 91       	pop	r29
    1370:	08 95       	ret

00001372 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1372:	df 93       	push	r29
    1374:	cf 93       	push	r28
    1376:	cd b7       	in	r28, 0x3d	; 61
    1378:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    137a:	cf 91       	pop	r28
    137c:	df 91       	pop	r29
    137e:	08 95       	ret

00001380 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1380:	0f 92       	push	r0
    1382:	0f b6       	in	r0, 0x3f	; 63
    1384:	f8 94       	cli
    1386:	0f 92       	push	r0
    1388:	1f 92       	push	r1
    138a:	11 24       	eor	r1, r1
    138c:	2f 92       	push	r2
    138e:	3f 92       	push	r3
    1390:	4f 92       	push	r4
    1392:	5f 92       	push	r5
    1394:	6f 92       	push	r6
    1396:	7f 92       	push	r7
    1398:	8f 92       	push	r8
    139a:	9f 92       	push	r9
    139c:	af 92       	push	r10
    139e:	bf 92       	push	r11
    13a0:	cf 92       	push	r12
    13a2:	df 92       	push	r13
    13a4:	ef 92       	push	r14
    13a6:	ff 92       	push	r15
    13a8:	0f 93       	push	r16
    13aa:	1f 93       	push	r17
    13ac:	2f 93       	push	r18
    13ae:	3f 93       	push	r19
    13b0:	4f 93       	push	r20
    13b2:	5f 93       	push	r21
    13b4:	6f 93       	push	r22
    13b6:	7f 93       	push	r23
    13b8:	8f 93       	push	r24
    13ba:	9f 93       	push	r25
    13bc:	af 93       	push	r26
    13be:	bf 93       	push	r27
    13c0:	cf 93       	push	r28
    13c2:	df 93       	push	r29
    13c4:	ef 93       	push	r30
    13c6:	ff 93       	push	r31
    13c8:	a0 91 5a 04 	lds	r26, 0x045A
    13cc:	b0 91 5b 04 	lds	r27, 0x045B
    13d0:	0d b6       	in	r0, 0x3d	; 61
    13d2:	0d 92       	st	X+, r0
    13d4:	0e b6       	in	r0, 0x3e	; 62
    13d6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    13d8:	0e 94 a1 19 	call	0x3342	; 0x3342 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13dc:	a0 91 5a 04 	lds	r26, 0x045A
    13e0:	b0 91 5b 04 	lds	r27, 0x045B
    13e4:	cd 91       	ld	r28, X+
    13e6:	cd bf       	out	0x3d, r28	; 61
    13e8:	dd 91       	ld	r29, X+
    13ea:	de bf       	out	0x3e, r29	; 62
    13ec:	ff 91       	pop	r31
    13ee:	ef 91       	pop	r30
    13f0:	df 91       	pop	r29
    13f2:	cf 91       	pop	r28
    13f4:	bf 91       	pop	r27
    13f6:	af 91       	pop	r26
    13f8:	9f 91       	pop	r25
    13fa:	8f 91       	pop	r24
    13fc:	7f 91       	pop	r23
    13fe:	6f 91       	pop	r22
    1400:	5f 91       	pop	r21
    1402:	4f 91       	pop	r20
    1404:	3f 91       	pop	r19
    1406:	2f 91       	pop	r18
    1408:	1f 91       	pop	r17
    140a:	0f 91       	pop	r16
    140c:	ff 90       	pop	r15
    140e:	ef 90       	pop	r14
    1410:	df 90       	pop	r13
    1412:	cf 90       	pop	r12
    1414:	bf 90       	pop	r11
    1416:	af 90       	pop	r10
    1418:	9f 90       	pop	r9
    141a:	8f 90       	pop	r8
    141c:	7f 90       	pop	r7
    141e:	6f 90       	pop	r6
    1420:	5f 90       	pop	r5
    1422:	4f 90       	pop	r4
    1424:	3f 90       	pop	r3
    1426:	2f 90       	pop	r2
    1428:	1f 90       	pop	r1
    142a:	0f 90       	pop	r0
    142c:	0f be       	out	0x3f, r0	; 63
    142e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1430:	08 95       	ret

00001432 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1432:	0f 92       	push	r0
    1434:	0f b6       	in	r0, 0x3f	; 63
    1436:	f8 94       	cli
    1438:	0f 92       	push	r0
    143a:	1f 92       	push	r1
    143c:	11 24       	eor	r1, r1
    143e:	2f 92       	push	r2
    1440:	3f 92       	push	r3
    1442:	4f 92       	push	r4
    1444:	5f 92       	push	r5
    1446:	6f 92       	push	r6
    1448:	7f 92       	push	r7
    144a:	8f 92       	push	r8
    144c:	9f 92       	push	r9
    144e:	af 92       	push	r10
    1450:	bf 92       	push	r11
    1452:	cf 92       	push	r12
    1454:	df 92       	push	r13
    1456:	ef 92       	push	r14
    1458:	ff 92       	push	r15
    145a:	0f 93       	push	r16
    145c:	1f 93       	push	r17
    145e:	2f 93       	push	r18
    1460:	3f 93       	push	r19
    1462:	4f 93       	push	r20
    1464:	5f 93       	push	r21
    1466:	6f 93       	push	r22
    1468:	7f 93       	push	r23
    146a:	8f 93       	push	r24
    146c:	9f 93       	push	r25
    146e:	af 93       	push	r26
    1470:	bf 93       	push	r27
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	ef 93       	push	r30
    1478:	ff 93       	push	r31
    147a:	a0 91 5a 04 	lds	r26, 0x045A
    147e:	b0 91 5b 04 	lds	r27, 0x045B
    1482:	0d b6       	in	r0, 0x3d	; 61
    1484:	0d 92       	st	X+, r0
    1486:	0e b6       	in	r0, 0x3e	; 62
    1488:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    148a:	0e 94 b8 18 	call	0x3170	; 0x3170 <xTaskIncrementTick>
    148e:	88 23       	and	r24, r24
    1490:	11 f0       	breq	.+4      	; 0x1496 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1492:	0e 94 a1 19 	call	0x3342	; 0x3342 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1496:	a0 91 5a 04 	lds	r26, 0x045A
    149a:	b0 91 5b 04 	lds	r27, 0x045B
    149e:	cd 91       	ld	r28, X+
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	dd 91       	ld	r29, X+
    14a4:	de bf       	out	0x3e, r29	; 62
    14a6:	ff 91       	pop	r31
    14a8:	ef 91       	pop	r30
    14aa:	df 91       	pop	r29
    14ac:	cf 91       	pop	r28
    14ae:	bf 91       	pop	r27
    14b0:	af 91       	pop	r26
    14b2:	9f 91       	pop	r25
    14b4:	8f 91       	pop	r24
    14b6:	7f 91       	pop	r23
    14b8:	6f 91       	pop	r22
    14ba:	5f 91       	pop	r21
    14bc:	4f 91       	pop	r20
    14be:	3f 91       	pop	r19
    14c0:	2f 91       	pop	r18
    14c2:	1f 91       	pop	r17
    14c4:	0f 91       	pop	r16
    14c6:	ff 90       	pop	r15
    14c8:	ef 90       	pop	r14
    14ca:	df 90       	pop	r13
    14cc:	cf 90       	pop	r12
    14ce:	bf 90       	pop	r11
    14d0:	af 90       	pop	r10
    14d2:	9f 90       	pop	r9
    14d4:	8f 90       	pop	r8
    14d6:	7f 90       	pop	r7
    14d8:	6f 90       	pop	r6
    14da:	5f 90       	pop	r5
    14dc:	4f 90       	pop	r4
    14de:	3f 90       	pop	r3
    14e0:	2f 90       	pop	r2
    14e2:	1f 90       	pop	r1
    14e4:	0f 90       	pop	r0
    14e6:	0f be       	out	0x3f, r0	; 63
    14e8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14ea:	08 95       	ret

000014ec <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    14ec:	df 93       	push	r29
    14ee:	cf 93       	push	r28
    14f0:	00 d0       	rcall	.+0      	; 0x14f2 <prvSetupTimerInterrupt+0x6>
    14f2:	00 d0       	rcall	.+0      	; 0x14f4 <prvSetupTimerInterrupt+0x8>
    14f4:	00 d0       	rcall	.+0      	; 0x14f6 <prvSetupTimerInterrupt+0xa>
    14f6:	cd b7       	in	r28, 0x3d	; 61
    14f8:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    14fa:	80 e4       	ldi	r24, 0x40	; 64
    14fc:	9f e1       	ldi	r25, 0x1F	; 31
    14fe:	a0 e0       	ldi	r26, 0x00	; 0
    1500:	b0 e0       	ldi	r27, 0x00	; 0
    1502:	8b 83       	std	Y+3, r24	; 0x03
    1504:	9c 83       	std	Y+4, r25	; 0x04
    1506:	ad 83       	std	Y+5, r26	; 0x05
    1508:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    150a:	8b 81       	ldd	r24, Y+3	; 0x03
    150c:	9c 81       	ldd	r25, Y+4	; 0x04
    150e:	ad 81       	ldd	r26, Y+5	; 0x05
    1510:	be 81       	ldd	r27, Y+6	; 0x06
    1512:	68 94       	set
    1514:	15 f8       	bld	r1, 5
    1516:	b6 95       	lsr	r27
    1518:	a7 95       	ror	r26
    151a:	97 95       	ror	r25
    151c:	87 95       	ror	r24
    151e:	16 94       	lsr	r1
    1520:	d1 f7       	brne	.-12     	; 0x1516 <prvSetupTimerInterrupt+0x2a>
    1522:	8b 83       	std	Y+3, r24	; 0x03
    1524:	9c 83       	std	Y+4, r25	; 0x04
    1526:	ad 83       	std	Y+5, r26	; 0x05
    1528:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    152a:	8b 81       	ldd	r24, Y+3	; 0x03
    152c:	9c 81       	ldd	r25, Y+4	; 0x04
    152e:	ad 81       	ldd	r26, Y+5	; 0x05
    1530:	be 81       	ldd	r27, Y+6	; 0x06
    1532:	01 97       	sbiw	r24, 0x01	; 1
    1534:	a1 09       	sbc	r26, r1
    1536:	b1 09       	sbc	r27, r1
    1538:	8b 83       	std	Y+3, r24	; 0x03
    153a:	9c 83       	std	Y+4, r25	; 0x04
    153c:	ad 83       	std	Y+5, r26	; 0x05
    153e:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1540:	8b 81       	ldd	r24, Y+3	; 0x03
    1542:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	9c 81       	ldd	r25, Y+4	; 0x04
    1548:	ad 81       	ldd	r26, Y+5	; 0x05
    154a:	be 81       	ldd	r27, Y+6	; 0x06
    154c:	89 2f       	mov	r24, r25
    154e:	9a 2f       	mov	r25, r26
    1550:	ab 2f       	mov	r26, r27
    1552:	bb 27       	eor	r27, r27
    1554:	8b 83       	std	Y+3, r24	; 0x03
    1556:	9c 83       	std	Y+4, r25	; 0x04
    1558:	ad 83       	std	Y+5, r26	; 0x05
    155a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    155c:	8b 81       	ldd	r24, Y+3	; 0x03
    155e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1560:	eb e4       	ldi	r30, 0x4B	; 75
    1562:	f0 e0       	ldi	r31, 0x00	; 0
    1564:	8a 81       	ldd	r24, Y+2	; 0x02
    1566:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1568:	ea e4       	ldi	r30, 0x4A	; 74
    156a:	f0 e0       	ldi	r31, 0x00	; 0
    156c:	89 81       	ldd	r24, Y+1	; 0x01
    156e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1570:	8b e0       	ldi	r24, 0x0B	; 11
    1572:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1574:	ee e4       	ldi	r30, 0x4E	; 78
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	89 81       	ldd	r24, Y+1	; 0x01
    157a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    157c:	e9 e5       	ldi	r30, 0x59	; 89
    157e:	f0 e0       	ldi	r31, 0x00	; 0
    1580:	80 81       	ld	r24, Z
    1582:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1584:	89 81       	ldd	r24, Y+1	; 0x01
    1586:	80 61       	ori	r24, 0x10	; 16
    1588:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    158a:	e9 e5       	ldi	r30, 0x59	; 89
    158c:	f0 e0       	ldi	r31, 0x00	; 0
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	80 83       	st	Z, r24
}
    1592:	26 96       	adiw	r28, 0x06	; 6
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	cd bf       	out	0x3d, r28	; 61
    159e:	cf 91       	pop	r28
    15a0:	df 91       	pop	r29
    15a2:	08 95       	ret

000015a4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    15a4:	0e 94 19 0a 	call	0x1432	; 0x1432 <vPortYieldFromTick>
		asm volatile ( "reti" );
    15a8:	18 95       	reti

000015aa <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    15aa:	df 93       	push	r29
    15ac:	cf 93       	push	r28
    15ae:	00 d0       	rcall	.+0      	; 0x15b0 <xQueueGenericReset+0x6>
    15b0:	00 d0       	rcall	.+0      	; 0x15b2 <xQueueGenericReset+0x8>
    15b2:	0f 92       	push	r0
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
    15b8:	9c 83       	std	Y+4, r25	; 0x04
    15ba:	8b 83       	std	Y+3, r24	; 0x03
    15bc:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    15be:	8b 81       	ldd	r24, Y+3	; 0x03
    15c0:	9c 81       	ldd	r25, Y+4	; 0x04
    15c2:	9a 83       	std	Y+2, r25	; 0x02
    15c4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	40 81       	ld	r20, Z
    15d2:	51 81       	ldd	r21, Z+1	; 0x01
    15d4:	e9 81       	ldd	r30, Y+1	; 0x01
    15d6:	fa 81       	ldd	r31, Y+2	; 0x02
    15d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    15da:	28 2f       	mov	r18, r24
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	e9 81       	ldd	r30, Y+1	; 0x01
    15e0:	fa 81       	ldd	r31, Y+2	; 0x02
    15e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    15e4:	88 2f       	mov	r24, r24
    15e6:	90 e0       	ldi	r25, 0x00	; 0
    15e8:	bc 01       	movw	r22, r24
    15ea:	26 9f       	mul	r18, r22
    15ec:	c0 01       	movw	r24, r0
    15ee:	27 9f       	mul	r18, r23
    15f0:	90 0d       	add	r25, r0
    15f2:	36 9f       	mul	r19, r22
    15f4:	90 0d       	add	r25, r0
    15f6:	11 24       	eor	r1, r1
    15f8:	84 0f       	add	r24, r20
    15fa:	95 1f       	adc	r25, r21
    15fc:	e9 81       	ldd	r30, Y+1	; 0x01
    15fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1600:	95 83       	std	Z+5, r25	; 0x05
    1602:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1604:	e9 81       	ldd	r30, Y+1	; 0x01
    1606:	fa 81       	ldd	r31, Y+2	; 0x02
    1608:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    160a:	e9 81       	ldd	r30, Y+1	; 0x01
    160c:	fa 81       	ldd	r31, Y+2	; 0x02
    160e:	80 81       	ld	r24, Z
    1610:	91 81       	ldd	r25, Z+1	; 0x01
    1612:	e9 81       	ldd	r30, Y+1	; 0x01
    1614:	fa 81       	ldd	r31, Y+2	; 0x02
    1616:	93 83       	std	Z+3, r25	; 0x03
    1618:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    161a:	e9 81       	ldd	r30, Y+1	; 0x01
    161c:	fa 81       	ldd	r31, Y+2	; 0x02
    161e:	40 81       	ld	r20, Z
    1620:	51 81       	ldd	r21, Z+1	; 0x01
    1622:	e9 81       	ldd	r30, Y+1	; 0x01
    1624:	fa 81       	ldd	r31, Y+2	; 0x02
    1626:	83 8d       	ldd	r24, Z+27	; 0x1b
    1628:	88 2f       	mov	r24, r24
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	9c 01       	movw	r18, r24
    162e:	21 50       	subi	r18, 0x01	; 1
    1630:	30 40       	sbci	r19, 0x00	; 0
    1632:	e9 81       	ldd	r30, Y+1	; 0x01
    1634:	fa 81       	ldd	r31, Y+2	; 0x02
    1636:	84 8d       	ldd	r24, Z+28	; 0x1c
    1638:	88 2f       	mov	r24, r24
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	bc 01       	movw	r22, r24
    163e:	26 9f       	mul	r18, r22
    1640:	c0 01       	movw	r24, r0
    1642:	27 9f       	mul	r18, r23
    1644:	90 0d       	add	r25, r0
    1646:	36 9f       	mul	r19, r22
    1648:	90 0d       	add	r25, r0
    164a:	11 24       	eor	r1, r1
    164c:	84 0f       	add	r24, r20
    164e:	95 1f       	adc	r25, r21
    1650:	e9 81       	ldd	r30, Y+1	; 0x01
    1652:	fa 81       	ldd	r31, Y+2	; 0x02
    1654:	97 83       	std	Z+7, r25	; 0x07
    1656:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1658:	e9 81       	ldd	r30, Y+1	; 0x01
    165a:	fa 81       	ldd	r31, Y+2	; 0x02
    165c:	8f ef       	ldi	r24, 0xFF	; 255
    165e:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1660:	e9 81       	ldd	r30, Y+1	; 0x01
    1662:	fa 81       	ldd	r31, Y+2	; 0x02
    1664:	8f ef       	ldi	r24, 0xFF	; 255
    1666:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1668:	8d 81       	ldd	r24, Y+5	; 0x05
    166a:	88 23       	and	r24, r24
    166c:	79 f4       	brne	.+30     	; 0x168c <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    166e:	e9 81       	ldd	r30, Y+1	; 0x01
    1670:	fa 81       	ldd	r31, Y+2	; 0x02
    1672:	80 85       	ldd	r24, Z+8	; 0x08
    1674:	88 23       	and	r24, r24
    1676:	a1 f0       	breq	.+40     	; 0x16a0 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1678:	89 81       	ldd	r24, Y+1	; 0x01
    167a:	9a 81       	ldd	r25, Y+2	; 0x02
    167c:	08 96       	adiw	r24, 0x08	; 8
    167e:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1682:	88 23       	and	r24, r24
    1684:	69 f0       	breq	.+26     	; 0x16a0 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1686:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    168a:	0a c0       	rjmp	.+20     	; 0x16a0 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    168c:	89 81       	ldd	r24, Y+1	; 0x01
    168e:	9a 81       	ldd	r25, Y+2	; 0x02
    1690:	08 96       	adiw	r24, 0x08	; 8
    1692:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1696:	89 81       	ldd	r24, Y+1	; 0x01
    1698:	9a 81       	ldd	r25, Y+2	; 0x02
    169a:	41 96       	adiw	r24, 0x11	; 17
    169c:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    16a4:	81 e0       	ldi	r24, 0x01	; 1
}
    16a6:	0f 90       	pop	r0
    16a8:	0f 90       	pop	r0
    16aa:	0f 90       	pop	r0
    16ac:	0f 90       	pop	r0
    16ae:	0f 90       	pop	r0
    16b0:	cf 91       	pop	r28
    16b2:	df 91       	pop	r29
    16b4:	08 95       	ret

000016b6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    16b6:	0f 93       	push	r16
    16b8:	1f 93       	push	r17
    16ba:	df 93       	push	r29
    16bc:	cf 93       	push	r28
    16be:	cd b7       	in	r28, 0x3d	; 61
    16c0:	de b7       	in	r29, 0x3e	; 62
    16c2:	29 97       	sbiw	r28, 0x09	; 9
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	de bf       	out	0x3e, r29	; 62
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	cd bf       	out	0x3d, r28	; 61
    16ce:	8f 83       	std	Y+7, r24	; 0x07
    16d0:	68 87       	std	Y+8, r22	; 0x08
    16d2:	49 87       	std	Y+9, r20	; 0x09
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16d4:	8f 81       	ldd	r24, Y+7	; 0x07
    16d6:	28 2f       	mov	r18, r24
    16d8:	30 e0       	ldi	r19, 0x00	; 0
    16da:	88 85       	ldd	r24, Y+8	; 0x08
    16dc:	88 2f       	mov	r24, r24
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	ac 01       	movw	r20, r24
    16e2:	24 9f       	mul	r18, r20
    16e4:	c0 01       	movw	r24, r0
    16e6:	25 9f       	mul	r18, r21
    16e8:	90 0d       	add	r25, r0
    16ea:	34 9f       	mul	r19, r20
    16ec:	90 0d       	add	r25, r0
    16ee:	11 24       	eor	r1, r1
    16f0:	9c 83       	std	Y+4, r25	; 0x04
    16f2:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    16f4:	8b 81       	ldd	r24, Y+3	; 0x03
    16f6:	9c 81       	ldd	r25, Y+4	; 0x04
    16f8:	4f 96       	adiw	r24, 0x1f	; 31
    16fa:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    16fe:	9e 83       	std	Y+6, r25	; 0x06
    1700:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1702:	8d 81       	ldd	r24, Y+5	; 0x05
    1704:	9e 81       	ldd	r25, Y+6	; 0x06
    1706:	00 97       	sbiw	r24, 0x00	; 0
    1708:	a1 f0       	breq	.+40     	; 0x1732 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    170a:	8d 81       	ldd	r24, Y+5	; 0x05
    170c:	9e 81       	ldd	r25, Y+6	; 0x06
    170e:	9a 83       	std	Y+2, r25	; 0x02
    1710:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1712:	89 81       	ldd	r24, Y+1	; 0x01
    1714:	9a 81       	ldd	r25, Y+2	; 0x02
    1716:	4f 96       	adiw	r24, 0x1f	; 31
    1718:	9a 83       	std	Y+2, r25	; 0x02
    171a:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    171c:	29 81       	ldd	r18, Y+1	; 0x01
    171e:	3a 81       	ldd	r19, Y+2	; 0x02
    1720:	ed 81       	ldd	r30, Y+5	; 0x05
    1722:	fe 81       	ldd	r31, Y+6	; 0x06
    1724:	8f 81       	ldd	r24, Y+7	; 0x07
    1726:	68 85       	ldd	r22, Y+8	; 0x08
    1728:	a9 01       	movw	r20, r18
    172a:	29 85       	ldd	r18, Y+9	; 0x09
    172c:	8f 01       	movw	r16, r30
    172e:	0e 94 a6 0b 	call	0x174c	; 0x174c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1732:	8d 81       	ldd	r24, Y+5	; 0x05
    1734:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1736:	29 96       	adiw	r28, 0x09	; 9
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	f8 94       	cli
    173c:	de bf       	out	0x3e, r29	; 62
    173e:	0f be       	out	0x3f, r0	; 63
    1740:	cd bf       	out	0x3d, r28	; 61
    1742:	cf 91       	pop	r28
    1744:	df 91       	pop	r29
    1746:	1f 91       	pop	r17
    1748:	0f 91       	pop	r16
    174a:	08 95       	ret

0000174c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    174c:	0f 93       	push	r16
    174e:	1f 93       	push	r17
    1750:	df 93       	push	r29
    1752:	cf 93       	push	r28
    1754:	cd b7       	in	r28, 0x3d	; 61
    1756:	de b7       	in	r29, 0x3e	; 62
    1758:	27 97       	sbiw	r28, 0x07	; 7
    175a:	0f b6       	in	r0, 0x3f	; 63
    175c:	f8 94       	cli
    175e:	de bf       	out	0x3e, r29	; 62
    1760:	0f be       	out	0x3f, r0	; 63
    1762:	cd bf       	out	0x3d, r28	; 61
    1764:	89 83       	std	Y+1, r24	; 0x01
    1766:	6a 83       	std	Y+2, r22	; 0x02
    1768:	5c 83       	std	Y+4, r21	; 0x04
    176a:	4b 83       	std	Y+3, r20	; 0x03
    176c:	2d 83       	std	Y+5, r18	; 0x05
    176e:	1f 83       	std	Y+7, r17	; 0x07
    1770:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1772:	8a 81       	ldd	r24, Y+2	; 0x02
    1774:	88 23       	and	r24, r24
    1776:	39 f4       	brne	.+14     	; 0x1786 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1778:	8e 81       	ldd	r24, Y+6	; 0x06
    177a:	9f 81       	ldd	r25, Y+7	; 0x07
    177c:	ee 81       	ldd	r30, Y+6	; 0x06
    177e:	ff 81       	ldd	r31, Y+7	; 0x07
    1780:	91 83       	std	Z+1, r25	; 0x01
    1782:	80 83       	st	Z, r24
    1784:	06 c0       	rjmp	.+12     	; 0x1792 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1786:	8b 81       	ldd	r24, Y+3	; 0x03
    1788:	9c 81       	ldd	r25, Y+4	; 0x04
    178a:	ee 81       	ldd	r30, Y+6	; 0x06
    178c:	ff 81       	ldd	r31, Y+7	; 0x07
    178e:	91 83       	std	Z+1, r25	; 0x01
    1790:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1792:	ee 81       	ldd	r30, Y+6	; 0x06
    1794:	ff 81       	ldd	r31, Y+7	; 0x07
    1796:	89 81       	ldd	r24, Y+1	; 0x01
    1798:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    179a:	ee 81       	ldd	r30, Y+6	; 0x06
    179c:	ff 81       	ldd	r31, Y+7	; 0x07
    179e:	8a 81       	ldd	r24, Y+2	; 0x02
    17a0:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    17a2:	8e 81       	ldd	r24, Y+6	; 0x06
    17a4:	9f 81       	ldd	r25, Y+7	; 0x07
    17a6:	61 e0       	ldi	r22, 0x01	; 1
    17a8:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    17ac:	27 96       	adiw	r28, 0x07	; 7
    17ae:	0f b6       	in	r0, 0x3f	; 63
    17b0:	f8 94       	cli
    17b2:	de bf       	out	0x3e, r29	; 62
    17b4:	0f be       	out	0x3f, r0	; 63
    17b6:	cd bf       	out	0x3d, r28	; 61
    17b8:	cf 91       	pop	r28
    17ba:	df 91       	pop	r29
    17bc:	1f 91       	pop	r17
    17be:	0f 91       	pop	r16
    17c0:	08 95       	ret

000017c2 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    17c2:	df 93       	push	r29
    17c4:	cf 93       	push	r28
    17c6:	00 d0       	rcall	.+0      	; 0x17c8 <xQueueCreateCountingSemaphore+0x6>
    17c8:	00 d0       	rcall	.+0      	; 0x17ca <xQueueCreateCountingSemaphore+0x8>
    17ca:	cd b7       	in	r28, 0x3d	; 61
    17cc:	de b7       	in	r29, 0x3e	; 62
    17ce:	8b 83       	std	Y+3, r24	; 0x03
    17d0:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    17d2:	8b 81       	ldd	r24, Y+3	; 0x03
    17d4:	60 e0       	ldi	r22, 0x00	; 0
    17d6:	42 e0       	ldi	r20, 0x02	; 2
    17d8:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <xQueueGenericCreate>
    17dc:	9a 83       	std	Y+2, r25	; 0x02
    17de:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    17e0:	89 81       	ldd	r24, Y+1	; 0x01
    17e2:	9a 81       	ldd	r25, Y+2	; 0x02
    17e4:	00 97       	sbiw	r24, 0x00	; 0
    17e6:	21 f0       	breq	.+8      	; 0x17f0 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    17e8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ea:	fa 81       	ldd	r31, Y+2	; 0x02
    17ec:	8c 81       	ldd	r24, Y+4	; 0x04
    17ee:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    17f0:	89 81       	ldd	r24, Y+1	; 0x01
    17f2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    17f4:	0f 90       	pop	r0
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	0f 90       	pop	r0
    17fc:	cf 91       	pop	r28
    17fe:	df 91       	pop	r29
    1800:	08 95       	ret

00001802 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1802:	df 93       	push	r29
    1804:	cf 93       	push	r28
    1806:	cd b7       	in	r28, 0x3d	; 61
    1808:	de b7       	in	r29, 0x3e	; 62
    180a:	2f 97       	sbiw	r28, 0x0f	; 15
    180c:	0f b6       	in	r0, 0x3f	; 63
    180e:	f8 94       	cli
    1810:	de bf       	out	0x3e, r29	; 62
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	cd bf       	out	0x3d, r28	; 61
    1816:	99 87       	std	Y+9, r25	; 0x09
    1818:	88 87       	std	Y+8, r24	; 0x08
    181a:	7b 87       	std	Y+11, r23	; 0x0b
    181c:	6a 87       	std	Y+10, r22	; 0x0a
    181e:	5d 87       	std	Y+13, r21	; 0x0d
    1820:	4c 87       	std	Y+12, r20	; 0x0c
    1822:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1824:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1826:	88 85       	ldd	r24, Y+8	; 0x08
    1828:	99 85       	ldd	r25, Y+9	; 0x09
    182a:	9a 83       	std	Y+2, r25	; 0x02
    182c:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1834:	e9 81       	ldd	r30, Y+1	; 0x01
    1836:	fa 81       	ldd	r31, Y+2	; 0x02
    1838:	92 8d       	ldd	r25, Z+26	; 0x1a
    183a:	e9 81       	ldd	r30, Y+1	; 0x01
    183c:	fa 81       	ldd	r31, Y+2	; 0x02
    183e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1840:	98 17       	cp	r25, r24
    1842:	18 f0       	brcs	.+6      	; 0x184a <xQueueGenericSend+0x48>
    1844:	8e 85       	ldd	r24, Y+14	; 0x0e
    1846:	82 30       	cpi	r24, 0x02	; 2
    1848:	11 f5       	brne	.+68     	; 0x188e <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    184a:	89 81       	ldd	r24, Y+1	; 0x01
    184c:	9a 81       	ldd	r25, Y+2	; 0x02
    184e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1850:	3b 85       	ldd	r19, Y+11	; 0x0b
    1852:	b9 01       	movw	r22, r18
    1854:	4e 85       	ldd	r20, Y+14	; 0x0e
    1856:	0e 94 57 10 	call	0x20ae	; 0x20ae <prvCopyDataToQueue>
    185a:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    185c:	e9 81       	ldd	r30, Y+1	; 0x01
    185e:	fa 81       	ldd	r31, Y+2	; 0x02
    1860:	81 89       	ldd	r24, Z+17	; 0x11
    1862:	88 23       	and	r24, r24
    1864:	51 f0       	breq	.+20     	; 0x187a <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1866:	89 81       	ldd	r24, Y+1	; 0x01
    1868:	9a 81       	ldd	r25, Y+2	; 0x02
    186a:	41 96       	adiw	r24, 0x11	; 17
    186c:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1870:	88 23       	and	r24, r24
    1872:	41 f0       	breq	.+16     	; 0x1884 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1874:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    1878:	05 c0       	rjmp	.+10     	; 0x1884 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    187a:	8b 81       	ldd	r24, Y+3	; 0x03
    187c:	88 23       	and	r24, r24
    187e:	11 f0       	breq	.+4      	; 0x1884 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1880:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	8f 87       	std	Y+15, r24	; 0x0f
    188c:	5c c0       	rjmp	.+184    	; 0x1946 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    188e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1890:	9d 85       	ldd	r25, Y+13	; 0x0d
    1892:	00 97       	sbiw	r24, 0x00	; 0
    1894:	21 f4       	brne	.+8      	; 0x189e <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1896:	0f 90       	pop	r0
    1898:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    189a:	1f 86       	std	Y+15, r1	; 0x0f
    189c:	54 c0       	rjmp	.+168    	; 0x1946 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    189e:	8c 81       	ldd	r24, Y+4	; 0x04
    18a0:	88 23       	and	r24, r24
    18a2:	31 f4       	brne	.+12     	; 0x18b0 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    18a4:	ce 01       	movw	r24, r28
    18a6:	05 96       	adiw	r24, 0x05	; 5
    18a8:	0e 94 46 1b 	call	0x368c	; 0x368c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18ac:	81 e0       	ldi	r24, 0x01	; 1
    18ae:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18b0:	0f 90       	pop	r0
    18b2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18b4:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	0f 92       	push	r0
    18be:	e9 81       	ldd	r30, Y+1	; 0x01
    18c0:	fa 81       	ldd	r31, Y+2	; 0x02
    18c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    18c4:	8f 3f       	cpi	r24, 0xFF	; 255
    18c6:	19 f4       	brne	.+6      	; 0x18ce <xQueueGenericSend+0xcc>
    18c8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ca:	fa 81       	ldd	r31, Y+2	; 0x02
    18cc:	15 8e       	std	Z+29, r1	; 0x1d
    18ce:	e9 81       	ldd	r30, Y+1	; 0x01
    18d0:	fa 81       	ldd	r31, Y+2	; 0x02
    18d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    18d4:	8f 3f       	cpi	r24, 0xFF	; 255
    18d6:	19 f4       	brne	.+6      	; 0x18de <xQueueGenericSend+0xdc>
    18d8:	e9 81       	ldd	r30, Y+1	; 0x01
    18da:	fa 81       	ldd	r31, Y+2	; 0x02
    18dc:	16 8e       	std	Z+30, r1	; 0x1e
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18e2:	ce 01       	movw	r24, r28
    18e4:	05 96       	adiw	r24, 0x05	; 5
    18e6:	9e 01       	movw	r18, r28
    18e8:	24 5f       	subi	r18, 0xF4	; 244
    18ea:	3f 4f       	sbci	r19, 0xFF	; 255
    18ec:	b9 01       	movw	r22, r18
    18ee:	0e 94 5f 1b 	call	0x36be	; 0x36be <xTaskCheckForTimeOut>
    18f2:	88 23       	and	r24, r24
    18f4:	09 f5       	brne	.+66     	; 0x1938 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18f6:	89 81       	ldd	r24, Y+1	; 0x01
    18f8:	9a 81       	ldd	r25, Y+2	; 0x02
    18fa:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <prvIsQueueFull>
    18fe:	88 23       	and	r24, r24
    1900:	a1 f0       	breq	.+40     	; 0x192a <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1902:	89 81       	ldd	r24, Y+1	; 0x01
    1904:	9a 81       	ldd	r25, Y+2	; 0x02
    1906:	08 96       	adiw	r24, 0x08	; 8
    1908:	2c 85       	ldd	r18, Y+12	; 0x0c
    190a:	3d 85       	ldd	r19, Y+13	; 0x0d
    190c:	b9 01       	movw	r22, r18
    190e:	0e 94 0e 1a 	call	0x341c	; 0x341c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1912:	89 81       	ldd	r24, Y+1	; 0x01
    1914:	9a 81       	ldd	r25, Y+2	; 0x02
    1916:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    191a:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    191e:	88 23       	and	r24, r24
    1920:	09 f0       	breq	.+2      	; 0x1924 <xQueueGenericSend+0x122>
    1922:	85 cf       	rjmp	.-246    	; 0x182e <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1924:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    1928:	82 cf       	rjmp	.-252    	; 0x182e <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	9a 81       	ldd	r25, Y+2	; 0x02
    192e:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1932:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1936:	7b cf       	rjmp	.-266    	; 0x182e <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	9a 81       	ldd	r25, Y+2	; 0x02
    193c:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1940:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1944:	1f 86       	std	Y+15, r1	; 0x0f
    1946:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1948:	2f 96       	adiw	r28, 0x0f	; 15
    194a:	0f b6       	in	r0, 0x3f	; 63
    194c:	f8 94       	cli
    194e:	de bf       	out	0x3e, r29	; 62
    1950:	0f be       	out	0x3f, r0	; 63
    1952:	cd bf       	out	0x3d, r28	; 61
    1954:	cf 91       	pop	r28
    1956:	df 91       	pop	r29
    1958:	08 95       	ret

0000195a <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    195a:	df 93       	push	r29
    195c:	cf 93       	push	r28
    195e:	cd b7       	in	r28, 0x3d	; 61
    1960:	de b7       	in	r29, 0x3e	; 62
    1962:	2d 97       	sbiw	r28, 0x0d	; 13
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	f8 94       	cli
    1968:	de bf       	out	0x3e, r29	; 62
    196a:	0f be       	out	0x3f, r0	; 63
    196c:	cd bf       	out	0x3d, r28	; 61
    196e:	98 87       	std	Y+8, r25	; 0x08
    1970:	8f 83       	std	Y+7, r24	; 0x07
    1972:	7a 87       	std	Y+10, r23	; 0x0a
    1974:	69 87       	std	Y+9, r22	; 0x09
    1976:	5c 87       	std	Y+12, r21	; 0x0c
    1978:	4b 87       	std	Y+11, r20	; 0x0b
    197a:	2d 87       	std	Y+13, r18	; 0x0d
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    197c:	8f 81       	ldd	r24, Y+7	; 0x07
    197e:	98 85       	ldd	r25, Y+8	; 0x08
    1980:	9c 83       	std	Y+4, r25	; 0x04
    1982:	8b 83       	std	Y+3, r24	; 0x03
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1984:	1d 82       	std	Y+5, r1	; 0x05
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1986:	eb 81       	ldd	r30, Y+3	; 0x03
    1988:	fc 81       	ldd	r31, Y+4	; 0x04
    198a:	92 8d       	ldd	r25, Z+26	; 0x1a
    198c:	eb 81       	ldd	r30, Y+3	; 0x03
    198e:	fc 81       	ldd	r31, Y+4	; 0x04
    1990:	83 8d       	ldd	r24, Z+27	; 0x1b
    1992:	98 17       	cp	r25, r24
    1994:	18 f0       	brcs	.+6      	; 0x199c <xQueueGenericSendFromISR+0x42>
    1996:	8d 85       	ldd	r24, Y+13	; 0x0d
    1998:	82 30       	cpi	r24, 0x02	; 2
    199a:	81 f5       	brne	.+96     	; 0x19fc <xQueueGenericSendFromISR+0xa2>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    199c:	eb 81       	ldd	r30, Y+3	; 0x03
    199e:	fc 81       	ldd	r31, Y+4	; 0x04
    19a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    19a2:	8a 83       	std	Y+2, r24	; 0x02
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    19a4:	eb 81       	ldd	r30, Y+3	; 0x03
    19a6:	fc 81       	ldd	r31, Y+4	; 0x04
    19a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    19aa:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19ac:	8b 81       	ldd	r24, Y+3	; 0x03
    19ae:	9c 81       	ldd	r25, Y+4	; 0x04
    19b0:	29 85       	ldd	r18, Y+9	; 0x09
    19b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    19b4:	b9 01       	movw	r22, r18
    19b6:	4d 85       	ldd	r20, Y+13	; 0x0d
    19b8:	0e 94 57 10 	call	0x20ae	; 0x20ae <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    19bc:	8a 81       	ldd	r24, Y+2	; 0x02
    19be:	8f 3f       	cpi	r24, 0xFF	; 255
    19c0:	a9 f4       	brne	.+42     	; 0x19ec <xQueueGenericSendFromISR+0x92>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19c2:	eb 81       	ldd	r30, Y+3	; 0x03
    19c4:	fc 81       	ldd	r31, Y+4	; 0x04
    19c6:	81 89       	ldd	r24, Z+17	; 0x11
    19c8:	88 23       	and	r24, r24
    19ca:	a9 f0       	breq	.+42     	; 0x19f6 <xQueueGenericSendFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19cc:	8b 81       	ldd	r24, Y+3	; 0x03
    19ce:	9c 81       	ldd	r25, Y+4	; 0x04
    19d0:	41 96       	adiw	r24, 0x11	; 17
    19d2:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    19d6:	88 23       	and	r24, r24
    19d8:	71 f0       	breq	.+28     	; 0x19f6 <xQueueGenericSendFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    19da:	8b 85       	ldd	r24, Y+11	; 0x0b
    19dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    19de:	00 97       	sbiw	r24, 0x00	; 0
    19e0:	51 f0       	breq	.+20     	; 0x19f6 <xQueueGenericSendFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    19e2:	eb 85       	ldd	r30, Y+11	; 0x0b
    19e4:	fc 85       	ldd	r31, Y+12	; 0x0c
    19e6:	81 e0       	ldi	r24, 0x01	; 1
    19e8:	80 83       	st	Z, r24
    19ea:	05 c0       	rjmp	.+10     	; 0x19f6 <xQueueGenericSendFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    19ec:	8a 81       	ldd	r24, Y+2	; 0x02
    19ee:	8f 5f       	subi	r24, 0xFF	; 255
    19f0:	eb 81       	ldd	r30, Y+3	; 0x03
    19f2:	fc 81       	ldd	r31, Y+4	; 0x04
    19f4:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	8e 83       	std	Y+6, r24	; 0x06
    19fa:	01 c0       	rjmp	.+2      	; 0x19fe <xQueueGenericSendFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    19fc:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    19fe:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1a00:	2d 96       	adiw	r28, 0x0d	; 13
    1a02:	0f b6       	in	r0, 0x3f	; 63
    1a04:	f8 94       	cli
    1a06:	de bf       	out	0x3e, r29	; 62
    1a08:	0f be       	out	0x3f, r0	; 63
    1a0a:	cd bf       	out	0x3d, r28	; 61
    1a0c:	cf 91       	pop	r28
    1a0e:	df 91       	pop	r29
    1a10:	08 95       	ret

00001a12 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a12:	df 93       	push	r29
    1a14:	cf 93       	push	r28
    1a16:	cd b7       	in	r28, 0x3d	; 61
    1a18:	de b7       	in	r29, 0x3e	; 62
    1a1a:	2a 97       	sbiw	r28, 0x0a	; 10
    1a1c:	0f b6       	in	r0, 0x3f	; 63
    1a1e:	f8 94       	cli
    1a20:	de bf       	out	0x3e, r29	; 62
    1a22:	0f be       	out	0x3f, r0	; 63
    1a24:	cd bf       	out	0x3d, r28	; 61
    1a26:	98 87       	std	Y+8, r25	; 0x08
    1a28:	8f 83       	std	Y+7, r24	; 0x07
    1a2a:	7a 87       	std	Y+10, r23	; 0x0a
    1a2c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1a2e:	8f 81       	ldd	r24, Y+7	; 0x07
    1a30:	98 85       	ldd	r25, Y+8	; 0x08
    1a32:	9c 83       	std	Y+4, r25	; 0x04
    1a34:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a36:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a38:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a3e:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1a40:	eb 81       	ldd	r30, Y+3	; 0x03
    1a42:	fc 81       	ldd	r31, Y+4	; 0x04
    1a44:	93 8d       	ldd	r25, Z+27	; 0x1b
    1a46:	8a 81       	ldd	r24, Y+2	; 0x02
    1a48:	89 17       	cp	r24, r25
    1a4a:	48 f5       	brcc	.+82     	; 0x1a9e <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1a4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a50:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a52:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1a54:	8a 81       	ldd	r24, Y+2	; 0x02
    1a56:	8f 5f       	subi	r24, 0xFF	; 255
    1a58:	eb 81       	ldd	r30, Y+3	; 0x03
    1a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a5c:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1a5e:	89 81       	ldd	r24, Y+1	; 0x01
    1a60:	8f 3f       	cpi	r24, 0xFF	; 255
    1a62:	a9 f4       	brne	.+42     	; 0x1a8e <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a64:	eb 81       	ldd	r30, Y+3	; 0x03
    1a66:	fc 81       	ldd	r31, Y+4	; 0x04
    1a68:	81 89       	ldd	r24, Z+17	; 0x11
    1a6a:	88 23       	and	r24, r24
    1a6c:	a9 f0       	breq	.+42     	; 0x1a98 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a70:	9c 81       	ldd	r25, Y+4	; 0x04
    1a72:	41 96       	adiw	r24, 0x11	; 17
    1a74:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1a78:	88 23       	and	r24, r24
    1a7a:	71 f0       	breq	.+28     	; 0x1a98 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a7c:	89 85       	ldd	r24, Y+9	; 0x09
    1a7e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a80:	00 97       	sbiw	r24, 0x00	; 0
    1a82:	51 f0       	breq	.+20     	; 0x1a98 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a84:	e9 85       	ldd	r30, Y+9	; 0x09
    1a86:	fa 85       	ldd	r31, Y+10	; 0x0a
    1a88:	81 e0       	ldi	r24, 0x01	; 1
    1a8a:	80 83       	st	Z, r24
    1a8c:	05 c0       	rjmp	.+10     	; 0x1a98 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1a8e:	89 81       	ldd	r24, Y+1	; 0x01
    1a90:	8f 5f       	subi	r24, 0xFF	; 255
    1a92:	eb 81       	ldd	r30, Y+3	; 0x03
    1a94:	fc 81       	ldd	r31, Y+4	; 0x04
    1a96:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	8e 83       	std	Y+6, r24	; 0x06
    1a9c:	01 c0       	rjmp	.+2      	; 0x1aa0 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a9e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1aa0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1aa2:	2a 96       	adiw	r28, 0x0a	; 10
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	f8 94       	cli
    1aa8:	de bf       	out	0x3e, r29	; 62
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	cd bf       	out	0x3d, r28	; 61
    1aae:	cf 91       	pop	r28
    1ab0:	df 91       	pop	r29
    1ab2:	08 95       	ret

00001ab4 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1ab4:	df 93       	push	r29
    1ab6:	cf 93       	push	r28
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
    1abc:	2e 97       	sbiw	r28, 0x0e	; 14
    1abe:	0f b6       	in	r0, 0x3f	; 63
    1ac0:	f8 94       	cli
    1ac2:	de bf       	out	0x3e, r29	; 62
    1ac4:	0f be       	out	0x3f, r0	; 63
    1ac6:	cd bf       	out	0x3d, r28	; 61
    1ac8:	99 87       	std	Y+9, r25	; 0x09
    1aca:	88 87       	std	Y+8, r24	; 0x08
    1acc:	7b 87       	std	Y+11, r23	; 0x0b
    1ace:	6a 87       	std	Y+10, r22	; 0x0a
    1ad0:	5d 87       	std	Y+13, r21	; 0x0d
    1ad2:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1ad4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1ad6:	88 85       	ldd	r24, Y+8	; 0x08
    1ad8:	99 85       	ldd	r25, Y+9	; 0x09
    1ada:	9b 83       	std	Y+3, r25	; 0x03
    1adc:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1ade:	0f b6       	in	r0, 0x3f	; 63
    1ae0:	f8 94       	cli
    1ae2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ae4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ae6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ae8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aea:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aec:	89 81       	ldd	r24, Y+1	; 0x01
    1aee:	88 23       	and	r24, r24
    1af0:	f9 f0       	breq	.+62     	; 0x1b30 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1af2:	8a 81       	ldd	r24, Y+2	; 0x02
    1af4:	9b 81       	ldd	r25, Y+3	; 0x03
    1af6:	2a 85       	ldd	r18, Y+10	; 0x0a
    1af8:	3b 85       	ldd	r19, Y+11	; 0x0b
    1afa:	b9 01       	movw	r22, r18
    1afc:	0e 94 fd 10 	call	0x21fa	; 0x21fa <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
    1b02:	81 50       	subi	r24, 0x01	; 1
    1b04:	ea 81       	ldd	r30, Y+2	; 0x02
    1b06:	fb 81       	ldd	r31, Y+3	; 0x03
    1b08:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b0a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b0c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b0e:	80 85       	ldd	r24, Z+8	; 0x08
    1b10:	88 23       	and	r24, r24
    1b12:	49 f0       	breq	.+18     	; 0x1b26 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b14:	8a 81       	ldd	r24, Y+2	; 0x02
    1b16:	9b 81       	ldd	r25, Y+3	; 0x03
    1b18:	08 96       	adiw	r24, 0x08	; 8
    1b1a:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1b1e:	88 23       	and	r24, r24
    1b20:	11 f0       	breq	.+4      	; 0x1b26 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1b22:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	8e 87       	std	Y+14, r24	; 0x0e
    1b2e:	63 c0       	rjmp	.+198    	; 0x1bf6 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b30:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b32:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b34:	00 97       	sbiw	r24, 0x00	; 0
    1b36:	21 f4       	brne	.+8      	; 0x1b40 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b38:	0f 90       	pop	r0
    1b3a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b3c:	1e 86       	std	Y+14, r1	; 0x0e
    1b3e:	5b c0       	rjmp	.+182    	; 0x1bf6 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b40:	8c 81       	ldd	r24, Y+4	; 0x04
    1b42:	88 23       	and	r24, r24
    1b44:	31 f4       	brne	.+12     	; 0x1b52 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1b46:	ce 01       	movw	r24, r28
    1b48:	05 96       	adiw	r24, 0x05	; 5
    1b4a:	0e 94 46 1b 	call	0x368c	; 0x368c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
    1b50:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b52:	0f 90       	pop	r0
    1b54:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b56:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b5a:	0f b6       	in	r0, 0x3f	; 63
    1b5c:	f8 94       	cli
    1b5e:	0f 92       	push	r0
    1b60:	ea 81       	ldd	r30, Y+2	; 0x02
    1b62:	fb 81       	ldd	r31, Y+3	; 0x03
    1b64:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b66:	8f 3f       	cpi	r24, 0xFF	; 255
    1b68:	19 f4       	brne	.+6      	; 0x1b70 <xQueueReceive+0xbc>
    1b6a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b6c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b6e:	15 8e       	std	Z+29, r1	; 0x1d
    1b70:	ea 81       	ldd	r30, Y+2	; 0x02
    1b72:	fb 81       	ldd	r31, Y+3	; 0x03
    1b74:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b76:	8f 3f       	cpi	r24, 0xFF	; 255
    1b78:	19 f4       	brne	.+6      	; 0x1b80 <xQueueReceive+0xcc>
    1b7a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b7c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b7e:	16 8e       	std	Z+30, r1	; 0x1e
    1b80:	0f 90       	pop	r0
    1b82:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b84:	ce 01       	movw	r24, r28
    1b86:	05 96       	adiw	r24, 0x05	; 5
    1b88:	9e 01       	movw	r18, r28
    1b8a:	24 5f       	subi	r18, 0xF4	; 244
    1b8c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b8e:	b9 01       	movw	r22, r18
    1b90:	0e 94 5f 1b 	call	0x36be	; 0x36be <xTaskCheckForTimeOut>
    1b94:	88 23       	and	r24, r24
    1b96:	09 f5       	brne	.+66     	; 0x1bda <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b98:	8a 81       	ldd	r24, Y+2	; 0x02
    1b9a:	9b 81       	ldd	r25, Y+3	; 0x03
    1b9c:	0e 94 97 11 	call	0x232e	; 0x232e <prvIsQueueEmpty>
    1ba0:	88 23       	and	r24, r24
    1ba2:	a1 f0       	breq	.+40     	; 0x1bcc <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ba8:	41 96       	adiw	r24, 0x11	; 17
    1baa:	2c 85       	ldd	r18, Y+12	; 0x0c
    1bac:	3d 85       	ldd	r19, Y+13	; 0x0d
    1bae:	b9 01       	movw	r22, r18
    1bb0:	0e 94 0e 1a 	call	0x341c	; 0x341c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb6:	9b 81       	ldd	r25, Y+3	; 0x03
    1bb8:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1bbc:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1bc0:	88 23       	and	r24, r24
    1bc2:	09 f0       	breq	.+2      	; 0x1bc6 <xQueueReceive+0x112>
    1bc4:	8c cf       	rjmp	.-232    	; 0x1ade <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1bc6:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    1bca:	89 cf       	rjmp	.-238    	; 0x1ade <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bce:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd0:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bd4:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1bd8:	82 cf       	rjmp	.-252    	; 0x1ade <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1bda:	8a 81       	ldd	r24, Y+2	; 0x02
    1bdc:	9b 81       	ldd	r25, Y+3	; 0x03
    1bde:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1be2:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1be6:	8a 81       	ldd	r24, Y+2	; 0x02
    1be8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bea:	0e 94 97 11 	call	0x232e	; 0x232e <prvIsQueueEmpty>
    1bee:	88 23       	and	r24, r24
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <xQueueReceive+0x140>
    1bf2:	75 cf       	rjmp	.-278    	; 0x1ade <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1bf4:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1bf6:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1bf8:	2e 96       	adiw	r28, 0x0e	; 14
    1bfa:	0f b6       	in	r0, 0x3f	; 63
    1bfc:	f8 94       	cli
    1bfe:	de bf       	out	0x3e, r29	; 62
    1c00:	0f be       	out	0x3f, r0	; 63
    1c02:	cd bf       	out	0x3d, r28	; 61
    1c04:	cf 91       	pop	r28
    1c06:	df 91       	pop	r29
    1c08:	08 95       	ret

00001c0a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1c0a:	df 93       	push	r29
    1c0c:	cf 93       	push	r28
    1c0e:	cd b7       	in	r28, 0x3d	; 61
    1c10:	de b7       	in	r29, 0x3e	; 62
    1c12:	2c 97       	sbiw	r28, 0x0c	; 12
    1c14:	0f b6       	in	r0, 0x3f	; 63
    1c16:	f8 94       	cli
    1c18:	de bf       	out	0x3e, r29	; 62
    1c1a:	0f be       	out	0x3f, r0	; 63
    1c1c:	cd bf       	out	0x3d, r28	; 61
    1c1e:	99 87       	std	Y+9, r25	; 0x09
    1c20:	88 87       	std	Y+8, r24	; 0x08
    1c22:	7b 87       	std	Y+11, r23	; 0x0b
    1c24:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1c26:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1c28:	88 85       	ldd	r24, Y+8	; 0x08
    1c2a:	99 85       	ldd	r25, Y+9	; 0x09
    1c2c:	9b 83       	std	Y+3, r25	; 0x03
    1c2e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c30:	0f b6       	in	r0, 0x3f	; 63
    1c32:	f8 94       	cli
    1c34:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1c36:	ea 81       	ldd	r30, Y+2	; 0x02
    1c38:	fb 81       	ldd	r31, Y+3	; 0x03
    1c3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c3c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1c3e:	89 81       	ldd	r24, Y+1	; 0x01
    1c40:	88 23       	and	r24, r24
    1c42:	c1 f0       	breq	.+48     	; 0x1c74 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	81 50       	subi	r24, 0x01	; 1
    1c48:	ea 81       	ldd	r30, Y+2	; 0x02
    1c4a:	fb 81       	ldd	r31, Y+3	; 0x03
    1c4c:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1c50:	fb 81       	ldd	r31, Y+3	; 0x03
    1c52:	80 85       	ldd	r24, Z+8	; 0x08
    1c54:	88 23       	and	r24, r24
    1c56:	49 f0       	breq	.+18     	; 0x1c6a <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c58:	8a 81       	ldd	r24, Y+2	; 0x02
    1c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c5c:	08 96       	adiw	r24, 0x08	; 8
    1c5e:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1c62:	88 23       	and	r24, r24
    1c64:	11 f0       	breq	.+4      	; 0x1c6a <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1c66:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1c6a:	0f 90       	pop	r0
    1c6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	8c 87       	std	Y+12, r24	; 0x0c
    1c72:	63 c0       	rjmp	.+198    	; 0x1d3a <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c74:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c76:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c78:	00 97       	sbiw	r24, 0x00	; 0
    1c7a:	21 f4       	brne	.+8      	; 0x1c84 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1c7c:	0f 90       	pop	r0
    1c7e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1c80:	1c 86       	std	Y+12, r1	; 0x0c
    1c82:	5b c0       	rjmp	.+182    	; 0x1d3a <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c84:	8c 81       	ldd	r24, Y+4	; 0x04
    1c86:	88 23       	and	r24, r24
    1c88:	31 f4       	brne	.+12     	; 0x1c96 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1c8a:	ce 01       	movw	r24, r28
    1c8c:	05 96       	adiw	r24, 0x05	; 5
    1c8e:	0e 94 46 1b 	call	0x368c	; 0x368c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c9a:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c9e:	0f b6       	in	r0, 0x3f	; 63
    1ca0:	f8 94       	cli
    1ca2:	0f 92       	push	r0
    1ca4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ca6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ca8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1caa:	8f 3f       	cpi	r24, 0xFF	; 255
    1cac:	19 f4       	brne	.+6      	; 0x1cb4 <xQueueSemaphoreTake+0xaa>
    1cae:	ea 81       	ldd	r30, Y+2	; 0x02
    1cb0:	fb 81       	ldd	r31, Y+3	; 0x03
    1cb2:	15 8e       	std	Z+29, r1	; 0x1d
    1cb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1cb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1cb8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cba:	8f 3f       	cpi	r24, 0xFF	; 255
    1cbc:	19 f4       	brne	.+6      	; 0x1cc4 <xQueueSemaphoreTake+0xba>
    1cbe:	ea 81       	ldd	r30, Y+2	; 0x02
    1cc0:	fb 81       	ldd	r31, Y+3	; 0x03
    1cc2:	16 8e       	std	Z+30, r1	; 0x1e
    1cc4:	0f 90       	pop	r0
    1cc6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cc8:	ce 01       	movw	r24, r28
    1cca:	05 96       	adiw	r24, 0x05	; 5
    1ccc:	9e 01       	movw	r18, r28
    1cce:	26 5f       	subi	r18, 0xF6	; 246
    1cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    1cd2:	b9 01       	movw	r22, r18
    1cd4:	0e 94 5f 1b 	call	0x36be	; 0x36be <xTaskCheckForTimeOut>
    1cd8:	88 23       	and	r24, r24
    1cda:	09 f5       	brne	.+66     	; 0x1d1e <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cde:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce0:	0e 94 97 11 	call	0x232e	; 0x232e <prvIsQueueEmpty>
    1ce4:	88 23       	and	r24, r24
    1ce6:	a1 f0       	breq	.+40     	; 0x1d10 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ce8:	8a 81       	ldd	r24, Y+2	; 0x02
    1cea:	9b 81       	ldd	r25, Y+3	; 0x03
    1cec:	41 96       	adiw	r24, 0x11	; 17
    1cee:	2a 85       	ldd	r18, Y+10	; 0x0a
    1cf0:	3b 85       	ldd	r19, Y+11	; 0x0b
    1cf2:	b9 01       	movw	r22, r18
    1cf4:	0e 94 0e 1a 	call	0x341c	; 0x341c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1cf8:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfa:	9b 81       	ldd	r25, Y+3	; 0x03
    1cfc:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d00:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1d04:	88 23       	and	r24, r24
    1d06:	09 f0       	breq	.+2      	; 0x1d0a <xQueueSemaphoreTake+0x100>
    1d08:	93 cf       	rjmp	.-218    	; 0x1c30 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1d0a:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    1d0e:	90 cf       	rjmp	.-224    	; 0x1c30 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1d10:	8a 81       	ldd	r24, Y+2	; 0x02
    1d12:	9b 81       	ldd	r25, Y+3	; 0x03
    1d14:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d18:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1d1c:	89 cf       	rjmp	.-238    	; 0x1c30 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d20:	9b 81       	ldd	r25, Y+3	; 0x03
    1d22:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d26:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d2c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d2e:	0e 94 97 11 	call	0x232e	; 0x232e <prvIsQueueEmpty>
    1d32:	88 23       	and	r24, r24
    1d34:	09 f4       	brne	.+2      	; 0x1d38 <xQueueSemaphoreTake+0x12e>
    1d36:	7c cf       	rjmp	.-264    	; 0x1c30 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1d38:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1d3a:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1d3c:	2c 96       	adiw	r28, 0x0c	; 12
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	de bf       	out	0x3e, r29	; 62
    1d44:	0f be       	out	0x3f, r0	; 63
    1d46:	cd bf       	out	0x3d, r28	; 61
    1d48:	cf 91       	pop	r28
    1d4a:	df 91       	pop	r29
    1d4c:	08 95       	ret

00001d4e <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1d4e:	df 93       	push	r29
    1d50:	cf 93       	push	r28
    1d52:	cd b7       	in	r28, 0x3d	; 61
    1d54:	de b7       	in	r29, 0x3e	; 62
    1d56:	60 97       	sbiw	r28, 0x10	; 16
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	de bf       	out	0x3e, r29	; 62
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	cd bf       	out	0x3d, r28	; 61
    1d62:	9b 87       	std	Y+11, r25	; 0x0b
    1d64:	8a 87       	std	Y+10, r24	; 0x0a
    1d66:	7d 87       	std	Y+13, r23	; 0x0d
    1d68:	6c 87       	std	Y+12, r22	; 0x0c
    1d6a:	5f 87       	std	Y+15, r21	; 0x0f
    1d6c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    1d6e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1d70:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d72:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d74:	9b 83       	std	Y+3, r25	; 0x03
    1d76:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1d78:	0f b6       	in	r0, 0x3f	; 63
    1d7a:	f8 94       	cli
    1d7c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1d7e:	ea 81       	ldd	r30, Y+2	; 0x02
    1d80:	fb 81       	ldd	r31, Y+3	; 0x03
    1d82:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d84:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d86:	89 81       	ldd	r24, Y+1	; 0x01
    1d88:	88 23       	and	r24, r24
    1d8a:	31 f1       	breq	.+76     	; 0x1dd8 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1d8c:	ea 81       	ldd	r30, Y+2	; 0x02
    1d8e:	fb 81       	ldd	r31, Y+3	; 0x03
    1d90:	86 81       	ldd	r24, Z+6	; 0x06
    1d92:	97 81       	ldd	r25, Z+7	; 0x07
    1d94:	9d 83       	std	Y+5, r25	; 0x05
    1d96:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d98:	8a 81       	ldd	r24, Y+2	; 0x02
    1d9a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d9c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d9e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1da0:	b9 01       	movw	r22, r18
    1da2:	0e 94 fd 10 	call	0x21fa	; 0x21fa <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1da6:	ea 81       	ldd	r30, Y+2	; 0x02
    1da8:	fb 81       	ldd	r31, Y+3	; 0x03
    1daa:	8c 81       	ldd	r24, Y+4	; 0x04
    1dac:	9d 81       	ldd	r25, Y+5	; 0x05
    1dae:	97 83       	std	Z+7, r25	; 0x07
    1db0:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1db2:	ea 81       	ldd	r30, Y+2	; 0x02
    1db4:	fb 81       	ldd	r31, Y+3	; 0x03
    1db6:	81 89       	ldd	r24, Z+17	; 0x11
    1db8:	88 23       	and	r24, r24
    1dba:	49 f0       	breq	.+18     	; 0x1dce <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dbe:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc0:	41 96       	adiw	r24, 0x11	; 17
    1dc2:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1dc6:	88 23       	and	r24, r24
    1dc8:	11 f0       	breq	.+4      	; 0x1dce <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1dca:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1dce:	0f 90       	pop	r0
    1dd0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1dd2:	81 e0       	ldi	r24, 0x01	; 1
    1dd4:	88 8b       	std	Y+16, r24	; 0x10
    1dd6:	63 c0       	rjmp	.+198    	; 0x1e9e <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1dd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dda:	9f 85       	ldd	r25, Y+15	; 0x0f
    1ddc:	00 97       	sbiw	r24, 0x00	; 0
    1dde:	21 f4       	brne	.+8      	; 0x1de8 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1de0:	0f 90       	pop	r0
    1de2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1de4:	18 8a       	std	Y+16, r1	; 0x10
    1de6:	5b c0       	rjmp	.+182    	; 0x1e9e <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1de8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dea:	88 23       	and	r24, r24
    1dec:	31 f4       	brne	.+12     	; 0x1dfa <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1dee:	ce 01       	movw	r24, r28
    1df0:	07 96       	adiw	r24, 0x07	; 7
    1df2:	0e 94 46 1b 	call	0x368c	; 0x368c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1df6:	81 e0       	ldi	r24, 0x01	; 1
    1df8:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1dfa:	0f 90       	pop	r0
    1dfc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1dfe:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	0f 92       	push	r0
    1e08:	ea 81       	ldd	r30, Y+2	; 0x02
    1e0a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e10:	19 f4       	brne	.+6      	; 0x1e18 <xQueuePeek+0xca>
    1e12:	ea 81       	ldd	r30, Y+2	; 0x02
    1e14:	fb 81       	ldd	r31, Y+3	; 0x03
    1e16:	15 8e       	std	Z+29, r1	; 0x1d
    1e18:	ea 81       	ldd	r30, Y+2	; 0x02
    1e1a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e20:	19 f4       	brne	.+6      	; 0x1e28 <xQueuePeek+0xda>
    1e22:	ea 81       	ldd	r30, Y+2	; 0x02
    1e24:	fb 81       	ldd	r31, Y+3	; 0x03
    1e26:	16 8e       	std	Z+30, r1	; 0x1e
    1e28:	0f 90       	pop	r0
    1e2a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e2c:	ce 01       	movw	r24, r28
    1e2e:	07 96       	adiw	r24, 0x07	; 7
    1e30:	9e 01       	movw	r18, r28
    1e32:	22 5f       	subi	r18, 0xF2	; 242
    1e34:	3f 4f       	sbci	r19, 0xFF	; 255
    1e36:	b9 01       	movw	r22, r18
    1e38:	0e 94 5f 1b 	call	0x36be	; 0x36be <xTaskCheckForTimeOut>
    1e3c:	88 23       	and	r24, r24
    1e3e:	09 f5       	brne	.+66     	; 0x1e82 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e40:	8a 81       	ldd	r24, Y+2	; 0x02
    1e42:	9b 81       	ldd	r25, Y+3	; 0x03
    1e44:	0e 94 97 11 	call	0x232e	; 0x232e <prvIsQueueEmpty>
    1e48:	88 23       	and	r24, r24
    1e4a:	a1 f0       	breq	.+40     	; 0x1e74 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e4e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e50:	41 96       	adiw	r24, 0x11	; 17
    1e52:	2e 85       	ldd	r18, Y+14	; 0x0e
    1e54:	3f 85       	ldd	r19, Y+15	; 0x0f
    1e56:	b9 01       	movw	r22, r18
    1e58:	0e 94 0e 1a 	call	0x341c	; 0x341c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e60:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e64:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1e68:	88 23       	and	r24, r24
    1e6a:	09 f0       	breq	.+2      	; 0x1e6e <xQueuePeek+0x120>
    1e6c:	85 cf       	rjmp	.-246    	; 0x1d78 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    1e6e:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    1e72:	82 cf       	rjmp	.-252    	; 0x1d78 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1e74:	8a 81       	ldd	r24, Y+2	; 0x02
    1e76:	9b 81       	ldd	r25, Y+3	; 0x03
    1e78:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e7c:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    1e80:	7b cf       	rjmp	.-266    	; 0x1d78 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1e82:	8a 81       	ldd	r24, Y+2	; 0x02
    1e84:	9b 81       	ldd	r25, Y+3	; 0x03
    1e86:	0e 94 44 11 	call	0x2288	; 0x2288 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e8a:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e90:	9b 81       	ldd	r25, Y+3	; 0x03
    1e92:	0e 94 97 11 	call	0x232e	; 0x232e <prvIsQueueEmpty>
    1e96:	88 23       	and	r24, r24
    1e98:	09 f4       	brne	.+2      	; 0x1e9c <xQueuePeek+0x14e>
    1e9a:	6e cf       	rjmp	.-292    	; 0x1d78 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1e9c:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1e9e:	88 89       	ldd	r24, Y+16	; 0x10
}
    1ea0:	60 96       	adiw	r28, 0x10	; 16
    1ea2:	0f b6       	in	r0, 0x3f	; 63
    1ea4:	f8 94       	cli
    1ea6:	de bf       	out	0x3e, r29	; 62
    1ea8:	0f be       	out	0x3f, r0	; 63
    1eaa:	cd bf       	out	0x3d, r28	; 61
    1eac:	cf 91       	pop	r28
    1eae:	df 91       	pop	r29
    1eb0:	08 95       	ret

00001eb2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1eb2:	df 93       	push	r29
    1eb4:	cf 93       	push	r28
    1eb6:	cd b7       	in	r28, 0x3d	; 61
    1eb8:	de b7       	in	r29, 0x3e	; 62
    1eba:	2c 97       	sbiw	r28, 0x0c	; 12
    1ebc:	0f b6       	in	r0, 0x3f	; 63
    1ebe:	f8 94       	cli
    1ec0:	de bf       	out	0x3e, r29	; 62
    1ec2:	0f be       	out	0x3f, r0	; 63
    1ec4:	cd bf       	out	0x3d, r28	; 61
    1ec6:	98 87       	std	Y+8, r25	; 0x08
    1ec8:	8f 83       	std	Y+7, r24	; 0x07
    1eca:	7a 87       	std	Y+10, r23	; 0x0a
    1ecc:	69 87       	std	Y+9, r22	; 0x09
    1ece:	5c 87       	std	Y+12, r21	; 0x0c
    1ed0:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1ed2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed4:	98 85       	ldd	r25, Y+8	; 0x08
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1eda:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1edc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ede:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ee2:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee6:	88 23       	and	r24, r24
    1ee8:	81 f1       	breq	.+96     	; 0x1f4a <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1eea:	eb 81       	ldd	r30, Y+3	; 0x03
    1eec:	fc 81       	ldd	r31, Y+4	; 0x04
    1eee:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ef0:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef6:	29 85       	ldd	r18, Y+9	; 0x09
    1ef8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1efa:	b9 01       	movw	r22, r18
    1efc:	0e 94 fd 10 	call	0x21fa	; 0x21fa <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1f00:	8a 81       	ldd	r24, Y+2	; 0x02
    1f02:	81 50       	subi	r24, 0x01	; 1
    1f04:	eb 81       	ldd	r30, Y+3	; 0x03
    1f06:	fc 81       	ldd	r31, Y+4	; 0x04
    1f08:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1f0a:	89 81       	ldd	r24, Y+1	; 0x01
    1f0c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f0e:	a9 f4       	brne	.+42     	; 0x1f3a <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f10:	eb 81       	ldd	r30, Y+3	; 0x03
    1f12:	fc 81       	ldd	r31, Y+4	; 0x04
    1f14:	80 85       	ldd	r24, Z+8	; 0x08
    1f16:	88 23       	and	r24, r24
    1f18:	a9 f0       	breq	.+42     	; 0x1f44 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1e:	08 96       	adiw	r24, 0x08	; 8
    1f20:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    1f24:	88 23       	and	r24, r24
    1f26:	71 f0       	breq	.+28     	; 0x1f44 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1f28:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f2a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f2c:	00 97       	sbiw	r24, 0x00	; 0
    1f2e:	51 f0       	breq	.+20     	; 0x1f44 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f30:	eb 85       	ldd	r30, Y+11	; 0x0b
    1f32:	fc 85       	ldd	r31, Y+12	; 0x0c
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	80 83       	st	Z, r24
    1f38:	05 c0       	rjmp	.+10     	; 0x1f44 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1f3a:	89 81       	ldd	r24, Y+1	; 0x01
    1f3c:	8f 5f       	subi	r24, 0xFF	; 255
    1f3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f40:	fc 81       	ldd	r31, Y+4	; 0x04
    1f42:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1f44:	81 e0       	ldi	r24, 0x01	; 1
    1f46:	8e 83       	std	Y+6, r24	; 0x06
    1f48:	01 c0       	rjmp	.+2      	; 0x1f4c <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1f4a:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f4c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1f4e:	2c 96       	adiw	r28, 0x0c	; 12
    1f50:	0f b6       	in	r0, 0x3f	; 63
    1f52:	f8 94       	cli
    1f54:	de bf       	out	0x3e, r29	; 62
    1f56:	0f be       	out	0x3f, r0	; 63
    1f58:	cd bf       	out	0x3d, r28	; 61
    1f5a:	cf 91       	pop	r28
    1f5c:	df 91       	pop	r29
    1f5e:	08 95       	ret

00001f60 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1f60:	df 93       	push	r29
    1f62:	cf 93       	push	r28
    1f64:	cd b7       	in	r28, 0x3d	; 61
    1f66:	de b7       	in	r29, 0x3e	; 62
    1f68:	2a 97       	sbiw	r28, 0x0a	; 10
    1f6a:	0f b6       	in	r0, 0x3f	; 63
    1f6c:	f8 94       	cli
    1f6e:	de bf       	out	0x3e, r29	; 62
    1f70:	0f be       	out	0x3f, r0	; 63
    1f72:	cd bf       	out	0x3d, r28	; 61
    1f74:	98 87       	std	Y+8, r25	; 0x08
    1f76:	8f 83       	std	Y+7, r24	; 0x07
    1f78:	7a 87       	std	Y+10, r23	; 0x0a
    1f7a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1f7c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f7e:	98 85       	ldd	r25, Y+8	; 0x08
    1f80:	9a 83       	std	Y+2, r25	; 0x02
    1f82:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f84:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f86:	e9 81       	ldd	r30, Y+1	; 0x01
    1f88:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f8c:	88 23       	and	r24, r24
    1f8e:	b1 f0       	breq	.+44     	; 0x1fbc <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1f90:	e9 81       	ldd	r30, Y+1	; 0x01
    1f92:	fa 81       	ldd	r31, Y+2	; 0x02
    1f94:	86 81       	ldd	r24, Z+6	; 0x06
    1f96:	97 81       	ldd	r25, Z+7	; 0x07
    1f98:	9c 83       	std	Y+4, r25	; 0x04
    1f9a:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f9c:	89 81       	ldd	r24, Y+1	; 0x01
    1f9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa0:	29 85       	ldd	r18, Y+9	; 0x09
    1fa2:	3a 85       	ldd	r19, Y+10	; 0x0a
    1fa4:	b9 01       	movw	r22, r18
    1fa6:	0e 94 fd 10 	call	0x21fa	; 0x21fa <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1faa:	e9 81       	ldd	r30, Y+1	; 0x01
    1fac:	fa 81       	ldd	r31, Y+2	; 0x02
    1fae:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb2:	97 83       	std	Z+7, r25	; 0x07
    1fb4:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1fb6:	81 e0       	ldi	r24, 0x01	; 1
    1fb8:	8e 83       	std	Y+6, r24	; 0x06
    1fba:	01 c0       	rjmp	.+2      	; 0x1fbe <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1fbc:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1fbe:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1fc0:	2a 96       	adiw	r28, 0x0a	; 10
    1fc2:	0f b6       	in	r0, 0x3f	; 63
    1fc4:	f8 94       	cli
    1fc6:	de bf       	out	0x3e, r29	; 62
    1fc8:	0f be       	out	0x3f, r0	; 63
    1fca:	cd bf       	out	0x3d, r28	; 61
    1fcc:	cf 91       	pop	r28
    1fce:	df 91       	pop	r29
    1fd0:	08 95       	ret

00001fd2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1fd2:	df 93       	push	r29
    1fd4:	cf 93       	push	r28
    1fd6:	00 d0       	rcall	.+0      	; 0x1fd8 <uxQueueMessagesWaiting+0x6>
    1fd8:	0f 92       	push	r0
    1fda:	cd b7       	in	r28, 0x3d	; 61
    1fdc:	de b7       	in	r29, 0x3e	; 62
    1fde:	9b 83       	std	Y+3, r25	; 0x03
    1fe0:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1fe2:	0f b6       	in	r0, 0x3f	; 63
    1fe4:	f8 94       	cli
    1fe6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1fe8:	ea 81       	ldd	r30, Y+2	; 0x02
    1fea:	fb 81       	ldd	r31, Y+3	; 0x03
    1fec:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fee:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1ff0:	0f 90       	pop	r0
    1ff2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1ff4:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ff6:	0f 90       	pop	r0
    1ff8:	0f 90       	pop	r0
    1ffa:	0f 90       	pop	r0
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	08 95       	ret

00002002 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2002:	df 93       	push	r29
    2004:	cf 93       	push	r28
    2006:	00 d0       	rcall	.+0      	; 0x2008 <uxQueueSpacesAvailable+0x6>
    2008:	00 d0       	rcall	.+0      	; 0x200a <uxQueueSpacesAvailable+0x8>
    200a:	0f 92       	push	r0
    200c:	cd b7       	in	r28, 0x3d	; 61
    200e:	de b7       	in	r29, 0x3e	; 62
    2010:	9d 83       	std	Y+5, r25	; 0x05
    2012:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2014:	8c 81       	ldd	r24, Y+4	; 0x04
    2016:	9d 81       	ldd	r25, Y+5	; 0x05
    2018:	9a 83       	std	Y+2, r25	; 0x02
    201a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    201c:	0f b6       	in	r0, 0x3f	; 63
    201e:	f8 94       	cli
    2020:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2022:	e9 81       	ldd	r30, Y+1	; 0x01
    2024:	fa 81       	ldd	r31, Y+2	; 0x02
    2026:	93 8d       	ldd	r25, Z+27	; 0x1b
    2028:	e9 81       	ldd	r30, Y+1	; 0x01
    202a:	fa 81       	ldd	r31, Y+2	; 0x02
    202c:	82 8d       	ldd	r24, Z+26	; 0x1a
    202e:	29 2f       	mov	r18, r25
    2030:	28 1b       	sub	r18, r24
    2032:	82 2f       	mov	r24, r18
    2034:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2036:	0f 90       	pop	r0
    2038:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    203a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    203c:	0f 90       	pop	r0
    203e:	0f 90       	pop	r0
    2040:	0f 90       	pop	r0
    2042:	0f 90       	pop	r0
    2044:	0f 90       	pop	r0
    2046:	cf 91       	pop	r28
    2048:	df 91       	pop	r29
    204a:	08 95       	ret

0000204c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    204c:	df 93       	push	r29
    204e:	cf 93       	push	r28
    2050:	00 d0       	rcall	.+0      	; 0x2052 <uxQueueMessagesWaitingFromISR+0x6>
    2052:	00 d0       	rcall	.+0      	; 0x2054 <uxQueueMessagesWaitingFromISR+0x8>
    2054:	0f 92       	push	r0
    2056:	cd b7       	in	r28, 0x3d	; 61
    2058:	de b7       	in	r29, 0x3e	; 62
    205a:	9d 83       	std	Y+5, r25	; 0x05
    205c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    205e:	8c 81       	ldd	r24, Y+4	; 0x04
    2060:	9d 81       	ldd	r25, Y+5	; 0x05
    2062:	9a 83       	std	Y+2, r25	; 0x02
    2064:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2066:	e9 81       	ldd	r30, Y+1	; 0x01
    2068:	fa 81       	ldd	r31, Y+2	; 0x02
    206a:	82 8d       	ldd	r24, Z+26	; 0x1a
    206c:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    206e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2070:	0f 90       	pop	r0
    2072:	0f 90       	pop	r0
    2074:	0f 90       	pop	r0
    2076:	0f 90       	pop	r0
    2078:	0f 90       	pop	r0
    207a:	cf 91       	pop	r28
    207c:	df 91       	pop	r29
    207e:	08 95       	ret

00002080 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2080:	df 93       	push	r29
    2082:	cf 93       	push	r28
    2084:	00 d0       	rcall	.+0      	; 0x2086 <vQueueDelete+0x6>
    2086:	00 d0       	rcall	.+0      	; 0x2088 <vQueueDelete+0x8>
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	9c 83       	std	Y+4, r25	; 0x04
    208e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2090:	8b 81       	ldd	r24, Y+3	; 0x03
    2092:	9c 81       	ldd	r25, Y+4	; 0x04
    2094:	9a 83       	std	Y+2, r25	; 0x02
    2096:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2098:	89 81       	ldd	r24, Y+1	; 0x01
    209a:	9a 81       	ldd	r25, Y+2	; 0x02
    209c:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    20a0:	0f 90       	pop	r0
    20a2:	0f 90       	pop	r0
    20a4:	0f 90       	pop	r0
    20a6:	0f 90       	pop	r0
    20a8:	cf 91       	pop	r28
    20aa:	df 91       	pop	r29
    20ac:	08 95       	ret

000020ae <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    20ae:	df 93       	push	r29
    20b0:	cf 93       	push	r28
    20b2:	cd b7       	in	r28, 0x3d	; 61
    20b4:	de b7       	in	r29, 0x3e	; 62
    20b6:	27 97       	sbiw	r28, 0x07	; 7
    20b8:	0f b6       	in	r0, 0x3f	; 63
    20ba:	f8 94       	cli
    20bc:	de bf       	out	0x3e, r29	; 62
    20be:	0f be       	out	0x3f, r0	; 63
    20c0:	cd bf       	out	0x3d, r28	; 61
    20c2:	9c 83       	std	Y+4, r25	; 0x04
    20c4:	8b 83       	std	Y+3, r24	; 0x03
    20c6:	7e 83       	std	Y+6, r23	; 0x06
    20c8:	6d 83       	std	Y+5, r22	; 0x05
    20ca:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    20cc:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    20ce:	eb 81       	ldd	r30, Y+3	; 0x03
    20d0:	fc 81       	ldd	r31, Y+4	; 0x04
    20d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    20d4:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    20d6:	eb 81       	ldd	r30, Y+3	; 0x03
    20d8:	fc 81       	ldd	r31, Y+4	; 0x04
    20da:	84 8d       	ldd	r24, Z+28	; 0x1c
    20dc:	88 23       	and	r24, r24
    20de:	09 f4       	brne	.+2      	; 0x20e2 <prvCopyDataToQueue+0x34>
    20e0:	7d c0       	rjmp	.+250    	; 0x21dc <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    20e2:	8f 81       	ldd	r24, Y+7	; 0x07
    20e4:	88 23       	and	r24, r24
    20e6:	99 f5       	brne	.+102    	; 0x214e <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    20e8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ea:	fc 81       	ldd	r31, Y+4	; 0x04
    20ec:	62 81       	ldd	r22, Z+2	; 0x02
    20ee:	73 81       	ldd	r23, Z+3	; 0x03
    20f0:	eb 81       	ldd	r30, Y+3	; 0x03
    20f2:	fc 81       	ldd	r31, Y+4	; 0x04
    20f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    20f6:	48 2f       	mov	r20, r24
    20f8:	50 e0       	ldi	r21, 0x00	; 0
    20fa:	2d 81       	ldd	r18, Y+5	; 0x05
    20fc:	3e 81       	ldd	r19, Y+6	; 0x06
    20fe:	cb 01       	movw	r24, r22
    2100:	b9 01       	movw	r22, r18
    2102:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2106:	eb 81       	ldd	r30, Y+3	; 0x03
    2108:	fc 81       	ldd	r31, Y+4	; 0x04
    210a:	22 81       	ldd	r18, Z+2	; 0x02
    210c:	33 81       	ldd	r19, Z+3	; 0x03
    210e:	eb 81       	ldd	r30, Y+3	; 0x03
    2110:	fc 81       	ldd	r31, Y+4	; 0x04
    2112:	84 8d       	ldd	r24, Z+28	; 0x1c
    2114:	88 2f       	mov	r24, r24
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	82 0f       	add	r24, r18
    211a:	93 1f       	adc	r25, r19
    211c:	eb 81       	ldd	r30, Y+3	; 0x03
    211e:	fc 81       	ldd	r31, Y+4	; 0x04
    2120:	93 83       	std	Z+3, r25	; 0x03
    2122:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2124:	eb 81       	ldd	r30, Y+3	; 0x03
    2126:	fc 81       	ldd	r31, Y+4	; 0x04
    2128:	22 81       	ldd	r18, Z+2	; 0x02
    212a:	33 81       	ldd	r19, Z+3	; 0x03
    212c:	eb 81       	ldd	r30, Y+3	; 0x03
    212e:	fc 81       	ldd	r31, Y+4	; 0x04
    2130:	84 81       	ldd	r24, Z+4	; 0x04
    2132:	95 81       	ldd	r25, Z+5	; 0x05
    2134:	28 17       	cp	r18, r24
    2136:	39 07       	cpc	r19, r25
    2138:	08 f4       	brcc	.+2      	; 0x213c <prvCopyDataToQueue+0x8e>
    213a:	50 c0       	rjmp	.+160    	; 0x21dc <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    213c:	eb 81       	ldd	r30, Y+3	; 0x03
    213e:	fc 81       	ldd	r31, Y+4	; 0x04
    2140:	80 81       	ld	r24, Z
    2142:	91 81       	ldd	r25, Z+1	; 0x01
    2144:	eb 81       	ldd	r30, Y+3	; 0x03
    2146:	fc 81       	ldd	r31, Y+4	; 0x04
    2148:	93 83       	std	Z+3, r25	; 0x03
    214a:	82 83       	std	Z+2, r24	; 0x02
    214c:	47 c0       	rjmp	.+142    	; 0x21dc <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    214e:	eb 81       	ldd	r30, Y+3	; 0x03
    2150:	fc 81       	ldd	r31, Y+4	; 0x04
    2152:	66 81       	ldd	r22, Z+6	; 0x06
    2154:	77 81       	ldd	r23, Z+7	; 0x07
    2156:	eb 81       	ldd	r30, Y+3	; 0x03
    2158:	fc 81       	ldd	r31, Y+4	; 0x04
    215a:	84 8d       	ldd	r24, Z+28	; 0x1c
    215c:	48 2f       	mov	r20, r24
    215e:	50 e0       	ldi	r21, 0x00	; 0
    2160:	2d 81       	ldd	r18, Y+5	; 0x05
    2162:	3e 81       	ldd	r19, Y+6	; 0x06
    2164:	cb 01       	movw	r24, r22
    2166:	b9 01       	movw	r22, r18
    2168:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    216c:	eb 81       	ldd	r30, Y+3	; 0x03
    216e:	fc 81       	ldd	r31, Y+4	; 0x04
    2170:	26 81       	ldd	r18, Z+6	; 0x06
    2172:	37 81       	ldd	r19, Z+7	; 0x07
    2174:	eb 81       	ldd	r30, Y+3	; 0x03
    2176:	fc 81       	ldd	r31, Y+4	; 0x04
    2178:	84 8d       	ldd	r24, Z+28	; 0x1c
    217a:	88 2f       	mov	r24, r24
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	90 95       	com	r25
    2180:	81 95       	neg	r24
    2182:	9f 4f       	sbci	r25, 0xFF	; 255
    2184:	82 0f       	add	r24, r18
    2186:	93 1f       	adc	r25, r19
    2188:	eb 81       	ldd	r30, Y+3	; 0x03
    218a:	fc 81       	ldd	r31, Y+4	; 0x04
    218c:	97 83       	std	Z+7, r25	; 0x07
    218e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2190:	eb 81       	ldd	r30, Y+3	; 0x03
    2192:	fc 81       	ldd	r31, Y+4	; 0x04
    2194:	26 81       	ldd	r18, Z+6	; 0x06
    2196:	37 81       	ldd	r19, Z+7	; 0x07
    2198:	eb 81       	ldd	r30, Y+3	; 0x03
    219a:	fc 81       	ldd	r31, Y+4	; 0x04
    219c:	80 81       	ld	r24, Z
    219e:	91 81       	ldd	r25, Z+1	; 0x01
    21a0:	28 17       	cp	r18, r24
    21a2:	39 07       	cpc	r19, r25
    21a4:	90 f4       	brcc	.+36     	; 0x21ca <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    21a6:	eb 81       	ldd	r30, Y+3	; 0x03
    21a8:	fc 81       	ldd	r31, Y+4	; 0x04
    21aa:	24 81       	ldd	r18, Z+4	; 0x04
    21ac:	35 81       	ldd	r19, Z+5	; 0x05
    21ae:	eb 81       	ldd	r30, Y+3	; 0x03
    21b0:	fc 81       	ldd	r31, Y+4	; 0x04
    21b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21b4:	88 2f       	mov	r24, r24
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	90 95       	com	r25
    21ba:	81 95       	neg	r24
    21bc:	9f 4f       	sbci	r25, 0xFF	; 255
    21be:	82 0f       	add	r24, r18
    21c0:	93 1f       	adc	r25, r19
    21c2:	eb 81       	ldd	r30, Y+3	; 0x03
    21c4:	fc 81       	ldd	r31, Y+4	; 0x04
    21c6:	97 83       	std	Z+7, r25	; 0x07
    21c8:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    21ca:	8f 81       	ldd	r24, Y+7	; 0x07
    21cc:	82 30       	cpi	r24, 0x02	; 2
    21ce:	31 f4       	brne	.+12     	; 0x21dc <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21d0:	89 81       	ldd	r24, Y+1	; 0x01
    21d2:	88 23       	and	r24, r24
    21d4:	19 f0       	breq	.+6      	; 0x21dc <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    21d6:	89 81       	ldd	r24, Y+1	; 0x01
    21d8:	81 50       	subi	r24, 0x01	; 1
    21da:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	8f 5f       	subi	r24, 0xFF	; 255
    21e0:	eb 81       	ldd	r30, Y+3	; 0x03
    21e2:	fc 81       	ldd	r31, Y+4	; 0x04
    21e4:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    21e6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    21e8:	27 96       	adiw	r28, 0x07	; 7
    21ea:	0f b6       	in	r0, 0x3f	; 63
    21ec:	f8 94       	cli
    21ee:	de bf       	out	0x3e, r29	; 62
    21f0:	0f be       	out	0x3f, r0	; 63
    21f2:	cd bf       	out	0x3d, r28	; 61
    21f4:	cf 91       	pop	r28
    21f6:	df 91       	pop	r29
    21f8:	08 95       	ret

000021fa <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    21fa:	df 93       	push	r29
    21fc:	cf 93       	push	r28
    21fe:	00 d0       	rcall	.+0      	; 0x2200 <prvCopyDataFromQueue+0x6>
    2200:	00 d0       	rcall	.+0      	; 0x2202 <prvCopyDataFromQueue+0x8>
    2202:	cd b7       	in	r28, 0x3d	; 61
    2204:	de b7       	in	r29, 0x3e	; 62
    2206:	9a 83       	std	Y+2, r25	; 0x02
    2208:	89 83       	std	Y+1, r24	; 0x01
    220a:	7c 83       	std	Y+4, r23	; 0x04
    220c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	84 8d       	ldd	r24, Z+28	; 0x1c
    2214:	88 23       	and	r24, r24
    2216:	89 f1       	breq	.+98     	; 0x227a <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2218:	e9 81       	ldd	r30, Y+1	; 0x01
    221a:	fa 81       	ldd	r31, Y+2	; 0x02
    221c:	26 81       	ldd	r18, Z+6	; 0x06
    221e:	37 81       	ldd	r19, Z+7	; 0x07
    2220:	e9 81       	ldd	r30, Y+1	; 0x01
    2222:	fa 81       	ldd	r31, Y+2	; 0x02
    2224:	84 8d       	ldd	r24, Z+28	; 0x1c
    2226:	88 2f       	mov	r24, r24
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	82 0f       	add	r24, r18
    222c:	93 1f       	adc	r25, r19
    222e:	e9 81       	ldd	r30, Y+1	; 0x01
    2230:	fa 81       	ldd	r31, Y+2	; 0x02
    2232:	97 83       	std	Z+7, r25	; 0x07
    2234:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2236:	e9 81       	ldd	r30, Y+1	; 0x01
    2238:	fa 81       	ldd	r31, Y+2	; 0x02
    223a:	26 81       	ldd	r18, Z+6	; 0x06
    223c:	37 81       	ldd	r19, Z+7	; 0x07
    223e:	e9 81       	ldd	r30, Y+1	; 0x01
    2240:	fa 81       	ldd	r31, Y+2	; 0x02
    2242:	84 81       	ldd	r24, Z+4	; 0x04
    2244:	95 81       	ldd	r25, Z+5	; 0x05
    2246:	28 17       	cp	r18, r24
    2248:	39 07       	cpc	r19, r25
    224a:	40 f0       	brcs	.+16     	; 0x225c <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    224c:	e9 81       	ldd	r30, Y+1	; 0x01
    224e:	fa 81       	ldd	r31, Y+2	; 0x02
    2250:	80 81       	ld	r24, Z
    2252:	91 81       	ldd	r25, Z+1	; 0x01
    2254:	e9 81       	ldd	r30, Y+1	; 0x01
    2256:	fa 81       	ldd	r31, Y+2	; 0x02
    2258:	97 83       	std	Z+7, r25	; 0x07
    225a:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    225c:	e9 81       	ldd	r30, Y+1	; 0x01
    225e:	fa 81       	ldd	r31, Y+2	; 0x02
    2260:	46 81       	ldd	r20, Z+6	; 0x06
    2262:	57 81       	ldd	r21, Z+7	; 0x07
    2264:	e9 81       	ldd	r30, Y+1	; 0x01
    2266:	fa 81       	ldd	r31, Y+2	; 0x02
    2268:	84 8d       	ldd	r24, Z+28	; 0x1c
    226a:	28 2f       	mov	r18, r24
    226c:	30 e0       	ldi	r19, 0x00	; 0
    226e:	8b 81       	ldd	r24, Y+3	; 0x03
    2270:	9c 81       	ldd	r25, Y+4	; 0x04
    2272:	ba 01       	movw	r22, r20
    2274:	a9 01       	movw	r20, r18
    2276:	0e 94 3c 2c 	call	0x5878	; 0x5878 <memcpy>
	}
}
    227a:	0f 90       	pop	r0
    227c:	0f 90       	pop	r0
    227e:	0f 90       	pop	r0
    2280:	0f 90       	pop	r0
    2282:	cf 91       	pop	r28
    2284:	df 91       	pop	r29
    2286:	08 95       	ret

00002288 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2288:	df 93       	push	r29
    228a:	cf 93       	push	r28
    228c:	00 d0       	rcall	.+0      	; 0x228e <prvUnlockQueue+0x6>
    228e:	00 d0       	rcall	.+0      	; 0x2290 <prvUnlockQueue+0x8>
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
    2294:	9c 83       	std	Y+4, r25	; 0x04
    2296:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	f8 94       	cli
    229c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    229e:	eb 81       	ldd	r30, Y+3	; 0x03
    22a0:	fc 81       	ldd	r31, Y+4	; 0x04
    22a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22a4:	8a 83       	std	Y+2, r24	; 0x02
    22a6:	11 c0       	rjmp	.+34     	; 0x22ca <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22a8:	eb 81       	ldd	r30, Y+3	; 0x03
    22aa:	fc 81       	ldd	r31, Y+4	; 0x04
    22ac:	81 89       	ldd	r24, Z+17	; 0x11
    22ae:	88 23       	and	r24, r24
    22b0:	79 f0       	breq	.+30     	; 0x22d0 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22b2:	8b 81       	ldd	r24, Y+3	; 0x03
    22b4:	9c 81       	ldd	r25, Y+4	; 0x04
    22b6:	41 96       	adiw	r24, 0x11	; 17
    22b8:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    22bc:	88 23       	and	r24, r24
    22be:	11 f0       	breq	.+4      	; 0x22c4 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    22c0:	0e 94 cc 1b 	call	0x3798	; 0x3798 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    22c4:	8a 81       	ldd	r24, Y+2	; 0x02
    22c6:	81 50       	subi	r24, 0x01	; 1
    22c8:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    22ca:	8a 81       	ldd	r24, Y+2	; 0x02
    22cc:	18 16       	cp	r1, r24
    22ce:	64 f3       	brlt	.-40     	; 0x22a8 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    22d0:	eb 81       	ldd	r30, Y+3	; 0x03
    22d2:	fc 81       	ldd	r31, Y+4	; 0x04
    22d4:	8f ef       	ldi	r24, 0xFF	; 255
    22d6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    22d8:	0f 90       	pop	r0
    22da:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    22dc:	0f b6       	in	r0, 0x3f	; 63
    22de:	f8 94       	cli
    22e0:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    22e2:	eb 81       	ldd	r30, Y+3	; 0x03
    22e4:	fc 81       	ldd	r31, Y+4	; 0x04
    22e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    22e8:	89 83       	std	Y+1, r24	; 0x01
    22ea:	11 c0       	rjmp	.+34     	; 0x230e <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22ec:	eb 81       	ldd	r30, Y+3	; 0x03
    22ee:	fc 81       	ldd	r31, Y+4	; 0x04
    22f0:	80 85       	ldd	r24, Z+8	; 0x08
    22f2:	88 23       	and	r24, r24
    22f4:	79 f0       	breq	.+30     	; 0x2314 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22f6:	8b 81       	ldd	r24, Y+3	; 0x03
    22f8:	9c 81       	ldd	r25, Y+4	; 0x04
    22fa:	08 96       	adiw	r24, 0x08	; 8
    22fc:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xTaskRemoveFromEventList>
    2300:	88 23       	and	r24, r24
    2302:	11 f0       	breq	.+4      	; 0x2308 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2304:	0e 94 cc 1b 	call	0x3798	; 0x3798 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2308:	89 81       	ldd	r24, Y+1	; 0x01
    230a:	81 50       	subi	r24, 0x01	; 1
    230c:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    230e:	89 81       	ldd	r24, Y+1	; 0x01
    2310:	18 16       	cp	r1, r24
    2312:	64 f3       	brlt	.-40     	; 0x22ec <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2314:	eb 81       	ldd	r30, Y+3	; 0x03
    2316:	fc 81       	ldd	r31, Y+4	; 0x04
    2318:	8f ef       	ldi	r24, 0xFF	; 255
    231a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    231c:	0f 90       	pop	r0
    231e:	0f be       	out	0x3f, r0	; 63
}
    2320:	0f 90       	pop	r0
    2322:	0f 90       	pop	r0
    2324:	0f 90       	pop	r0
    2326:	0f 90       	pop	r0
    2328:	cf 91       	pop	r28
    232a:	df 91       	pop	r29
    232c:	08 95       	ret

0000232e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    232e:	df 93       	push	r29
    2330:	cf 93       	push	r28
    2332:	00 d0       	rcall	.+0      	; 0x2334 <prvIsQueueEmpty+0x6>
    2334:	0f 92       	push	r0
    2336:	cd b7       	in	r28, 0x3d	; 61
    2338:	de b7       	in	r29, 0x3e	; 62
    233a:	9b 83       	std	Y+3, r25	; 0x03
    233c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2344:	ea 81       	ldd	r30, Y+2	; 0x02
    2346:	fb 81       	ldd	r31, Y+3	; 0x03
    2348:	82 8d       	ldd	r24, Z+26	; 0x1a
    234a:	88 23       	and	r24, r24
    234c:	19 f4       	brne	.+6      	; 0x2354 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    234e:	81 e0       	ldi	r24, 0x01	; 1
    2350:	89 83       	std	Y+1, r24	; 0x01
    2352:	01 c0       	rjmp	.+2      	; 0x2356 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2354:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2356:	0f 90       	pop	r0
    2358:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    235a:	89 81       	ldd	r24, Y+1	; 0x01
}
    235c:	0f 90       	pop	r0
    235e:	0f 90       	pop	r0
    2360:	0f 90       	pop	r0
    2362:	cf 91       	pop	r28
    2364:	df 91       	pop	r29
    2366:	08 95       	ret

00002368 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2368:	df 93       	push	r29
    236a:	cf 93       	push	r28
    236c:	00 d0       	rcall	.+0      	; 0x236e <xQueueIsQueueEmptyFromISR+0x6>
    236e:	00 d0       	rcall	.+0      	; 0x2370 <xQueueIsQueueEmptyFromISR+0x8>
    2370:	0f 92       	push	r0
    2372:	cd b7       	in	r28, 0x3d	; 61
    2374:	de b7       	in	r29, 0x3e	; 62
    2376:	9d 83       	std	Y+5, r25	; 0x05
    2378:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    237a:	8c 81       	ldd	r24, Y+4	; 0x04
    237c:	9d 81       	ldd	r25, Y+5	; 0x05
    237e:	9a 83       	std	Y+2, r25	; 0x02
    2380:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2382:	e9 81       	ldd	r30, Y+1	; 0x01
    2384:	fa 81       	ldd	r31, Y+2	; 0x02
    2386:	82 8d       	ldd	r24, Z+26	; 0x1a
    2388:	88 23       	and	r24, r24
    238a:	19 f4       	brne	.+6      	; 0x2392 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    238c:	81 e0       	ldi	r24, 0x01	; 1
    238e:	8b 83       	std	Y+3, r24	; 0x03
    2390:	01 c0       	rjmp	.+2      	; 0x2394 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2392:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2396:	0f 90       	pop	r0
    2398:	0f 90       	pop	r0
    239a:	0f 90       	pop	r0
    239c:	0f 90       	pop	r0
    239e:	0f 90       	pop	r0
    23a0:	cf 91       	pop	r28
    23a2:	df 91       	pop	r29
    23a4:	08 95       	ret

000023a6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    23a6:	df 93       	push	r29
    23a8:	cf 93       	push	r28
    23aa:	00 d0       	rcall	.+0      	; 0x23ac <prvIsQueueFull+0x6>
    23ac:	0f 92       	push	r0
    23ae:	cd b7       	in	r28, 0x3d	; 61
    23b0:	de b7       	in	r29, 0x3e	; 62
    23b2:	9b 83       	std	Y+3, r25	; 0x03
    23b4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    23bc:	ea 81       	ldd	r30, Y+2	; 0x02
    23be:	fb 81       	ldd	r31, Y+3	; 0x03
    23c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    23c2:	ea 81       	ldd	r30, Y+2	; 0x02
    23c4:	fb 81       	ldd	r31, Y+3	; 0x03
    23c6:	83 8d       	ldd	r24, Z+27	; 0x1b
    23c8:	98 17       	cp	r25, r24
    23ca:	19 f4       	brne	.+6      	; 0x23d2 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	89 83       	std	Y+1, r24	; 0x01
    23d0:	01 c0       	rjmp	.+2      	; 0x23d4 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    23d2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    23d4:	0f 90       	pop	r0
    23d6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    23da:	0f 90       	pop	r0
    23dc:	0f 90       	pop	r0
    23de:	0f 90       	pop	r0
    23e0:	cf 91       	pop	r28
    23e2:	df 91       	pop	r29
    23e4:	08 95       	ret

000023e6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    23e6:	df 93       	push	r29
    23e8:	cf 93       	push	r28
    23ea:	00 d0       	rcall	.+0      	; 0x23ec <xQueueIsQueueFullFromISR+0x6>
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <xQueueIsQueueFullFromISR+0x8>
    23ee:	0f 92       	push	r0
    23f0:	cd b7       	in	r28, 0x3d	; 61
    23f2:	de b7       	in	r29, 0x3e	; 62
    23f4:	9d 83       	std	Y+5, r25	; 0x05
    23f6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    23f8:	8c 81       	ldd	r24, Y+4	; 0x04
    23fa:	9d 81       	ldd	r25, Y+5	; 0x05
    23fc:	9a 83       	std	Y+2, r25	; 0x02
    23fe:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2400:	e9 81       	ldd	r30, Y+1	; 0x01
    2402:	fa 81       	ldd	r31, Y+2	; 0x02
    2404:	92 8d       	ldd	r25, Z+26	; 0x1a
    2406:	e9 81       	ldd	r30, Y+1	; 0x01
    2408:	fa 81       	ldd	r31, Y+2	; 0x02
    240a:	83 8d       	ldd	r24, Z+27	; 0x1b
    240c:	98 17       	cp	r25, r24
    240e:	19 f4       	brne	.+6      	; 0x2416 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2410:	81 e0       	ldi	r24, 0x01	; 1
    2412:	8b 83       	std	Y+3, r24	; 0x03
    2414:	01 c0       	rjmp	.+2      	; 0x2418 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2416:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2418:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    241a:	0f 90       	pop	r0
    241c:	0f 90       	pop	r0
    241e:	0f 90       	pop	r0
    2420:	0f 90       	pop	r0
    2422:	0f 90       	pop	r0
    2424:	cf 91       	pop	r28
    2426:	df 91       	pop	r29
    2428:	08 95       	ret

0000242a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    242a:	8f 92       	push	r8
    242c:	9f 92       	push	r9
    242e:	af 92       	push	r10
    2430:	bf 92       	push	r11
    2432:	cf 92       	push	r12
    2434:	df 92       	push	r13
    2436:	ef 92       	push	r14
    2438:	ff 92       	push	r15
    243a:	0f 93       	push	r16
    243c:	1f 93       	push	r17
    243e:	df 93       	push	r29
    2440:	cf 93       	push	r28
    2442:	cd b7       	in	r28, 0x3d	; 61
    2444:	de b7       	in	r29, 0x3e	; 62
    2446:	60 97       	sbiw	r28, 0x10	; 16
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	f8 94       	cli
    244c:	de bf       	out	0x3e, r29	; 62
    244e:	0f be       	out	0x3f, r0	; 63
    2450:	cd bf       	out	0x3d, r28	; 61
    2452:	9f 83       	std	Y+7, r25	; 0x07
    2454:	8e 83       	std	Y+6, r24	; 0x06
    2456:	79 87       	std	Y+9, r23	; 0x09
    2458:	68 87       	std	Y+8, r22	; 0x08
    245a:	5b 87       	std	Y+11, r21	; 0x0b
    245c:	4a 87       	std	Y+10, r20	; 0x0a
    245e:	3d 87       	std	Y+13, r19	; 0x0d
    2460:	2c 87       	std	Y+12, r18	; 0x0c
    2462:	0e 87       	std	Y+14, r16	; 0x0e
    2464:	f8 8a       	std	Y+16, r15	; 0x10
    2466:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2468:	8a 85       	ldd	r24, Y+10	; 0x0a
    246a:	9b 85       	ldd	r25, Y+11	; 0x0b
    246c:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    2470:	9a 83       	std	Y+2, r25	; 0x02
    2472:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2474:	89 81       	ldd	r24, Y+1	; 0x01
    2476:	9a 81       	ldd	r25, Y+2	; 0x02
    2478:	00 97       	sbiw	r24, 0x00	; 0
    247a:	b1 f0       	breq	.+44     	; 0x24a8 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    247c:	86 e2       	ldi	r24, 0x26	; 38
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	0e 94 4f 06 	call	0xc9e	; 0xc9e <pvPortMalloc>
    2484:	9d 83       	std	Y+5, r25	; 0x05
    2486:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2488:	8c 81       	ldd	r24, Y+4	; 0x04
    248a:	9d 81       	ldd	r25, Y+5	; 0x05
    248c:	00 97       	sbiw	r24, 0x00	; 0
    248e:	39 f0       	breq	.+14     	; 0x249e <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2490:	ec 81       	ldd	r30, Y+4	; 0x04
    2492:	fd 81       	ldd	r31, Y+5	; 0x05
    2494:	89 81       	ldd	r24, Y+1	; 0x01
    2496:	9a 81       	ldd	r25, Y+2	; 0x02
    2498:	90 8f       	std	Z+24, r25	; 0x18
    249a:	87 8b       	std	Z+23, r24	; 0x17
    249c:	07 c0       	rjmp	.+14     	; 0x24ac <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    249e:	89 81       	ldd	r24, Y+1	; 0x01
    24a0:	9a 81       	ldd	r25, Y+2	; 0x02
    24a2:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vPortFree>
    24a6:	02 c0       	rjmp	.+4      	; 0x24ac <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    24a8:	1d 82       	std	Y+5, r1	; 0x05
    24aa:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    24ac:	8c 81       	ldd	r24, Y+4	; 0x04
    24ae:	9d 81       	ldd	r25, Y+5	; 0x05
    24b0:	00 97       	sbiw	r24, 0x00	; 0
    24b2:	e9 f0       	breq	.+58     	; 0x24ee <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    24b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    24b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    24b8:	9c 01       	movw	r18, r24
    24ba:	40 e0       	ldi	r20, 0x00	; 0
    24bc:	50 e0       	ldi	r21, 0x00	; 0
    24be:	8e 81       	ldd	r24, Y+6	; 0x06
    24c0:	9f 81       	ldd	r25, Y+7	; 0x07
    24c2:	68 85       	ldd	r22, Y+8	; 0x08
    24c4:	79 85       	ldd	r23, Y+9	; 0x09
    24c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    24c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    24ca:	af 85       	ldd	r26, Y+15	; 0x0f
    24cc:	b8 89       	ldd	r27, Y+16	; 0x10
    24ce:	ac 80       	ldd	r10, Y+4	; 0x04
    24d0:	bd 80       	ldd	r11, Y+5	; 0x05
    24d2:	8f 01       	movw	r16, r30
    24d4:	ee 84       	ldd	r14, Y+14	; 0x0e
    24d6:	6d 01       	movw	r12, r26
    24d8:	88 24       	eor	r8, r8
    24da:	99 24       	eor	r9, r9
    24dc:	0e 94 8d 12 	call	0x251a	; 0x251a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    24e0:	8c 81       	ldd	r24, Y+4	; 0x04
    24e2:	9d 81       	ldd	r25, Y+5	; 0x05
    24e4:	0e 94 49 13 	call	0x2692	; 0x2692 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    24e8:	81 e0       	ldi	r24, 0x01	; 1
    24ea:	8b 83       	std	Y+3, r24	; 0x03
    24ec:	02 c0       	rjmp	.+4      	; 0x24f2 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    24ee:	8f ef       	ldi	r24, 0xFF	; 255
    24f0:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    24f2:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    24f4:	60 96       	adiw	r28, 0x10	; 16
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	de bf       	out	0x3e, r29	; 62
    24fc:	0f be       	out	0x3f, r0	; 63
    24fe:	cd bf       	out	0x3d, r28	; 61
    2500:	cf 91       	pop	r28
    2502:	df 91       	pop	r29
    2504:	1f 91       	pop	r17
    2506:	0f 91       	pop	r16
    2508:	ff 90       	pop	r15
    250a:	ef 90       	pop	r14
    250c:	df 90       	pop	r13
    250e:	cf 90       	pop	r12
    2510:	bf 90       	pop	r11
    2512:	af 90       	pop	r10
    2514:	9f 90       	pop	r9
    2516:	8f 90       	pop	r8
    2518:	08 95       	ret

0000251a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    251a:	8f 92       	push	r8
    251c:	9f 92       	push	r9
    251e:	af 92       	push	r10
    2520:	bf 92       	push	r11
    2522:	cf 92       	push	r12
    2524:	df 92       	push	r13
    2526:	ef 92       	push	r14
    2528:	0f 93       	push	r16
    252a:	1f 93       	push	r17
    252c:	df 93       	push	r29
    252e:	cf 93       	push	r28
    2530:	cd b7       	in	r28, 0x3d	; 61
    2532:	de b7       	in	r29, 0x3e	; 62
    2534:	64 97       	sbiw	r28, 0x14	; 20
    2536:	0f b6       	in	r0, 0x3f	; 63
    2538:	f8 94       	cli
    253a:	de bf       	out	0x3e, r29	; 62
    253c:	0f be       	out	0x3f, r0	; 63
    253e:	cd bf       	out	0x3d, r28	; 61
    2540:	9d 83       	std	Y+5, r25	; 0x05
    2542:	8c 83       	std	Y+4, r24	; 0x04
    2544:	7f 83       	std	Y+7, r23	; 0x07
    2546:	6e 83       	std	Y+6, r22	; 0x06
    2548:	28 87       	std	Y+8, r18	; 0x08
    254a:	39 87       	std	Y+9, r19	; 0x09
    254c:	4a 87       	std	Y+10, r20	; 0x0a
    254e:	5b 87       	std	Y+11, r21	; 0x0b
    2550:	1d 87       	std	Y+13, r17	; 0x0d
    2552:	0c 87       	std	Y+12, r16	; 0x0c
    2554:	ee 86       	std	Y+14, r14	; 0x0e
    2556:	d8 8a       	std	Y+16, r13	; 0x10
    2558:	cf 86       	std	Y+15, r12	; 0x0f
    255a:	ba 8a       	std	Y+18, r11	; 0x12
    255c:	a9 8a       	std	Y+17, r10	; 0x11
    255e:	9c 8a       	std	Y+20, r9	; 0x14
    2560:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2562:	e9 89       	ldd	r30, Y+17	; 0x11
    2564:	fa 89       	ldd	r31, Y+18	; 0x12
    2566:	27 89       	ldd	r18, Z+23	; 0x17
    2568:	30 8d       	ldd	r19, Z+24	; 0x18
    256a:	88 85       	ldd	r24, Y+8	; 0x08
    256c:	99 85       	ldd	r25, Y+9	; 0x09
    256e:	01 97       	sbiw	r24, 0x01	; 1
    2570:	82 0f       	add	r24, r18
    2572:	93 1f       	adc	r25, r19
    2574:	9b 83       	std	Y+3, r25	; 0x03
    2576:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2578:	8e 81       	ldd	r24, Y+6	; 0x06
    257a:	9f 81       	ldd	r25, Y+7	; 0x07
    257c:	00 97       	sbiw	r24, 0x00	; 0
    257e:	51 f1       	breq	.+84     	; 0x25d4 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2580:	19 82       	std	Y+1, r1	; 0x01
    2582:	21 c0       	rjmp	.+66     	; 0x25c6 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2584:	89 81       	ldd	r24, Y+1	; 0x01
    2586:	48 2f       	mov	r20, r24
    2588:	50 e0       	ldi	r21, 0x00	; 0
    258a:	89 81       	ldd	r24, Y+1	; 0x01
    258c:	28 2f       	mov	r18, r24
    258e:	30 e0       	ldi	r19, 0x00	; 0
    2590:	8e 81       	ldd	r24, Y+6	; 0x06
    2592:	9f 81       	ldd	r25, Y+7	; 0x07
    2594:	fc 01       	movw	r30, r24
    2596:	e2 0f       	add	r30, r18
    2598:	f3 1f       	adc	r31, r19
    259a:	20 81       	ld	r18, Z
    259c:	89 89       	ldd	r24, Y+17	; 0x11
    259e:	9a 89       	ldd	r25, Y+18	; 0x12
    25a0:	84 0f       	add	r24, r20
    25a2:	95 1f       	adc	r25, r21
    25a4:	fc 01       	movw	r30, r24
    25a6:	79 96       	adiw	r30, 0x19	; 25
    25a8:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    25aa:	89 81       	ldd	r24, Y+1	; 0x01
    25ac:	28 2f       	mov	r18, r24
    25ae:	30 e0       	ldi	r19, 0x00	; 0
    25b0:	8e 81       	ldd	r24, Y+6	; 0x06
    25b2:	9f 81       	ldd	r25, Y+7	; 0x07
    25b4:	fc 01       	movw	r30, r24
    25b6:	e2 0f       	add	r30, r18
    25b8:	f3 1f       	adc	r31, r19
    25ba:	80 81       	ld	r24, Z
    25bc:	88 23       	and	r24, r24
    25be:	31 f0       	breq	.+12     	; 0x25cc <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    25c0:	89 81       	ldd	r24, Y+1	; 0x01
    25c2:	8f 5f       	subi	r24, 0xFF	; 255
    25c4:	89 83       	std	Y+1, r24	; 0x01
    25c6:	89 81       	ldd	r24, Y+1	; 0x01
    25c8:	88 30       	cpi	r24, 0x08	; 8
    25ca:	e0 f2       	brcs	.-72     	; 0x2584 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    25cc:	e9 89       	ldd	r30, Y+17	; 0x11
    25ce:	fa 89       	ldd	r31, Y+18	; 0x12
    25d0:	10 a2       	std	Z+32, r1	; 0x20
    25d2:	03 c0       	rjmp	.+6      	; 0x25da <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    25d4:	e9 89       	ldd	r30, Y+17	; 0x11
    25d6:	fa 89       	ldd	r31, Y+18	; 0x12
    25d8:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    25da:	8e 85       	ldd	r24, Y+14	; 0x0e
    25dc:	85 30       	cpi	r24, 0x05	; 5
    25de:	10 f0       	brcs	.+4      	; 0x25e4 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    25e0:	84 e0       	ldi	r24, 0x04	; 4
    25e2:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    25e4:	e9 89       	ldd	r30, Y+17	; 0x11
    25e6:	fa 89       	ldd	r31, Y+18	; 0x12
    25e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    25ea:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    25ec:	89 89       	ldd	r24, Y+17	; 0x11
    25ee:	9a 89       	ldd	r25, Y+18	; 0x12
    25f0:	02 96       	adiw	r24, 0x02	; 2
    25f2:	0e 94 f5 06 	call	0xdea	; 0xdea <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    25f6:	89 89       	ldd	r24, Y+17	; 0x11
    25f8:	9a 89       	ldd	r25, Y+18	; 0x12
    25fa:	0c 96       	adiw	r24, 0x0c	; 12
    25fc:	0e 94 f5 06 	call	0xdea	; 0xdea <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2600:	e9 89       	ldd	r30, Y+17	; 0x11
    2602:	fa 89       	ldd	r31, Y+18	; 0x12
    2604:	89 89       	ldd	r24, Y+17	; 0x11
    2606:	9a 89       	ldd	r25, Y+18	; 0x12
    2608:	91 87       	std	Z+9, r25	; 0x09
    260a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    260c:	8e 85       	ldd	r24, Y+14	; 0x0e
    260e:	28 2f       	mov	r18, r24
    2610:	30 e0       	ldi	r19, 0x00	; 0
    2612:	85 e0       	ldi	r24, 0x05	; 5
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	82 1b       	sub	r24, r18
    2618:	93 0b       	sbc	r25, r19
    261a:	e9 89       	ldd	r30, Y+17	; 0x11
    261c:	fa 89       	ldd	r31, Y+18	; 0x12
    261e:	95 87       	std	Z+13, r25	; 0x0d
    2620:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2622:	e9 89       	ldd	r30, Y+17	; 0x11
    2624:	fa 89       	ldd	r31, Y+18	; 0x12
    2626:	89 89       	ldd	r24, Y+17	; 0x11
    2628:	9a 89       	ldd	r25, Y+18	; 0x12
    262a:	93 8b       	std	Z+19, r25	; 0x13
    262c:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    262e:	e9 89       	ldd	r30, Y+17	; 0x11
    2630:	fa 89       	ldd	r31, Y+18	; 0x12
    2632:	11 a2       	std	Z+33, r1	; 0x21
    2634:	12 a2       	std	Z+34, r1	; 0x22
    2636:	13 a2       	std	Z+35, r1	; 0x23
    2638:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    263a:	e9 89       	ldd	r30, Y+17	; 0x11
    263c:	fa 89       	ldd	r31, Y+18	; 0x12
    263e:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2640:	8a 81       	ldd	r24, Y+2	; 0x02
    2642:	9b 81       	ldd	r25, Y+3	; 0x03
    2644:	2c 81       	ldd	r18, Y+4	; 0x04
    2646:	3d 81       	ldd	r19, Y+5	; 0x05
    2648:	4c 85       	ldd	r20, Y+12	; 0x0c
    264a:	5d 85       	ldd	r21, Y+13	; 0x0d
    264c:	b9 01       	movw	r22, r18
    264e:	0e 94 01 08 	call	0x1002	; 0x1002 <pxPortInitialiseStack>
    2652:	e9 89       	ldd	r30, Y+17	; 0x11
    2654:	fa 89       	ldd	r31, Y+18	; 0x12
    2656:	91 83       	std	Z+1, r25	; 0x01
    2658:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    265a:	8f 85       	ldd	r24, Y+15	; 0x0f
    265c:	98 89       	ldd	r25, Y+16	; 0x10
    265e:	00 97       	sbiw	r24, 0x00	; 0
    2660:	31 f0       	breq	.+12     	; 0x266e <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2662:	ef 85       	ldd	r30, Y+15	; 0x0f
    2664:	f8 89       	ldd	r31, Y+16	; 0x10
    2666:	89 89       	ldd	r24, Y+17	; 0x11
    2668:	9a 89       	ldd	r25, Y+18	; 0x12
    266a:	91 83       	std	Z+1, r25	; 0x01
    266c:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    266e:	64 96       	adiw	r28, 0x14	; 20
    2670:	0f b6       	in	r0, 0x3f	; 63
    2672:	f8 94       	cli
    2674:	de bf       	out	0x3e, r29	; 62
    2676:	0f be       	out	0x3f, r0	; 63
    2678:	cd bf       	out	0x3d, r28	; 61
    267a:	cf 91       	pop	r28
    267c:	df 91       	pop	r29
    267e:	1f 91       	pop	r17
    2680:	0f 91       	pop	r16
    2682:	ef 90       	pop	r14
    2684:	df 90       	pop	r13
    2686:	cf 90       	pop	r12
    2688:	bf 90       	pop	r11
    268a:	af 90       	pop	r10
    268c:	9f 90       	pop	r9
    268e:	8f 90       	pop	r8
    2690:	08 95       	ret

00002692 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2692:	df 93       	push	r29
    2694:	cf 93       	push	r28
    2696:	00 d0       	rcall	.+0      	; 0x2698 <prvAddNewTaskToReadyList+0x6>
    2698:	cd b7       	in	r28, 0x3d	; 61
    269a:	de b7       	in	r29, 0x3e	; 62
    269c:	9a 83       	std	Y+2, r25	; 0x02
    269e:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    26a6:	80 91 5d 04 	lds	r24, 0x045D
    26aa:	8f 5f       	subi	r24, 0xFF	; 255
    26ac:	80 93 5d 04 	sts	0x045D, r24
		if( pxCurrentTCB == NULL )
    26b0:	80 91 5a 04 	lds	r24, 0x045A
    26b4:	90 91 5b 04 	lds	r25, 0x045B
    26b8:	00 97       	sbiw	r24, 0x00	; 0
    26ba:	69 f4       	brne	.+26     	; 0x26d6 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	9a 81       	ldd	r25, Y+2	; 0x02
    26c0:	90 93 5b 04 	sts	0x045B, r25
    26c4:	80 93 5a 04 	sts	0x045A, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    26c8:	80 91 5d 04 	lds	r24, 0x045D
    26cc:	81 30       	cpi	r24, 0x01	; 1
    26ce:	b9 f4       	brne	.+46     	; 0x26fe <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    26d0:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <prvInitialiseTaskLists>
    26d4:	14 c0       	rjmp	.+40     	; 0x26fe <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    26d6:	80 91 61 04 	lds	r24, 0x0461
    26da:	88 23       	and	r24, r24
    26dc:	81 f4       	brne	.+32     	; 0x26fe <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    26de:	e0 91 5a 04 	lds	r30, 0x045A
    26e2:	f0 91 5b 04 	lds	r31, 0x045B
    26e6:	96 89       	ldd	r25, Z+22	; 0x16
    26e8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ea:	fa 81       	ldd	r31, Y+2	; 0x02
    26ec:	86 89       	ldd	r24, Z+22	; 0x16
    26ee:	89 17       	cp	r24, r25
    26f0:	30 f0       	brcs	.+12     	; 0x26fe <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
    26f4:	9a 81       	ldd	r25, Y+2	; 0x02
    26f6:	90 93 5b 04 	sts	0x045B, r25
    26fa:	80 93 5a 04 	sts	0x045A, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    26fe:	80 91 66 04 	lds	r24, 0x0466
    2702:	8f 5f       	subi	r24, 0xFF	; 255
    2704:	80 93 66 04 	sts	0x0466, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2708:	e9 81       	ldd	r30, Y+1	; 0x01
    270a:	fa 81       	ldd	r31, Y+2	; 0x02
    270c:	96 89       	ldd	r25, Z+22	; 0x16
    270e:	80 91 60 04 	lds	r24, 0x0460
    2712:	89 17       	cp	r24, r25
    2714:	28 f4       	brcc	.+10     	; 0x2720 <prvAddNewTaskToReadyList+0x8e>
    2716:	e9 81       	ldd	r30, Y+1	; 0x01
    2718:	fa 81       	ldd	r31, Y+2	; 0x02
    271a:	86 89       	ldd	r24, Z+22	; 0x16
    271c:	80 93 60 04 	sts	0x0460, r24
    2720:	e9 81       	ldd	r30, Y+1	; 0x01
    2722:	fa 81       	ldd	r31, Y+2	; 0x02
    2724:	86 89       	ldd	r24, Z+22	; 0x16
    2726:	28 2f       	mov	r18, r24
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	c9 01       	movw	r24, r18
    272c:	88 0f       	add	r24, r24
    272e:	99 1f       	adc	r25, r25
    2730:	88 0f       	add	r24, r24
    2732:	99 1f       	adc	r25, r25
    2734:	88 0f       	add	r24, r24
    2736:	99 1f       	adc	r25, r25
    2738:	82 0f       	add	r24, r18
    273a:	93 1f       	adc	r25, r19
    273c:	ac 01       	movw	r20, r24
    273e:	44 59       	subi	r20, 0x94	; 148
    2740:	5b 4f       	sbci	r21, 0xFB	; 251
    2742:	89 81       	ldd	r24, Y+1	; 0x01
    2744:	9a 81       	ldd	r25, Y+2	; 0x02
    2746:	9c 01       	movw	r18, r24
    2748:	2e 5f       	subi	r18, 0xFE	; 254
    274a:	3f 4f       	sbci	r19, 0xFF	; 255
    274c:	ca 01       	movw	r24, r20
    274e:	b9 01       	movw	r22, r18
    2750:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    2754:	0f 90       	pop	r0
    2756:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    2758:	80 91 61 04 	lds	r24, 0x0461
    275c:	88 23       	and	r24, r24
    275e:	61 f0       	breq	.+24     	; 0x2778 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2760:	e0 91 5a 04 	lds	r30, 0x045A
    2764:	f0 91 5b 04 	lds	r31, 0x045B
    2768:	96 89       	ldd	r25, Z+22	; 0x16
    276a:	e9 81       	ldd	r30, Y+1	; 0x01
    276c:	fa 81       	ldd	r31, Y+2	; 0x02
    276e:	86 89       	ldd	r24, Z+22	; 0x16
    2770:	98 17       	cp	r25, r24
    2772:	10 f4       	brcc	.+4      	; 0x2778 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    2774:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2778:	0f 90       	pop	r0
    277a:	0f 90       	pop	r0
    277c:	cf 91       	pop	r28
    277e:	df 91       	pop	r29
    2780:	08 95       	ret

00002782 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2782:	df 93       	push	r29
    2784:	cf 93       	push	r28
    2786:	00 d0       	rcall	.+0      	; 0x2788 <vTaskDelete+0x6>
    2788:	00 d0       	rcall	.+0      	; 0x278a <vTaskDelete+0x8>
    278a:	00 d0       	rcall	.+0      	; 0x278c <vTaskDelete+0xa>
    278c:	cd b7       	in	r28, 0x3d	; 61
    278e:	de b7       	in	r29, 0x3e	; 62
    2790:	9c 83       	std	Y+4, r25	; 0x04
    2792:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2794:	0f b6       	in	r0, 0x3f	; 63
    2796:	f8 94       	cli
    2798:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	00 97       	sbiw	r24, 0x00	; 0
    27a0:	39 f4       	brne	.+14     	; 0x27b0 <vTaskDelete+0x2e>
    27a2:	80 91 5a 04 	lds	r24, 0x045A
    27a6:	90 91 5b 04 	lds	r25, 0x045B
    27aa:	9e 83       	std	Y+6, r25	; 0x06
    27ac:	8d 83       	std	Y+5, r24	; 0x05
    27ae:	04 c0       	rjmp	.+8      	; 0x27b8 <vTaskDelete+0x36>
    27b0:	8b 81       	ldd	r24, Y+3	; 0x03
    27b2:	9c 81       	ldd	r25, Y+4	; 0x04
    27b4:	9e 83       	std	Y+6, r25	; 0x06
    27b6:	8d 83       	std	Y+5, r24	; 0x05
    27b8:	8d 81       	ldd	r24, Y+5	; 0x05
    27ba:	9e 81       	ldd	r25, Y+6	; 0x06
    27bc:	9a 83       	std	Y+2, r25	; 0x02
    27be:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    27c0:	89 81       	ldd	r24, Y+1	; 0x01
    27c2:	9a 81       	ldd	r25, Y+2	; 0x02
    27c4:	02 96       	adiw	r24, 0x02	; 2
    27c6:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    27ca:	e9 81       	ldd	r30, Y+1	; 0x01
    27cc:	fa 81       	ldd	r31, Y+2	; 0x02
    27ce:	84 89       	ldd	r24, Z+20	; 0x14
    27d0:	95 89       	ldd	r25, Z+21	; 0x15
    27d2:	00 97       	sbiw	r24, 0x00	; 0
    27d4:	29 f0       	breq	.+10     	; 0x27e0 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    27d6:	89 81       	ldd	r24, Y+1	; 0x01
    27d8:	9a 81       	ldd	r25, Y+2	; 0x02
    27da:	0c 96       	adiw	r24, 0x0c	; 12
    27dc:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    27e0:	80 91 66 04 	lds	r24, 0x0466
    27e4:	8f 5f       	subi	r24, 0xFF	; 255
    27e6:	80 93 66 04 	sts	0x0466, r24

			if( pxTCB == pxCurrentTCB )
    27ea:	20 91 5a 04 	lds	r18, 0x045A
    27ee:	30 91 5b 04 	lds	r19, 0x045B
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	9a 81       	ldd	r25, Y+2	; 0x02
    27f6:	82 17       	cp	r24, r18
    27f8:	93 07       	cpc	r25, r19
    27fa:	81 f4       	brne	.+32     	; 0x281c <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    27fc:	89 81       	ldd	r24, Y+1	; 0x01
    27fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2800:	9c 01       	movw	r18, r24
    2802:	2e 5f       	subi	r18, 0xFE	; 254
    2804:	3f 4f       	sbci	r19, 0xFF	; 255
    2806:	88 eb       	ldi	r24, 0xB8	; 184
    2808:	94 e0       	ldi	r25, 0x04	; 4
    280a:	b9 01       	movw	r22, r18
    280c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    2810:	80 91 5c 04 	lds	r24, 0x045C
    2814:	8f 5f       	subi	r24, 0xFF	; 255
    2816:	80 93 5c 04 	sts	0x045C, r24
    281a:	0b c0       	rjmp	.+22     	; 0x2832 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    281c:	80 91 5d 04 	lds	r24, 0x045D
    2820:	81 50       	subi	r24, 0x01	; 1
    2822:	80 93 5d 04 	sts	0x045D, r24
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
    2826:	89 81       	ldd	r24, Y+1	; 0x01
    2828:	9a 81       	ldd	r25, Y+2	; 0x02
    282a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    282e:	0e 94 66 1c 	call	0x38cc	; 0x38cc <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
    2832:	0f 90       	pop	r0
    2834:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2836:	80 91 61 04 	lds	r24, 0x0461
    283a:	88 23       	and	r24, r24
    283c:	59 f0       	breq	.+22     	; 0x2854 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    283e:	20 91 5a 04 	lds	r18, 0x045A
    2842:	30 91 5b 04 	lds	r19, 0x045B
    2846:	89 81       	ldd	r24, Y+1	; 0x01
    2848:	9a 81       	ldd	r25, Y+2	; 0x02
    284a:	82 17       	cp	r24, r18
    284c:	93 07       	cpc	r25, r19
    284e:	11 f4       	brne	.+4      	; 0x2854 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2850:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2854:	26 96       	adiw	r28, 0x06	; 6
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	de bf       	out	0x3e, r29	; 62
    285c:	0f be       	out	0x3f, r0	; 63
    285e:	cd bf       	out	0x3d, r28	; 61
    2860:	cf 91       	pop	r28
    2862:	df 91       	pop	r29
    2864:	08 95       	ret

00002866 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2866:	df 93       	push	r29
    2868:	cf 93       	push	r28
    286a:	cd b7       	in	r28, 0x3d	; 61
    286c:	de b7       	in	r29, 0x3e	; 62
    286e:	2a 97       	sbiw	r28, 0x0a	; 10
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	de bf       	out	0x3e, r29	; 62
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	cd bf       	out	0x3d, r28	; 61
    287a:	98 87       	std	Y+8, r25	; 0x08
    287c:	8f 83       	std	Y+7, r24	; 0x07
    287e:	7a 87       	std	Y+10, r23	; 0x0a
    2880:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2882:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2884:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2888:	80 91 5e 04 	lds	r24, 0x045E
    288c:	90 91 5f 04 	lds	r25, 0x045F
    2890:	9a 83       	std	Y+2, r25	; 0x02
    2892:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2894:	ef 81       	ldd	r30, Y+7	; 0x07
    2896:	f8 85       	ldd	r31, Y+8	; 0x08
    2898:	20 81       	ld	r18, Z
    289a:	31 81       	ldd	r19, Z+1	; 0x01
    289c:	89 85       	ldd	r24, Y+9	; 0x09
    289e:	9a 85       	ldd	r25, Y+10	; 0x0a
    28a0:	82 0f       	add	r24, r18
    28a2:	93 1f       	adc	r25, r19
    28a4:	9e 83       	std	Y+6, r25	; 0x06
    28a6:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    28a8:	ef 81       	ldd	r30, Y+7	; 0x07
    28aa:	f8 85       	ldd	r31, Y+8	; 0x08
    28ac:	20 81       	ld	r18, Z
    28ae:	31 81       	ldd	r19, Z+1	; 0x01
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	9a 81       	ldd	r25, Y+2	; 0x02
    28b4:	82 17       	cp	r24, r18
    28b6:	93 07       	cpc	r25, r19
    28b8:	98 f4       	brcc	.+38     	; 0x28e0 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    28ba:	ef 81       	ldd	r30, Y+7	; 0x07
    28bc:	f8 85       	ldd	r31, Y+8	; 0x08
    28be:	20 81       	ld	r18, Z
    28c0:	31 81       	ldd	r19, Z+1	; 0x01
    28c2:	8d 81       	ldd	r24, Y+5	; 0x05
    28c4:	9e 81       	ldd	r25, Y+6	; 0x06
    28c6:	82 17       	cp	r24, r18
    28c8:	93 07       	cpc	r25, r19
    28ca:	e0 f4       	brcc	.+56     	; 0x2904 <vTaskDelayUntil+0x9e>
    28cc:	2d 81       	ldd	r18, Y+5	; 0x05
    28ce:	3e 81       	ldd	r19, Y+6	; 0x06
    28d0:	89 81       	ldd	r24, Y+1	; 0x01
    28d2:	9a 81       	ldd	r25, Y+2	; 0x02
    28d4:	82 17       	cp	r24, r18
    28d6:	93 07       	cpc	r25, r19
    28d8:	a8 f4       	brcc	.+42     	; 0x2904 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    28da:	81 e0       	ldi	r24, 0x01	; 1
    28dc:	8b 83       	std	Y+3, r24	; 0x03
    28de:	12 c0       	rjmp	.+36     	; 0x2904 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    28e0:	ef 81       	ldd	r30, Y+7	; 0x07
    28e2:	f8 85       	ldd	r31, Y+8	; 0x08
    28e4:	20 81       	ld	r18, Z
    28e6:	31 81       	ldd	r19, Z+1	; 0x01
    28e8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ea:	9e 81       	ldd	r25, Y+6	; 0x06
    28ec:	82 17       	cp	r24, r18
    28ee:	93 07       	cpc	r25, r19
    28f0:	38 f0       	brcs	.+14     	; 0x2900 <vTaskDelayUntil+0x9a>
    28f2:	2d 81       	ldd	r18, Y+5	; 0x05
    28f4:	3e 81       	ldd	r19, Y+6	; 0x06
    28f6:	89 81       	ldd	r24, Y+1	; 0x01
    28f8:	9a 81       	ldd	r25, Y+2	; 0x02
    28fa:	82 17       	cp	r24, r18
    28fc:	93 07       	cpc	r25, r19
    28fe:	10 f4       	brcc	.+4      	; 0x2904 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2904:	ef 81       	ldd	r30, Y+7	; 0x07
    2906:	f8 85       	ldd	r31, Y+8	; 0x08
    2908:	8d 81       	ldd	r24, Y+5	; 0x05
    290a:	9e 81       	ldd	r25, Y+6	; 0x06
    290c:	91 83       	std	Z+1, r25	; 0x01
    290e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2910:	8b 81       	ldd	r24, Y+3	; 0x03
    2912:	88 23       	and	r24, r24
    2914:	49 f0       	breq	.+18     	; 0x2928 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2916:	8d 81       	ldd	r24, Y+5	; 0x05
    2918:	9e 81       	ldd	r25, Y+6	; 0x06
    291a:	29 81       	ldd	r18, Y+1	; 0x01
    291c:	3a 81       	ldd	r19, Y+2	; 0x02
    291e:	82 1b       	sub	r24, r18
    2920:	93 0b       	sbc	r25, r19
    2922:	60 e0       	ldi	r22, 0x00	; 0
    2924:	0e 94 bb 20 	call	0x4176	; 0x4176 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2928:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    292c:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    292e:	8c 81       	ldd	r24, Y+4	; 0x04
    2930:	88 23       	and	r24, r24
    2932:	11 f4       	brne	.+4      	; 0x2938 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2934:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2938:	2a 96       	adiw	r28, 0x0a	; 10
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	f8 94       	cli
    293e:	de bf       	out	0x3e, r29	; 62
    2940:	0f be       	out	0x3f, r0	; 63
    2942:	cd bf       	out	0x3d, r28	; 61
    2944:	cf 91       	pop	r28
    2946:	df 91       	pop	r29
    2948:	08 95       	ret

0000294a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    294a:	df 93       	push	r29
    294c:	cf 93       	push	r28
    294e:	00 d0       	rcall	.+0      	; 0x2950 <vTaskDelay+0x6>
    2950:	0f 92       	push	r0
    2952:	cd b7       	in	r28, 0x3d	; 61
    2954:	de b7       	in	r29, 0x3e	; 62
    2956:	9b 83       	std	Y+3, r25	; 0x03
    2958:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    295a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    295c:	8a 81       	ldd	r24, Y+2	; 0x02
    295e:	9b 81       	ldd	r25, Y+3	; 0x03
    2960:	00 97       	sbiw	r24, 0x00	; 0
    2962:	51 f0       	breq	.+20     	; 0x2978 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2964:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2968:	8a 81       	ldd	r24, Y+2	; 0x02
    296a:	9b 81       	ldd	r25, Y+3	; 0x03
    296c:	60 e0       	ldi	r22, 0x00	; 0
    296e:	0e 94 bb 20 	call	0x4176	; 0x4176 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2972:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    2976:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2978:	89 81       	ldd	r24, Y+1	; 0x01
    297a:	88 23       	and	r24, r24
    297c:	11 f4       	brne	.+4      	; 0x2982 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    297e:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2982:	0f 90       	pop	r0
    2984:	0f 90       	pop	r0
    2986:	0f 90       	pop	r0
    2988:	cf 91       	pop	r28
    298a:	df 91       	pop	r29
    298c:	08 95       	ret

0000298e <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    298e:	df 93       	push	r29
    2990:	cf 93       	push	r28
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
    2996:	27 97       	sbiw	r28, 0x07	; 7
    2998:	0f b6       	in	r0, 0x3f	; 63
    299a:	f8 94       	cli
    299c:	de bf       	out	0x3e, r29	; 62
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	cd bf       	out	0x3d, r28	; 61
    29a2:	9d 83       	std	Y+5, r25	; 0x05
    29a4:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    29a6:	0f b6       	in	r0, 0x3f	; 63
    29a8:	f8 94       	cli
    29aa:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    29ac:	8c 81       	ldd	r24, Y+4	; 0x04
    29ae:	9d 81       	ldd	r25, Y+5	; 0x05
    29b0:	00 97       	sbiw	r24, 0x00	; 0
    29b2:	39 f4       	brne	.+14     	; 0x29c2 <uxTaskPriorityGet+0x34>
    29b4:	80 91 5a 04 	lds	r24, 0x045A
    29b8:	90 91 5b 04 	lds	r25, 0x045B
    29bc:	9f 83       	std	Y+7, r25	; 0x07
    29be:	8e 83       	std	Y+6, r24	; 0x06
    29c0:	04 c0       	rjmp	.+8      	; 0x29ca <uxTaskPriorityGet+0x3c>
    29c2:	8c 81       	ldd	r24, Y+4	; 0x04
    29c4:	9d 81       	ldd	r25, Y+5	; 0x05
    29c6:	9f 83       	std	Y+7, r25	; 0x07
    29c8:	8e 83       	std	Y+6, r24	; 0x06
    29ca:	8e 81       	ldd	r24, Y+6	; 0x06
    29cc:	9f 81       	ldd	r25, Y+7	; 0x07
    29ce:	9b 83       	std	Y+3, r25	; 0x03
    29d0:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    29d2:	ea 81       	ldd	r30, Y+2	; 0x02
    29d4:	fb 81       	ldd	r31, Y+3	; 0x03
    29d6:	86 89       	ldd	r24, Z+22	; 0x16
    29d8:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    29da:	0f 90       	pop	r0
    29dc:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    29de:	89 81       	ldd	r24, Y+1	; 0x01
	}
    29e0:	27 96       	adiw	r28, 0x07	; 7
    29e2:	0f b6       	in	r0, 0x3f	; 63
    29e4:	f8 94       	cli
    29e6:	de bf       	out	0x3e, r29	; 62
    29e8:	0f be       	out	0x3f, r0	; 63
    29ea:	cd bf       	out	0x3d, r28	; 61
    29ec:	cf 91       	pop	r28
    29ee:	df 91       	pop	r29
    29f0:	08 95       	ret

000029f2 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    29f2:	df 93       	push	r29
    29f4:	cf 93       	push	r28
    29f6:	cd b7       	in	r28, 0x3d	; 61
    29f8:	de b7       	in	r29, 0x3e	; 62
    29fa:	28 97       	sbiw	r28, 0x08	; 8
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	f8 94       	cli
    2a00:	de bf       	out	0x3e, r29	; 62
    2a02:	0f be       	out	0x3f, r0	; 63
    2a04:	cd bf       	out	0x3d, r28	; 61
    2a06:	9e 83       	std	Y+6, r25	; 0x06
    2a08:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    2a0a:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a10:	00 97       	sbiw	r24, 0x00	; 0
    2a12:	39 f4       	brne	.+14     	; 0x2a22 <uxTaskPriorityGetFromISR+0x30>
    2a14:	80 91 5a 04 	lds	r24, 0x045A
    2a18:	90 91 5b 04 	lds	r25, 0x045B
    2a1c:	98 87       	std	Y+8, r25	; 0x08
    2a1e:	8f 83       	std	Y+7, r24	; 0x07
    2a20:	04 c0       	rjmp	.+8      	; 0x2a2a <uxTaskPriorityGetFromISR+0x38>
    2a22:	8d 81       	ldd	r24, Y+5	; 0x05
    2a24:	9e 81       	ldd	r25, Y+6	; 0x06
    2a26:	98 87       	std	Y+8, r25	; 0x08
    2a28:	8f 83       	std	Y+7, r24	; 0x07
    2a2a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a2c:	98 85       	ldd	r25, Y+8	; 0x08
    2a2e:	9c 83       	std	Y+4, r25	; 0x04
    2a30:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    2a32:	eb 81       	ldd	r30, Y+3	; 0x03
    2a34:	fc 81       	ldd	r31, Y+4	; 0x04
    2a36:	86 89       	ldd	r24, Z+22	; 0x16
    2a38:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    2a3a:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    2a3c:	28 96       	adiw	r28, 0x08	; 8
    2a3e:	0f b6       	in	r0, 0x3f	; 63
    2a40:	f8 94       	cli
    2a42:	de bf       	out	0x3e, r29	; 62
    2a44:	0f be       	out	0x3f, r0	; 63
    2a46:	cd bf       	out	0x3d, r28	; 61
    2a48:	cf 91       	pop	r28
    2a4a:	df 91       	pop	r29
    2a4c:	08 95       	ret

00002a4e <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    2a4e:	df 93       	push	r29
    2a50:	cf 93       	push	r28
    2a52:	cd b7       	in	r28, 0x3d	; 61
    2a54:	de b7       	in	r29, 0x3e	; 62
    2a56:	2a 97       	sbiw	r28, 0x0a	; 10
    2a58:	0f b6       	in	r0, 0x3f	; 63
    2a5a:	f8 94       	cli
    2a5c:	de bf       	out	0x3e, r29	; 62
    2a5e:	0f be       	out	0x3f, r0	; 63
    2a60:	cd bf       	out	0x3d, r28	; 61
    2a62:	9f 83       	std	Y+7, r25	; 0x07
    2a64:	8e 83       	std	Y+6, r24	; 0x06
    2a66:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    2a68:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2a6a:	88 85       	ldd	r24, Y+8	; 0x08
    2a6c:	85 30       	cpi	r24, 0x05	; 5
    2a6e:	10 f0       	brcs	.+4      	; 0x2a74 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2a70:	84 e0       	ldi	r24, 0x04	; 4
    2a72:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    2a74:	0f b6       	in	r0, 0x3f	; 63
    2a76:	f8 94       	cli
    2a78:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2a7a:	8e 81       	ldd	r24, Y+6	; 0x06
    2a7c:	9f 81       	ldd	r25, Y+7	; 0x07
    2a7e:	00 97       	sbiw	r24, 0x00	; 0
    2a80:	39 f4       	brne	.+14     	; 0x2a90 <vTaskPrioritySet+0x42>
    2a82:	80 91 5a 04 	lds	r24, 0x045A
    2a86:	90 91 5b 04 	lds	r25, 0x045B
    2a8a:	9a 87       	std	Y+10, r25	; 0x0a
    2a8c:	89 87       	std	Y+9, r24	; 0x09
    2a8e:	04 c0       	rjmp	.+8      	; 0x2a98 <vTaskPrioritySet+0x4a>
    2a90:	8e 81       	ldd	r24, Y+6	; 0x06
    2a92:	9f 81       	ldd	r25, Y+7	; 0x07
    2a94:	9a 87       	std	Y+10, r25	; 0x0a
    2a96:	89 87       	std	Y+9, r24	; 0x09
    2a98:	89 85       	ldd	r24, Y+9	; 0x09
    2a9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a9c:	9d 83       	std	Y+5, r25	; 0x05
    2a9e:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    2aa0:	ec 81       	ldd	r30, Y+4	; 0x04
    2aa2:	fd 81       	ldd	r31, Y+5	; 0x05
    2aa4:	86 89       	ldd	r24, Z+22	; 0x16
    2aa6:	8b 83       	std	Y+3, r24	; 0x03
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    2aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    2aaa:	88 85       	ldd	r24, Y+8	; 0x08
    2aac:	98 17       	cp	r25, r24
    2aae:	09 f4       	brne	.+2      	; 0x2ab2 <vTaskPrioritySet+0x64>
    2ab0:	81 c0       	rjmp	.+258    	; 0x2bb4 <vTaskPrioritySet+0x166>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    2ab2:	98 85       	ldd	r25, Y+8	; 0x08
    2ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab6:	89 17       	cp	r24, r25
    2ab8:	a0 f4       	brcc	.+40     	; 0x2ae2 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    2aba:	20 91 5a 04 	lds	r18, 0x045A
    2abe:	30 91 5b 04 	lds	r19, 0x045B
    2ac2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ac4:	9d 81       	ldd	r25, Y+5	; 0x05
    2ac6:	82 17       	cp	r24, r18
    2ac8:	93 07       	cpc	r25, r19
    2aca:	b1 f0       	breq	.+44     	; 0x2af8 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    2acc:	e0 91 5a 04 	lds	r30, 0x045A
    2ad0:	f0 91 5b 04 	lds	r31, 0x045B
    2ad4:	96 89       	ldd	r25, Z+22	; 0x16
    2ad6:	88 85       	ldd	r24, Y+8	; 0x08
    2ad8:	89 17       	cp	r24, r25
    2ada:	70 f0       	brcs	.+28     	; 0x2af8 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    2adc:	81 e0       	ldi	r24, 0x01	; 1
    2ade:	89 83       	std	Y+1, r24	; 0x01
    2ae0:	0b c0       	rjmp	.+22     	; 0x2af8 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    2ae2:	20 91 5a 04 	lds	r18, 0x045A
    2ae6:	30 91 5b 04 	lds	r19, 0x045B
    2aea:	8c 81       	ldd	r24, Y+4	; 0x04
    2aec:	9d 81       	ldd	r25, Y+5	; 0x05
    2aee:	82 17       	cp	r24, r18
    2af0:	93 07       	cpc	r25, r19
    2af2:	11 f4       	brne	.+4      	; 0x2af8 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    2af4:	81 e0       	ldi	r24, 0x01	; 1
    2af6:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    2af8:	ec 81       	ldd	r30, Y+4	; 0x04
    2afa:	fd 81       	ldd	r31, Y+5	; 0x05
    2afc:	86 89       	ldd	r24, Z+22	; 0x16
    2afe:	8a 83       	std	Y+2, r24	; 0x02
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    2b00:	ec 81       	ldd	r30, Y+4	; 0x04
    2b02:	fd 81       	ldd	r31, Y+5	; 0x05
    2b04:	88 85       	ldd	r24, Y+8	; 0x08
    2b06:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2b08:	ec 81       	ldd	r30, Y+4	; 0x04
    2b0a:	fd 81       	ldd	r31, Y+5	; 0x05
    2b0c:	84 85       	ldd	r24, Z+12	; 0x0c
    2b0e:	95 85       	ldd	r25, Z+13	; 0x0d
    2b10:	99 23       	and	r25, r25
    2b12:	5c f0       	brlt	.+22     	; 0x2b2a <vTaskPrioritySet+0xdc>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2b14:	88 85       	ldd	r24, Y+8	; 0x08
    2b16:	28 2f       	mov	r18, r24
    2b18:	30 e0       	ldi	r19, 0x00	; 0
    2b1a:	85 e0       	ldi	r24, 0x05	; 5
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	82 1b       	sub	r24, r18
    2b20:	93 0b       	sbc	r25, r19
    2b22:	ec 81       	ldd	r30, Y+4	; 0x04
    2b24:	fd 81       	ldd	r31, Y+5	; 0x05
    2b26:	95 87       	std	Z+13, r25	; 0x0d
    2b28:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2b2a:	ec 81       	ldd	r30, Y+4	; 0x04
    2b2c:	fd 81       	ldd	r31, Y+5	; 0x05
    2b2e:	42 85       	ldd	r20, Z+10	; 0x0a
    2b30:	53 85       	ldd	r21, Z+11	; 0x0b
    2b32:	8a 81       	ldd	r24, Y+2	; 0x02
    2b34:	28 2f       	mov	r18, r24
    2b36:	30 e0       	ldi	r19, 0x00	; 0
    2b38:	c9 01       	movw	r24, r18
    2b3a:	88 0f       	add	r24, r24
    2b3c:	99 1f       	adc	r25, r25
    2b3e:	88 0f       	add	r24, r24
    2b40:	99 1f       	adc	r25, r25
    2b42:	88 0f       	add	r24, r24
    2b44:	99 1f       	adc	r25, r25
    2b46:	82 0f       	add	r24, r18
    2b48:	93 1f       	adc	r25, r19
    2b4a:	84 59       	subi	r24, 0x94	; 148
    2b4c:	9b 4f       	sbci	r25, 0xFB	; 251
    2b4e:	48 17       	cp	r20, r24
    2b50:	59 07       	cpc	r21, r25
    2b52:	59 f5       	brne	.+86     	; 0x2baa <vTaskPrioritySet+0x15c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2b54:	8c 81       	ldd	r24, Y+4	; 0x04
    2b56:	9d 81       	ldd	r25, Y+5	; 0x05
    2b58:	02 96       	adiw	r24, 0x02	; 2
    2b5a:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    2b5e:	ec 81       	ldd	r30, Y+4	; 0x04
    2b60:	fd 81       	ldd	r31, Y+5	; 0x05
    2b62:	96 89       	ldd	r25, Z+22	; 0x16
    2b64:	80 91 60 04 	lds	r24, 0x0460
    2b68:	89 17       	cp	r24, r25
    2b6a:	28 f4       	brcc	.+10     	; 0x2b76 <vTaskPrioritySet+0x128>
    2b6c:	ec 81       	ldd	r30, Y+4	; 0x04
    2b6e:	fd 81       	ldd	r31, Y+5	; 0x05
    2b70:	86 89       	ldd	r24, Z+22	; 0x16
    2b72:	80 93 60 04 	sts	0x0460, r24
    2b76:	ec 81       	ldd	r30, Y+4	; 0x04
    2b78:	fd 81       	ldd	r31, Y+5	; 0x05
    2b7a:	86 89       	ldd	r24, Z+22	; 0x16
    2b7c:	28 2f       	mov	r18, r24
    2b7e:	30 e0       	ldi	r19, 0x00	; 0
    2b80:	c9 01       	movw	r24, r18
    2b82:	88 0f       	add	r24, r24
    2b84:	99 1f       	adc	r25, r25
    2b86:	88 0f       	add	r24, r24
    2b88:	99 1f       	adc	r25, r25
    2b8a:	88 0f       	add	r24, r24
    2b8c:	99 1f       	adc	r25, r25
    2b8e:	82 0f       	add	r24, r18
    2b90:	93 1f       	adc	r25, r19
    2b92:	ac 01       	movw	r20, r24
    2b94:	44 59       	subi	r20, 0x94	; 148
    2b96:	5b 4f       	sbci	r21, 0xFB	; 251
    2b98:	8c 81       	ldd	r24, Y+4	; 0x04
    2b9a:	9d 81       	ldd	r25, Y+5	; 0x05
    2b9c:	9c 01       	movw	r18, r24
    2b9e:	2e 5f       	subi	r18, 0xFE	; 254
    2ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ba2:	ca 01       	movw	r24, r20
    2ba4:	b9 01       	movw	r22, r18
    2ba6:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    2baa:	89 81       	ldd	r24, Y+1	; 0x01
    2bac:	88 23       	and	r24, r24
    2bae:	11 f0       	breq	.+4      	; 0x2bb4 <vTaskPrioritySet+0x166>
				{
					taskYIELD_IF_USING_PREEMPTION();
    2bb0:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    2bb4:	0f 90       	pop	r0
    2bb6:	0f be       	out	0x3f, r0	; 63
	}
    2bb8:	2a 96       	adiw	r28, 0x0a	; 10
    2bba:	0f b6       	in	r0, 0x3f	; 63
    2bbc:	f8 94       	cli
    2bbe:	de bf       	out	0x3e, r29	; 62
    2bc0:	0f be       	out	0x3f, r0	; 63
    2bc2:	cd bf       	out	0x3d, r28	; 61
    2bc4:	cf 91       	pop	r28
    2bc6:	df 91       	pop	r29
    2bc8:	08 95       	ret

00002bca <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2bca:	df 93       	push	r29
    2bcc:	cf 93       	push	r28
    2bce:	00 d0       	rcall	.+0      	; 0x2bd0 <vTaskSuspend+0x6>
    2bd0:	00 d0       	rcall	.+0      	; 0x2bd2 <vTaskSuspend+0x8>
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <vTaskSuspend+0xa>
    2bd4:	cd b7       	in	r28, 0x3d	; 61
    2bd6:	de b7       	in	r29, 0x3e	; 62
    2bd8:	9c 83       	std	Y+4, r25	; 0x04
    2bda:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    2be2:	8b 81       	ldd	r24, Y+3	; 0x03
    2be4:	9c 81       	ldd	r25, Y+4	; 0x04
    2be6:	00 97       	sbiw	r24, 0x00	; 0
    2be8:	39 f4       	brne	.+14     	; 0x2bf8 <vTaskSuspend+0x2e>
    2bea:	80 91 5a 04 	lds	r24, 0x045A
    2bee:	90 91 5b 04 	lds	r25, 0x045B
    2bf2:	9e 83       	std	Y+6, r25	; 0x06
    2bf4:	8d 83       	std	Y+5, r24	; 0x05
    2bf6:	04 c0       	rjmp	.+8      	; 0x2c00 <vTaskSuspend+0x36>
    2bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfc:	9e 83       	std	Y+6, r25	; 0x06
    2bfe:	8d 83       	std	Y+5, r24	; 0x05
    2c00:	8d 81       	ldd	r24, Y+5	; 0x05
    2c02:	9e 81       	ldd	r25, Y+6	; 0x06
    2c04:	9a 83       	std	Y+2, r25	; 0x02
    2c06:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2c08:	89 81       	ldd	r24, Y+1	; 0x01
    2c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c0c:	02 96       	adiw	r24, 0x02	; 2
    2c0e:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2c12:	e9 81       	ldd	r30, Y+1	; 0x01
    2c14:	fa 81       	ldd	r31, Y+2	; 0x02
    2c16:	84 89       	ldd	r24, Z+20	; 0x14
    2c18:	95 89       	ldd	r25, Z+21	; 0x15
    2c1a:	00 97       	sbiw	r24, 0x00	; 0
    2c1c:	29 f0       	breq	.+10     	; 0x2c28 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c1e:	89 81       	ldd	r24, Y+1	; 0x01
    2c20:	9a 81       	ldd	r25, Y+2	; 0x02
    2c22:	0c 96       	adiw	r24, 0x0c	; 12
    2c24:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    2c28:	89 81       	ldd	r24, Y+1	; 0x01
    2c2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c2c:	9c 01       	movw	r18, r24
    2c2e:	2e 5f       	subi	r18, 0xFE	; 254
    2c30:	3f 4f       	sbci	r19, 0xFF	; 255
    2c32:	81 ec       	ldi	r24, 0xC1	; 193
    2c34:	94 e0       	ldi	r25, 0x04	; 4
    2c36:	b9 01       	movw	r22, r18
    2c38:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2c3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c40:	85 a1       	ldd	r24, Z+37	; 0x25
    2c42:	81 30       	cpi	r24, 0x01	; 1
    2c44:	19 f4       	brne	.+6      	; 0x2c4c <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2c46:	e9 81       	ldd	r30, Y+1	; 0x01
    2c48:	fa 81       	ldd	r31, Y+2	; 0x02
    2c4a:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    2c4c:	0f 90       	pop	r0
    2c4e:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    2c50:	80 91 61 04 	lds	r24, 0x0461
    2c54:	88 23       	and	r24, r24
    2c56:	39 f0       	breq	.+14     	; 0x2c66 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    2c58:	0f b6       	in	r0, 0x3f	; 63
    2c5a:	f8 94       	cli
    2c5c:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    2c5e:	0e 94 66 1c 	call	0x38cc	; 0x38cc <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    2c62:	0f 90       	pop	r0
    2c64:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    2c66:	20 91 5a 04 	lds	r18, 0x045A
    2c6a:	30 91 5b 04 	lds	r19, 0x045B
    2c6e:	89 81       	ldd	r24, Y+1	; 0x01
    2c70:	9a 81       	ldd	r25, Y+2	; 0x02
    2c72:	82 17       	cp	r24, r18
    2c74:	93 07       	cpc	r25, r19
    2c76:	a1 f4       	brne	.+40     	; 0x2ca0 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    2c78:	80 91 61 04 	lds	r24, 0x0461
    2c7c:	88 23       	and	r24, r24
    2c7e:	19 f0       	breq	.+6      	; 0x2c86 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2c80:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
    2c84:	0d c0       	rjmp	.+26     	; 0x2ca0 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    2c86:	90 91 c1 04 	lds	r25, 0x04C1
    2c8a:	80 91 5d 04 	lds	r24, 0x045D
    2c8e:	98 17       	cp	r25, r24
    2c90:	29 f4       	brne	.+10     	; 0x2c9c <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2c92:	10 92 5b 04 	sts	0x045B, r1
    2c96:	10 92 5a 04 	sts	0x045A, r1
    2c9a:	02 c0       	rjmp	.+4      	; 0x2ca0 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    2c9c:	0e 94 a1 19 	call	0x3342	; 0x3342 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2ca0:	26 96       	adiw	r28, 0x06	; 6
    2ca2:	0f b6       	in	r0, 0x3f	; 63
    2ca4:	f8 94       	cli
    2ca6:	de bf       	out	0x3e, r29	; 62
    2ca8:	0f be       	out	0x3f, r0	; 63
    2caa:	cd bf       	out	0x3d, r28	; 61
    2cac:	cf 91       	pop	r28
    2cae:	df 91       	pop	r29
    2cb0:	08 95       	ret

00002cb2 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    2cb2:	df 93       	push	r29
    2cb4:	cf 93       	push	r28
    2cb6:	00 d0       	rcall	.+0      	; 0x2cb8 <prvTaskIsTaskSuspended+0x6>
    2cb8:	00 d0       	rcall	.+0      	; 0x2cba <prvTaskIsTaskSuspended+0x8>
    2cba:	0f 92       	push	r0
    2cbc:	cd b7       	in	r28, 0x3d	; 61
    2cbe:	de b7       	in	r29, 0x3e	; 62
    2cc0:	9d 83       	std	Y+5, r25	; 0x05
    2cc2:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    2cc4:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    2cc6:	8c 81       	ldd	r24, Y+4	; 0x04
    2cc8:	9d 81       	ldd	r25, Y+5	; 0x05
    2cca:	9a 83       	std	Y+2, r25	; 0x02
    2ccc:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    2cce:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2cd2:	82 85       	ldd	r24, Z+10	; 0x0a
    2cd4:	93 85       	ldd	r25, Z+11	; 0x0b
    2cd6:	24 e0       	ldi	r18, 0x04	; 4
    2cd8:	81 3c       	cpi	r24, 0xC1	; 193
    2cda:	92 07       	cpc	r25, r18
    2cdc:	81 f4       	brne	.+32     	; 0x2cfe <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    2cde:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce2:	84 89       	ldd	r24, Z+20	; 0x14
    2ce4:	95 89       	ldd	r25, Z+21	; 0x15
    2ce6:	24 e0       	ldi	r18, 0x04	; 4
    2ce8:	8f 3a       	cpi	r24, 0xAF	; 175
    2cea:	92 07       	cpc	r25, r18
    2cec:	41 f0       	breq	.+16     	; 0x2cfe <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    2cee:	e9 81       	ldd	r30, Y+1	; 0x01
    2cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    2cf2:	84 89       	ldd	r24, Z+20	; 0x14
    2cf4:	95 89       	ldd	r25, Z+21	; 0x15
    2cf6:	00 97       	sbiw	r24, 0x00	; 0
    2cf8:	11 f4       	brne	.+4      	; 0x2cfe <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
    2cfc:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    2d00:	0f 90       	pop	r0
    2d02:	0f 90       	pop	r0
    2d04:	0f 90       	pop	r0
    2d06:	0f 90       	pop	r0
    2d08:	0f 90       	pop	r0
    2d0a:	cf 91       	pop	r28
    2d0c:	df 91       	pop	r29
    2d0e:	08 95       	ret

00002d10 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    2d10:	df 93       	push	r29
    2d12:	cf 93       	push	r28
    2d14:	00 d0       	rcall	.+0      	; 0x2d16 <vTaskResume+0x6>
    2d16:	00 d0       	rcall	.+0      	; 0x2d18 <vTaskResume+0x8>
    2d18:	cd b7       	in	r28, 0x3d	; 61
    2d1a:	de b7       	in	r29, 0x3e	; 62
    2d1c:	9c 83       	std	Y+4, r25	; 0x04
    2d1e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    2d20:	8b 81       	ldd	r24, Y+3	; 0x03
    2d22:	9c 81       	ldd	r25, Y+4	; 0x04
    2d24:	9a 83       	std	Y+2, r25	; 0x02
    2d26:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    2d28:	20 91 5a 04 	lds	r18, 0x045A
    2d2c:	30 91 5b 04 	lds	r19, 0x045B
    2d30:	89 81       	ldd	r24, Y+1	; 0x01
    2d32:	9a 81       	ldd	r25, Y+2	; 0x02
    2d34:	82 17       	cp	r24, r18
    2d36:	93 07       	cpc	r25, r19
    2d38:	09 f4       	brne	.+2      	; 0x2d3c <vTaskResume+0x2c>
    2d3a:	47 c0       	rjmp	.+142    	; 0x2dca <vTaskResume+0xba>
    2d3c:	89 81       	ldd	r24, Y+1	; 0x01
    2d3e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d40:	00 97       	sbiw	r24, 0x00	; 0
    2d42:	09 f4       	brne	.+2      	; 0x2d46 <vTaskResume+0x36>
    2d44:	42 c0       	rjmp	.+132    	; 0x2dca <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    2d46:	0f b6       	in	r0, 0x3f	; 63
    2d48:	f8 94       	cli
    2d4a:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2d4c:	89 81       	ldd	r24, Y+1	; 0x01
    2d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d50:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <prvTaskIsTaskSuspended>
    2d54:	88 23       	and	r24, r24
    2d56:	b9 f1       	breq	.+110    	; 0x2dc6 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    2d58:	89 81       	ldd	r24, Y+1	; 0x01
    2d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d5c:	02 96       	adiw	r24, 0x02	; 2
    2d5e:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2d62:	e9 81       	ldd	r30, Y+1	; 0x01
    2d64:	fa 81       	ldd	r31, Y+2	; 0x02
    2d66:	96 89       	ldd	r25, Z+22	; 0x16
    2d68:	80 91 60 04 	lds	r24, 0x0460
    2d6c:	89 17       	cp	r24, r25
    2d6e:	28 f4       	brcc	.+10     	; 0x2d7a <vTaskResume+0x6a>
    2d70:	e9 81       	ldd	r30, Y+1	; 0x01
    2d72:	fa 81       	ldd	r31, Y+2	; 0x02
    2d74:	86 89       	ldd	r24, Z+22	; 0x16
    2d76:	80 93 60 04 	sts	0x0460, r24
    2d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7e:	86 89       	ldd	r24, Z+22	; 0x16
    2d80:	28 2f       	mov	r18, r24
    2d82:	30 e0       	ldi	r19, 0x00	; 0
    2d84:	c9 01       	movw	r24, r18
    2d86:	88 0f       	add	r24, r24
    2d88:	99 1f       	adc	r25, r25
    2d8a:	88 0f       	add	r24, r24
    2d8c:	99 1f       	adc	r25, r25
    2d8e:	88 0f       	add	r24, r24
    2d90:	99 1f       	adc	r25, r25
    2d92:	82 0f       	add	r24, r18
    2d94:	93 1f       	adc	r25, r19
    2d96:	ac 01       	movw	r20, r24
    2d98:	44 59       	subi	r20, 0x94	; 148
    2d9a:	5b 4f       	sbci	r21, 0xFB	; 251
    2d9c:	89 81       	ldd	r24, Y+1	; 0x01
    2d9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2da0:	9c 01       	movw	r18, r24
    2da2:	2e 5f       	subi	r18, 0xFE	; 254
    2da4:	3f 4f       	sbci	r19, 0xFF	; 255
    2da6:	ca 01       	movw	r24, r20
    2da8:	b9 01       	movw	r22, r18
    2daa:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2dae:	e9 81       	ldd	r30, Y+1	; 0x01
    2db0:	fa 81       	ldd	r31, Y+2	; 0x02
    2db2:	96 89       	ldd	r25, Z+22	; 0x16
    2db4:	e0 91 5a 04 	lds	r30, 0x045A
    2db8:	f0 91 5b 04 	lds	r31, 0x045B
    2dbc:	86 89       	ldd	r24, Z+22	; 0x16
    2dbe:	98 17       	cp	r25, r24
    2dc0:	10 f0       	brcs	.+4      	; 0x2dc6 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    2dc2:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2dc6:	0f 90       	pop	r0
    2dc8:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	0f 90       	pop	r0
    2dd0:	0f 90       	pop	r0
    2dd2:	cf 91       	pop	r28
    2dd4:	df 91       	pop	r29
    2dd6:	08 95       	ret

00002dd8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    2dd8:	df 93       	push	r29
    2dda:	cf 93       	push	r28
    2ddc:	00 d0       	rcall	.+0      	; 0x2dde <xTaskResumeFromISR+0x6>
    2dde:	00 d0       	rcall	.+0      	; 0x2de0 <xTaskResumeFromISR+0x8>
    2de0:	00 d0       	rcall	.+0      	; 0x2de2 <xTaskResumeFromISR+0xa>
    2de2:	cd b7       	in	r28, 0x3d	; 61
    2de4:	de b7       	in	r29, 0x3e	; 62
    2de6:	9e 83       	std	Y+6, r25	; 0x06
    2de8:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    2dea:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    2dec:	8d 81       	ldd	r24, Y+5	; 0x05
    2dee:	9e 81       	ldd	r25, Y+6	; 0x06
    2df0:	9b 83       	std	Y+3, r25	; 0x03
    2df2:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2df4:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2df6:	8a 81       	ldd	r24, Y+2	; 0x02
    2df8:	9b 81       	ldd	r25, Y+3	; 0x03
    2dfa:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <prvTaskIsTaskSuspended>
    2dfe:	88 23       	and	r24, r24
    2e00:	09 f4       	brne	.+2      	; 0x2e04 <xTaskResumeFromISR+0x2c>
    2e02:	46 c0       	rjmp	.+140    	; 0x2e90 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2e04:	80 91 6b 04 	lds	r24, 0x046B
    2e08:	88 23       	and	r24, r24
    2e0a:	c1 f5       	brne	.+112    	; 0x2e7c <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2e0c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e0e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e10:	96 89       	ldd	r25, Z+22	; 0x16
    2e12:	e0 91 5a 04 	lds	r30, 0x045A
    2e16:	f0 91 5b 04 	lds	r31, 0x045B
    2e1a:	86 89       	ldd	r24, Z+22	; 0x16
    2e1c:	98 17       	cp	r25, r24
    2e1e:	10 f0       	brcs	.+4      	; 0x2e24 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    2e20:	81 e0       	ldi	r24, 0x01	; 1
    2e22:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2e24:	8a 81       	ldd	r24, Y+2	; 0x02
    2e26:	9b 81       	ldd	r25, Y+3	; 0x03
    2e28:	02 96       	adiw	r24, 0x02	; 2
    2e2a:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2e2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e30:	fb 81       	ldd	r31, Y+3	; 0x03
    2e32:	96 89       	ldd	r25, Z+22	; 0x16
    2e34:	80 91 60 04 	lds	r24, 0x0460
    2e38:	89 17       	cp	r24, r25
    2e3a:	28 f4       	brcc	.+10     	; 0x2e46 <xTaskResumeFromISR+0x6e>
    2e3c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e3e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e40:	86 89       	ldd	r24, Z+22	; 0x16
    2e42:	80 93 60 04 	sts	0x0460, r24
    2e46:	ea 81       	ldd	r30, Y+2	; 0x02
    2e48:	fb 81       	ldd	r31, Y+3	; 0x03
    2e4a:	86 89       	ldd	r24, Z+22	; 0x16
    2e4c:	28 2f       	mov	r18, r24
    2e4e:	30 e0       	ldi	r19, 0x00	; 0
    2e50:	c9 01       	movw	r24, r18
    2e52:	88 0f       	add	r24, r24
    2e54:	99 1f       	adc	r25, r25
    2e56:	88 0f       	add	r24, r24
    2e58:	99 1f       	adc	r25, r25
    2e5a:	88 0f       	add	r24, r24
    2e5c:	99 1f       	adc	r25, r25
    2e5e:	82 0f       	add	r24, r18
    2e60:	93 1f       	adc	r25, r19
    2e62:	ac 01       	movw	r20, r24
    2e64:	44 59       	subi	r20, 0x94	; 148
    2e66:	5b 4f       	sbci	r21, 0xFB	; 251
    2e68:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2e6c:	9c 01       	movw	r18, r24
    2e6e:	2e 5f       	subi	r18, 0xFE	; 254
    2e70:	3f 4f       	sbci	r19, 0xFF	; 255
    2e72:	ca 01       	movw	r24, r20
    2e74:	b9 01       	movw	r22, r18
    2e76:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
    2e7a:	0a c0       	rjmp	.+20     	; 0x2e90 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e80:	9c 01       	movw	r18, r24
    2e82:	24 5f       	subi	r18, 0xF4	; 244
    2e84:	3f 4f       	sbci	r19, 0xFF	; 255
    2e86:	8f ea       	ldi	r24, 0xAF	; 175
    2e88:	94 e0       	ldi	r25, 0x04	; 4
    2e8a:	b9 01       	movw	r22, r18
    2e8c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    2e90:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    2e92:	26 96       	adiw	r28, 0x06	; 6
    2e94:	0f b6       	in	r0, 0x3f	; 63
    2e96:	f8 94       	cli
    2e98:	de bf       	out	0x3e, r29	; 62
    2e9a:	0f be       	out	0x3f, r0	; 63
    2e9c:	cd bf       	out	0x3d, r28	; 61
    2e9e:	cf 91       	pop	r28
    2ea0:	df 91       	pop	r29
    2ea2:	08 95       	ret

00002ea4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2ea4:	ef 92       	push	r14
    2ea6:	ff 92       	push	r15
    2ea8:	0f 93       	push	r16
    2eaa:	df 93       	push	r29
    2eac:	cf 93       	push	r28
    2eae:	0f 92       	push	r0
    2eb0:	cd b7       	in	r28, 0x3d	; 61
    2eb2:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2eb4:	86 ed       	ldi	r24, 0xD6	; 214
    2eb6:	9b e1       	ldi	r25, 0x1B	; 27
    2eb8:	20 e6       	ldi	r18, 0x60	; 96
    2eba:	30 e0       	ldi	r19, 0x00	; 0
    2ebc:	e9 e6       	ldi	r30, 0x69	; 105
    2ebe:	f4 e0       	ldi	r31, 0x04	; 4
    2ec0:	b9 01       	movw	r22, r18
    2ec2:	4a ef       	ldi	r20, 0xFA	; 250
    2ec4:	50 e0       	ldi	r21, 0x00	; 0
    2ec6:	20 e0       	ldi	r18, 0x00	; 0
    2ec8:	30 e0       	ldi	r19, 0x00	; 0
    2eca:	00 e0       	ldi	r16, 0x00	; 0
    2ecc:	7f 01       	movw	r14, r30
    2ece:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskCreate>
    2ed2:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2ed4:	89 81       	ldd	r24, Y+1	; 0x01
    2ed6:	81 30       	cpi	r24, 0x01	; 1
    2ed8:	81 f4       	brne	.+32     	; 0x2efa <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2eda:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2edc:	8f ef       	ldi	r24, 0xFF	; 255
    2ede:	9f ef       	ldi	r25, 0xFF	; 255
    2ee0:	90 93 68 04 	sts	0x0468, r25
    2ee4:	80 93 67 04 	sts	0x0467, r24
		xSchedulerRunning = pdTRUE;
    2ee8:	81 e0       	ldi	r24, 0x01	; 1
    2eea:	80 93 61 04 	sts	0x0461, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2eee:	10 92 5f 04 	sts	0x045F, r1
    2ef2:	10 92 5e 04 	sts	0x045E, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2ef6:	0e 94 84 09 	call	0x1308	; 0x1308 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2efa:	0f 90       	pop	r0
    2efc:	cf 91       	pop	r28
    2efe:	df 91       	pop	r29
    2f00:	0f 91       	pop	r16
    2f02:	ff 90       	pop	r15
    2f04:	ef 90       	pop	r14
    2f06:	08 95       	ret

00002f08 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2f08:	df 93       	push	r29
    2f0a:	cf 93       	push	r28
    2f0c:	cd b7       	in	r28, 0x3d	; 61
    2f0e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2f10:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2f12:	10 92 61 04 	sts	0x0461, r1
	vPortEndScheduler();
    2f16:	0e 94 b9 09 	call	0x1372	; 0x1372 <vPortEndScheduler>
}
    2f1a:	cf 91       	pop	r28
    2f1c:	df 91       	pop	r29
    2f1e:	08 95       	ret

00002f20 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2f20:	df 93       	push	r29
    2f22:	cf 93       	push	r28
    2f24:	cd b7       	in	r28, 0x3d	; 61
    2f26:	de b7       	in	r29, 0x3e	; 62
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
    2f28:	80 91 6b 04 	lds	r24, 0x046B
    2f2c:	8f 5f       	subi	r24, 0xFF	; 255
    2f2e:	80 93 6b 04 	sts	0x046B, r24

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
    2f32:	cf 91       	pop	r28
    2f34:	df 91       	pop	r29
    2f36:	08 95       	ret

00002f38 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2f38:	df 93       	push	r29
    2f3a:	cf 93       	push	r28
    2f3c:	00 d0       	rcall	.+0      	; 0x2f3e <xTaskResumeAll+0x6>
    2f3e:	00 d0       	rcall	.+0      	; 0x2f40 <xTaskResumeAll+0x8>
    2f40:	0f 92       	push	r0
    2f42:	cd b7       	in	r28, 0x3d	; 61
    2f44:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    2f46:	1d 82       	std	Y+5, r1	; 0x05
    2f48:	1c 82       	std	Y+4, r1	; 0x04
BaseType_t xAlreadyYielded = pdFALSE;
    2f4a:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2f4c:	0f b6       	in	r0, 0x3f	; 63
    2f4e:	f8 94       	cli
    2f50:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2f52:	80 91 6b 04 	lds	r24, 0x046B
    2f56:	81 50       	subi	r24, 0x01	; 1
    2f58:	80 93 6b 04 	sts	0x046B, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f5c:	80 91 6b 04 	lds	r24, 0x046B
    2f60:	88 23       	and	r24, r24
    2f62:	09 f0       	breq	.+2      	; 0x2f66 <xTaskResumeAll+0x2e>
    2f64:	7c c0       	rjmp	.+248    	; 0x305e <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2f66:	80 91 5d 04 	lds	r24, 0x045D
    2f6a:	88 23       	and	r24, r24
    2f6c:	09 f4       	brne	.+2      	; 0x2f70 <xTaskResumeAll+0x38>
    2f6e:	77 c0       	rjmp	.+238    	; 0x305e <xTaskResumeAll+0x126>
    2f70:	45 c0       	rjmp	.+138    	; 0x2ffc <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f72:	e0 91 b4 04 	lds	r30, 0x04B4
    2f76:	f0 91 b5 04 	lds	r31, 0x04B5
    2f7a:	86 81       	ldd	r24, Z+6	; 0x06
    2f7c:	97 81       	ldd	r25, Z+7	; 0x07
    2f7e:	9d 83       	std	Y+5, r25	; 0x05
    2f80:	8c 83       	std	Y+4, r24	; 0x04
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2f82:	8c 81       	ldd	r24, Y+4	; 0x04
    2f84:	9d 81       	ldd	r25, Y+5	; 0x05
    2f86:	0c 96       	adiw	r24, 0x0c	; 12
    2f88:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2f8c:	8c 81       	ldd	r24, Y+4	; 0x04
    2f8e:	9d 81       	ldd	r25, Y+5	; 0x05
    2f90:	02 96       	adiw	r24, 0x02	; 2
    2f92:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2f96:	ec 81       	ldd	r30, Y+4	; 0x04
    2f98:	fd 81       	ldd	r31, Y+5	; 0x05
    2f9a:	96 89       	ldd	r25, Z+22	; 0x16
    2f9c:	80 91 60 04 	lds	r24, 0x0460
    2fa0:	89 17       	cp	r24, r25
    2fa2:	28 f4       	brcc	.+10     	; 0x2fae <xTaskResumeAll+0x76>
    2fa4:	ec 81       	ldd	r30, Y+4	; 0x04
    2fa6:	fd 81       	ldd	r31, Y+5	; 0x05
    2fa8:	86 89       	ldd	r24, Z+22	; 0x16
    2faa:	80 93 60 04 	sts	0x0460, r24
    2fae:	ec 81       	ldd	r30, Y+4	; 0x04
    2fb0:	fd 81       	ldd	r31, Y+5	; 0x05
    2fb2:	86 89       	ldd	r24, Z+22	; 0x16
    2fb4:	28 2f       	mov	r18, r24
    2fb6:	30 e0       	ldi	r19, 0x00	; 0
    2fb8:	c9 01       	movw	r24, r18
    2fba:	88 0f       	add	r24, r24
    2fbc:	99 1f       	adc	r25, r25
    2fbe:	88 0f       	add	r24, r24
    2fc0:	99 1f       	adc	r25, r25
    2fc2:	88 0f       	add	r24, r24
    2fc4:	99 1f       	adc	r25, r25
    2fc6:	82 0f       	add	r24, r18
    2fc8:	93 1f       	adc	r25, r19
    2fca:	ac 01       	movw	r20, r24
    2fcc:	44 59       	subi	r20, 0x94	; 148
    2fce:	5b 4f       	sbci	r21, 0xFB	; 251
    2fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    2fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    2fd4:	9c 01       	movw	r18, r24
    2fd6:	2e 5f       	subi	r18, 0xFE	; 254
    2fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    2fda:	ca 01       	movw	r24, r20
    2fdc:	b9 01       	movw	r22, r18
    2fde:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2fe2:	ec 81       	ldd	r30, Y+4	; 0x04
    2fe4:	fd 81       	ldd	r31, Y+5	; 0x05
    2fe6:	96 89       	ldd	r25, Z+22	; 0x16
    2fe8:	e0 91 5a 04 	lds	r30, 0x045A
    2fec:	f0 91 5b 04 	lds	r31, 0x045B
    2ff0:	86 89       	ldd	r24, Z+22	; 0x16
    2ff2:	98 17       	cp	r25, r24
    2ff4:	18 f0       	brcs	.+6      	; 0x2ffc <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    2ff6:	81 e0       	ldi	r24, 0x01	; 1
    2ff8:	80 93 64 04 	sts	0x0464, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2ffc:	80 91 af 04 	lds	r24, 0x04AF
    3000:	88 23       	and	r24, r24
    3002:	09 f0       	breq	.+2      	; 0x3006 <xTaskResumeAll+0xce>
    3004:	b6 cf       	rjmp	.-148    	; 0x2f72 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    3006:	8c 81       	ldd	r24, Y+4	; 0x04
    3008:	9d 81       	ldd	r25, Y+5	; 0x05
    300a:	00 97       	sbiw	r24, 0x00	; 0
    300c:	11 f0       	breq	.+4      	; 0x3012 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    300e:	0e 94 66 1c 	call	0x38cc	; 0x38cc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3012:	80 91 62 04 	lds	r24, 0x0462
    3016:	90 91 63 04 	lds	r25, 0x0463
    301a:	9a 83       	std	Y+2, r25	; 0x02
    301c:	89 83       	std	Y+1, r24	; 0x01

					if( xPendedCounts > ( TickType_t ) 0U )
    301e:	89 81       	ldd	r24, Y+1	; 0x01
    3020:	9a 81       	ldd	r25, Y+2	; 0x02
    3022:	00 97       	sbiw	r24, 0x00	; 0
    3024:	a1 f0       	breq	.+40     	; 0x304e <xTaskResumeAll+0x116>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3026:	0e 94 b8 18 	call	0x3170	; 0x3170 <xTaskIncrementTick>
    302a:	88 23       	and	r24, r24
    302c:	19 f0       	breq	.+6      	; 0x3034 <xTaskResumeAll+0xfc>
							{
								xYieldPending = pdTRUE;
    302e:	81 e0       	ldi	r24, 0x01	; 1
    3030:	80 93 64 04 	sts	0x0464, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
    3034:	89 81       	ldd	r24, Y+1	; 0x01
    3036:	9a 81       	ldd	r25, Y+2	; 0x02
    3038:	01 97       	sbiw	r24, 0x01	; 1
    303a:	9a 83       	std	Y+2, r25	; 0x02
    303c:	89 83       	std	Y+1, r24	; 0x01
						} while( xPendedCounts > ( TickType_t ) 0U );
    303e:	89 81       	ldd	r24, Y+1	; 0x01
    3040:	9a 81       	ldd	r25, Y+2	; 0x02
    3042:	00 97       	sbiw	r24, 0x00	; 0
    3044:	81 f7       	brne	.-32     	; 0x3026 <xTaskResumeAll+0xee>

						xPendedTicks = 0;
    3046:	10 92 63 04 	sts	0x0463, r1
    304a:	10 92 62 04 	sts	0x0462, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    304e:	80 91 64 04 	lds	r24, 0x0464
    3052:	88 23       	and	r24, r24
    3054:	21 f0       	breq	.+8      	; 0x305e <xTaskResumeAll+0x126>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3056:	81 e0       	ldi	r24, 0x01	; 1
    3058:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    305a:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    305e:	0f 90       	pop	r0
    3060:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3062:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3064:	0f 90       	pop	r0
    3066:	0f 90       	pop	r0
    3068:	0f 90       	pop	r0
    306a:	0f 90       	pop	r0
    306c:	0f 90       	pop	r0
    306e:	cf 91       	pop	r28
    3070:	df 91       	pop	r29
    3072:	08 95       	ret

00003074 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3074:	df 93       	push	r29
    3076:	cf 93       	push	r28
    3078:	00 d0       	rcall	.+0      	; 0x307a <xTaskGetTickCount+0x6>
    307a:	cd b7       	in	r28, 0x3d	; 61
    307c:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    307e:	0f b6       	in	r0, 0x3f	; 63
    3080:	f8 94       	cli
    3082:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3084:	80 91 5e 04 	lds	r24, 0x045E
    3088:	90 91 5f 04 	lds	r25, 0x045F
    308c:	9a 83       	std	Y+2, r25	; 0x02
    308e:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3090:	0f 90       	pop	r0
    3092:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3094:	89 81       	ldd	r24, Y+1	; 0x01
    3096:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3098:	0f 90       	pop	r0
    309a:	0f 90       	pop	r0
    309c:	cf 91       	pop	r28
    309e:	df 91       	pop	r29
    30a0:	08 95       	ret

000030a2 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    30a2:	df 93       	push	r29
    30a4:	cf 93       	push	r28
    30a6:	00 d0       	rcall	.+0      	; 0x30a8 <xTaskGetTickCountFromISR+0x6>
    30a8:	0f 92       	push	r0
    30aa:	cd b7       	in	r28, 0x3d	; 61
    30ac:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    30ae:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    30b0:	80 91 5e 04 	lds	r24, 0x045E
    30b4:	90 91 5f 04 	lds	r25, 0x045F
    30b8:	9b 83       	std	Y+3, r25	; 0x03
    30ba:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    30bc:	8a 81       	ldd	r24, Y+2	; 0x02
    30be:	9b 81       	ldd	r25, Y+3	; 0x03
}
    30c0:	0f 90       	pop	r0
    30c2:	0f 90       	pop	r0
    30c4:	0f 90       	pop	r0
    30c6:	cf 91       	pop	r28
    30c8:	df 91       	pop	r29
    30ca:	08 95       	ret

000030cc <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    30cc:	df 93       	push	r29
    30ce:	cf 93       	push	r28
    30d0:	cd b7       	in	r28, 0x3d	; 61
    30d2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    30d4:	80 91 5d 04 	lds	r24, 0x045D
}
    30d8:	cf 91       	pop	r28
    30da:	df 91       	pop	r29
    30dc:	08 95       	ret

000030de <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    30de:	df 93       	push	r29
    30e0:	cf 93       	push	r28
    30e2:	00 d0       	rcall	.+0      	; 0x30e4 <pcTaskGetName+0x6>
    30e4:	00 d0       	rcall	.+0      	; 0x30e6 <pcTaskGetName+0x8>
    30e6:	00 d0       	rcall	.+0      	; 0x30e8 <pcTaskGetName+0xa>
    30e8:	cd b7       	in	r28, 0x3d	; 61
    30ea:	de b7       	in	r29, 0x3e	; 62
    30ec:	9c 83       	std	Y+4, r25	; 0x04
    30ee:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    30f0:	8b 81       	ldd	r24, Y+3	; 0x03
    30f2:	9c 81       	ldd	r25, Y+4	; 0x04
    30f4:	00 97       	sbiw	r24, 0x00	; 0
    30f6:	39 f4       	brne	.+14     	; 0x3106 <pcTaskGetName+0x28>
    30f8:	80 91 5a 04 	lds	r24, 0x045A
    30fc:	90 91 5b 04 	lds	r25, 0x045B
    3100:	9e 83       	std	Y+6, r25	; 0x06
    3102:	8d 83       	std	Y+5, r24	; 0x05
    3104:	04 c0       	rjmp	.+8      	; 0x310e <pcTaskGetName+0x30>
    3106:	8b 81       	ldd	r24, Y+3	; 0x03
    3108:	9c 81       	ldd	r25, Y+4	; 0x04
    310a:	9e 83       	std	Y+6, r25	; 0x06
    310c:	8d 83       	std	Y+5, r24	; 0x05
    310e:	8d 81       	ldd	r24, Y+5	; 0x05
    3110:	9e 81       	ldd	r25, Y+6	; 0x06
    3112:	9a 83       	std	Y+2, r25	; 0x02
    3114:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    3116:	89 81       	ldd	r24, Y+1	; 0x01
    3118:	9a 81       	ldd	r25, Y+2	; 0x02
    311a:	49 96       	adiw	r24, 0x19	; 25
}
    311c:	26 96       	adiw	r28, 0x06	; 6
    311e:	0f b6       	in	r0, 0x3f	; 63
    3120:	f8 94       	cli
    3122:	de bf       	out	0x3e, r29	; 62
    3124:	0f be       	out	0x3f, r0	; 63
    3126:	cd bf       	out	0x3d, r28	; 61
    3128:	cf 91       	pop	r28
    312a:	df 91       	pop	r29
    312c:	08 95       	ret

0000312e <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    312e:	df 93       	push	r29
    3130:	cf 93       	push	r28
    3132:	00 d0       	rcall	.+0      	; 0x3134 <xTaskCatchUpTicks+0x6>
    3134:	0f 92       	push	r0
    3136:	cd b7       	in	r28, 0x3d	; 61
    3138:	de b7       	in	r29, 0x3e	; 62
    313a:	9b 83       	std	Y+3, r25	; 0x03
    313c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xYieldRequired = pdFALSE;
    313e:	19 82       	std	Y+1, r1	; 0x01
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
    3140:	0e 94 90 17 	call	0x2f20	; 0x2f20 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
    3144:	20 91 62 04 	lds	r18, 0x0462
    3148:	30 91 63 04 	lds	r19, 0x0463
    314c:	8a 81       	ldd	r24, Y+2	; 0x02
    314e:	9b 81       	ldd	r25, Y+3	; 0x03
    3150:	82 0f       	add	r24, r18
    3152:	93 1f       	adc	r25, r19
    3154:	90 93 63 04 	sts	0x0463, r25
    3158:	80 93 62 04 	sts	0x0462, r24
	xYieldRequired = xTaskResumeAll();
    315c:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <xTaskResumeAll>
    3160:	89 83       	std	Y+1, r24	; 0x01

	return xYieldRequired;
    3162:	89 81       	ldd	r24, Y+1	; 0x01
}
    3164:	0f 90       	pop	r0
    3166:	0f 90       	pop	r0
    3168:	0f 90       	pop	r0
    316a:	cf 91       	pop	r28
    316c:	df 91       	pop	r29
    316e:	08 95       	ret

00003170 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3170:	df 93       	push	r29
    3172:	cf 93       	push	r28
    3174:	cd b7       	in	r28, 0x3d	; 61
    3176:	de b7       	in	r29, 0x3e	; 62
    3178:	29 97       	sbiw	r28, 0x09	; 9
    317a:	0f b6       	in	r0, 0x3f	; 63
    317c:	f8 94       	cli
    317e:	de bf       	out	0x3e, r29	; 62
    3180:	0f be       	out	0x3f, r0	; 63
    3182:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3184:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3186:	80 91 6b 04 	lds	r24, 0x046B
    318a:	88 23       	and	r24, r24
    318c:	09 f0       	breq	.+2      	; 0x3190 <xTaskIncrementTick+0x20>
    318e:	c6 c0       	rjmp	.+396    	; 0x331c <xTaskIncrementTick+0x1ac>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3190:	80 91 5e 04 	lds	r24, 0x045E
    3194:	90 91 5f 04 	lds	r25, 0x045F
    3198:	01 96       	adiw	r24, 0x01	; 1
    319a:	9c 83       	std	Y+4, r25	; 0x04
    319c:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    319e:	8b 81       	ldd	r24, Y+3	; 0x03
    31a0:	9c 81       	ldd	r25, Y+4	; 0x04
    31a2:	90 93 5f 04 	sts	0x045F, r25
    31a6:	80 93 5e 04 	sts	0x045E, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    31aa:	8b 81       	ldd	r24, Y+3	; 0x03
    31ac:	9c 81       	ldd	r25, Y+4	; 0x04
    31ae:	00 97       	sbiw	r24, 0x00	; 0
    31b0:	d9 f4       	brne	.+54     	; 0x31e8 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    31b2:	80 91 ab 04 	lds	r24, 0x04AB
    31b6:	90 91 ac 04 	lds	r25, 0x04AC
    31ba:	9a 83       	std	Y+2, r25	; 0x02
    31bc:	89 83       	std	Y+1, r24	; 0x01
    31be:	80 91 ad 04 	lds	r24, 0x04AD
    31c2:	90 91 ae 04 	lds	r25, 0x04AE
    31c6:	90 93 ac 04 	sts	0x04AC, r25
    31ca:	80 93 ab 04 	sts	0x04AB, r24
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
    31d0:	9a 81       	ldd	r25, Y+2	; 0x02
    31d2:	90 93 ae 04 	sts	0x04AE, r25
    31d6:	80 93 ad 04 	sts	0x04AD, r24
    31da:	80 91 65 04 	lds	r24, 0x0465
    31de:	8f 5f       	subi	r24, 0xFF	; 255
    31e0:	80 93 65 04 	sts	0x0465, r24
    31e4:	0e 94 66 1c 	call	0x38cc	; 0x38cc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    31e8:	20 91 67 04 	lds	r18, 0x0467
    31ec:	30 91 68 04 	lds	r19, 0x0468
    31f0:	8b 81       	ldd	r24, Y+3	; 0x03
    31f2:	9c 81       	ldd	r25, Y+4	; 0x04
    31f4:	82 17       	cp	r24, r18
    31f6:	93 07       	cpc	r25, r19
    31f8:	08 f4       	brcc	.+2      	; 0x31fc <xTaskIncrementTick+0x8c>
    31fa:	71 c0       	rjmp	.+226    	; 0x32de <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    31fc:	e0 91 ab 04 	lds	r30, 0x04AB
    3200:	f0 91 ac 04 	lds	r31, 0x04AC
    3204:	80 81       	ld	r24, Z
    3206:	88 23       	and	r24, r24
    3208:	39 f4       	brne	.+14     	; 0x3218 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    320a:	8f ef       	ldi	r24, 0xFF	; 255
    320c:	9f ef       	ldi	r25, 0xFF	; 255
    320e:	90 93 68 04 	sts	0x0468, r25
    3212:	80 93 67 04 	sts	0x0467, r24
    3216:	63 c0       	rjmp	.+198    	; 0x32de <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3218:	e0 91 ab 04 	lds	r30, 0x04AB
    321c:	f0 91 ac 04 	lds	r31, 0x04AC
    3220:	05 80       	ldd	r0, Z+5	; 0x05
    3222:	f6 81       	ldd	r31, Z+6	; 0x06
    3224:	e0 2d       	mov	r30, r0
    3226:	86 81       	ldd	r24, Z+6	; 0x06
    3228:	97 81       	ldd	r25, Z+7	; 0x07
    322a:	99 87       	std	Y+9, r25	; 0x09
    322c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    322e:	e8 85       	ldd	r30, Y+8	; 0x08
    3230:	f9 85       	ldd	r31, Y+9	; 0x09
    3232:	82 81       	ldd	r24, Z+2	; 0x02
    3234:	93 81       	ldd	r25, Z+3	; 0x03
    3236:	9f 83       	std	Y+7, r25	; 0x07
    3238:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    323a:	2b 81       	ldd	r18, Y+3	; 0x03
    323c:	3c 81       	ldd	r19, Y+4	; 0x04
    323e:	8e 81       	ldd	r24, Y+6	; 0x06
    3240:	9f 81       	ldd	r25, Y+7	; 0x07
    3242:	28 17       	cp	r18, r24
    3244:	39 07       	cpc	r19, r25
    3246:	38 f4       	brcc	.+14     	; 0x3256 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3248:	8e 81       	ldd	r24, Y+6	; 0x06
    324a:	9f 81       	ldd	r25, Y+7	; 0x07
    324c:	90 93 68 04 	sts	0x0468, r25
    3250:	80 93 67 04 	sts	0x0467, r24
    3254:	44 c0       	rjmp	.+136    	; 0x32de <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3256:	88 85       	ldd	r24, Y+8	; 0x08
    3258:	99 85       	ldd	r25, Y+9	; 0x09
    325a:	02 96       	adiw	r24, 0x02	; 2
    325c:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3260:	e8 85       	ldd	r30, Y+8	; 0x08
    3262:	f9 85       	ldd	r31, Y+9	; 0x09
    3264:	84 89       	ldd	r24, Z+20	; 0x14
    3266:	95 89       	ldd	r25, Z+21	; 0x15
    3268:	00 97       	sbiw	r24, 0x00	; 0
    326a:	29 f0       	breq	.+10     	; 0x3276 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    326c:	88 85       	ldd	r24, Y+8	; 0x08
    326e:	99 85       	ldd	r25, Y+9	; 0x09
    3270:	0c 96       	adiw	r24, 0x0c	; 12
    3272:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3276:	e8 85       	ldd	r30, Y+8	; 0x08
    3278:	f9 85       	ldd	r31, Y+9	; 0x09
    327a:	96 89       	ldd	r25, Z+22	; 0x16
    327c:	80 91 60 04 	lds	r24, 0x0460
    3280:	89 17       	cp	r24, r25
    3282:	28 f4       	brcc	.+10     	; 0x328e <xTaskIncrementTick+0x11e>
    3284:	e8 85       	ldd	r30, Y+8	; 0x08
    3286:	f9 85       	ldd	r31, Y+9	; 0x09
    3288:	86 89       	ldd	r24, Z+22	; 0x16
    328a:	80 93 60 04 	sts	0x0460, r24
    328e:	e8 85       	ldd	r30, Y+8	; 0x08
    3290:	f9 85       	ldd	r31, Y+9	; 0x09
    3292:	86 89       	ldd	r24, Z+22	; 0x16
    3294:	28 2f       	mov	r18, r24
    3296:	30 e0       	ldi	r19, 0x00	; 0
    3298:	c9 01       	movw	r24, r18
    329a:	88 0f       	add	r24, r24
    329c:	99 1f       	adc	r25, r25
    329e:	88 0f       	add	r24, r24
    32a0:	99 1f       	adc	r25, r25
    32a2:	88 0f       	add	r24, r24
    32a4:	99 1f       	adc	r25, r25
    32a6:	82 0f       	add	r24, r18
    32a8:	93 1f       	adc	r25, r19
    32aa:	ac 01       	movw	r20, r24
    32ac:	44 59       	subi	r20, 0x94	; 148
    32ae:	5b 4f       	sbci	r21, 0xFB	; 251
    32b0:	88 85       	ldd	r24, Y+8	; 0x08
    32b2:	99 85       	ldd	r25, Y+9	; 0x09
    32b4:	9c 01       	movw	r18, r24
    32b6:	2e 5f       	subi	r18, 0xFE	; 254
    32b8:	3f 4f       	sbci	r19, 0xFF	; 255
    32ba:	ca 01       	movw	r24, r20
    32bc:	b9 01       	movw	r22, r18
    32be:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    32c2:	e8 85       	ldd	r30, Y+8	; 0x08
    32c4:	f9 85       	ldd	r31, Y+9	; 0x09
    32c6:	96 89       	ldd	r25, Z+22	; 0x16
    32c8:	e0 91 5a 04 	lds	r30, 0x045A
    32cc:	f0 91 5b 04 	lds	r31, 0x045B
    32d0:	86 89       	ldd	r24, Z+22	; 0x16
    32d2:	98 17       	cp	r25, r24
    32d4:	08 f4       	brcc	.+2      	; 0x32d8 <xTaskIncrementTick+0x168>
    32d6:	92 cf       	rjmp	.-220    	; 0x31fc <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    32d8:	81 e0       	ldi	r24, 0x01	; 1
    32da:	8d 83       	std	Y+5, r24	; 0x05
    32dc:	8f cf       	rjmp	.-226    	; 0x31fc <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    32de:	e0 91 5a 04 	lds	r30, 0x045A
    32e2:	f0 91 5b 04 	lds	r31, 0x045B
    32e6:	86 89       	ldd	r24, Z+22	; 0x16
    32e8:	28 2f       	mov	r18, r24
    32ea:	30 e0       	ldi	r19, 0x00	; 0
    32ec:	c9 01       	movw	r24, r18
    32ee:	88 0f       	add	r24, r24
    32f0:	99 1f       	adc	r25, r25
    32f2:	88 0f       	add	r24, r24
    32f4:	99 1f       	adc	r25, r25
    32f6:	88 0f       	add	r24, r24
    32f8:	99 1f       	adc	r25, r25
    32fa:	82 0f       	add	r24, r18
    32fc:	93 1f       	adc	r25, r19
    32fe:	fc 01       	movw	r30, r24
    3300:	e4 59       	subi	r30, 0x94	; 148
    3302:	fb 4f       	sbci	r31, 0xFB	; 251
    3304:	80 81       	ld	r24, Z
    3306:	82 30       	cpi	r24, 0x02	; 2
    3308:	10 f0       	brcs	.+4      	; 0x330e <xTaskIncrementTick+0x19e>
			{
				xSwitchRequired = pdTRUE;
    330a:	81 e0       	ldi	r24, 0x01	; 1
    330c:	8d 83       	std	Y+5, r24	; 0x05
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
    330e:	80 91 64 04 	lds	r24, 0x0464
    3312:	88 23       	and	r24, r24
    3314:	61 f0       	breq	.+24     	; 0x332e <xTaskIncrementTick+0x1be>
			{
				xSwitchRequired = pdTRUE;
    3316:	81 e0       	ldi	r24, 0x01	; 1
    3318:	8d 83       	std	Y+5, r24	; 0x05
    331a:	09 c0       	rjmp	.+18     	; 0x332e <xTaskIncrementTick+0x1be>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
    331c:	80 91 62 04 	lds	r24, 0x0462
    3320:	90 91 63 04 	lds	r25, 0x0463
    3324:	01 96       	adiw	r24, 0x01	; 1
    3326:	90 93 63 04 	sts	0x0463, r25
    332a:	80 93 62 04 	sts	0x0462, r24
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
    332e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3330:	29 96       	adiw	r28, 0x09	; 9
    3332:	0f b6       	in	r0, 0x3f	; 63
    3334:	f8 94       	cli
    3336:	de bf       	out	0x3e, r29	; 62
    3338:	0f be       	out	0x3f, r0	; 63
    333a:	cd bf       	out	0x3d, r28	; 61
    333c:	cf 91       	pop	r28
    333e:	df 91       	pop	r29
    3340:	08 95       	ret

00003342 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3342:	df 93       	push	r29
    3344:	cf 93       	push	r28
    3346:	00 d0       	rcall	.+0      	; 0x3348 <vTaskSwitchContext+0x6>
    3348:	0f 92       	push	r0
    334a:	cd b7       	in	r28, 0x3d	; 61
    334c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    334e:	80 91 6b 04 	lds	r24, 0x046B
    3352:	88 23       	and	r24, r24
    3354:	21 f0       	breq	.+8      	; 0x335e <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3356:	81 e0       	ldi	r24, 0x01	; 1
    3358:	80 93 64 04 	sts	0x0464, r24
    335c:	59 c0       	rjmp	.+178    	; 0x3410 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    335e:	10 92 64 04 	sts	0x0464, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3362:	80 91 60 04 	lds	r24, 0x0460
    3366:	8b 83       	std	Y+3, r24	; 0x03
    3368:	03 c0       	rjmp	.+6      	; 0x3370 <vTaskSwitchContext+0x2e>
    336a:	8b 81       	ldd	r24, Y+3	; 0x03
    336c:	81 50       	subi	r24, 0x01	; 1
    336e:	8b 83       	std	Y+3, r24	; 0x03
    3370:	8b 81       	ldd	r24, Y+3	; 0x03
    3372:	28 2f       	mov	r18, r24
    3374:	30 e0       	ldi	r19, 0x00	; 0
    3376:	c9 01       	movw	r24, r18
    3378:	88 0f       	add	r24, r24
    337a:	99 1f       	adc	r25, r25
    337c:	88 0f       	add	r24, r24
    337e:	99 1f       	adc	r25, r25
    3380:	88 0f       	add	r24, r24
    3382:	99 1f       	adc	r25, r25
    3384:	82 0f       	add	r24, r18
    3386:	93 1f       	adc	r25, r19
    3388:	fc 01       	movw	r30, r24
    338a:	e4 59       	subi	r30, 0x94	; 148
    338c:	fb 4f       	sbci	r31, 0xFB	; 251
    338e:	80 81       	ld	r24, Z
    3390:	88 23       	and	r24, r24
    3392:	59 f3       	breq	.-42     	; 0x336a <vTaskSwitchContext+0x28>
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
    3396:	28 2f       	mov	r18, r24
    3398:	30 e0       	ldi	r19, 0x00	; 0
    339a:	c9 01       	movw	r24, r18
    339c:	88 0f       	add	r24, r24
    339e:	99 1f       	adc	r25, r25
    33a0:	88 0f       	add	r24, r24
    33a2:	99 1f       	adc	r25, r25
    33a4:	88 0f       	add	r24, r24
    33a6:	99 1f       	adc	r25, r25
    33a8:	82 0f       	add	r24, r18
    33aa:	93 1f       	adc	r25, r19
    33ac:	84 59       	subi	r24, 0x94	; 148
    33ae:	9b 4f       	sbci	r25, 0xFB	; 251
    33b0:	9a 83       	std	Y+2, r25	; 0x02
    33b2:	89 83       	std	Y+1, r24	; 0x01
    33b4:	e9 81       	ldd	r30, Y+1	; 0x01
    33b6:	fa 81       	ldd	r31, Y+2	; 0x02
    33b8:	01 80       	ldd	r0, Z+1	; 0x01
    33ba:	f2 81       	ldd	r31, Z+2	; 0x02
    33bc:	e0 2d       	mov	r30, r0
    33be:	82 81       	ldd	r24, Z+2	; 0x02
    33c0:	93 81       	ldd	r25, Z+3	; 0x03
    33c2:	e9 81       	ldd	r30, Y+1	; 0x01
    33c4:	fa 81       	ldd	r31, Y+2	; 0x02
    33c6:	92 83       	std	Z+2, r25	; 0x02
    33c8:	81 83       	std	Z+1, r24	; 0x01
    33ca:	e9 81       	ldd	r30, Y+1	; 0x01
    33cc:	fa 81       	ldd	r31, Y+2	; 0x02
    33ce:	21 81       	ldd	r18, Z+1	; 0x01
    33d0:	32 81       	ldd	r19, Z+2	; 0x02
    33d2:	89 81       	ldd	r24, Y+1	; 0x01
    33d4:	9a 81       	ldd	r25, Y+2	; 0x02
    33d6:	03 96       	adiw	r24, 0x03	; 3
    33d8:	28 17       	cp	r18, r24
    33da:	39 07       	cpc	r19, r25
    33dc:	59 f4       	brne	.+22     	; 0x33f4 <vTaskSwitchContext+0xb2>
    33de:	e9 81       	ldd	r30, Y+1	; 0x01
    33e0:	fa 81       	ldd	r31, Y+2	; 0x02
    33e2:	01 80       	ldd	r0, Z+1	; 0x01
    33e4:	f2 81       	ldd	r31, Z+2	; 0x02
    33e6:	e0 2d       	mov	r30, r0
    33e8:	82 81       	ldd	r24, Z+2	; 0x02
    33ea:	93 81       	ldd	r25, Z+3	; 0x03
    33ec:	e9 81       	ldd	r30, Y+1	; 0x01
    33ee:	fa 81       	ldd	r31, Y+2	; 0x02
    33f0:	92 83       	std	Z+2, r25	; 0x02
    33f2:	81 83       	std	Z+1, r24	; 0x01
    33f4:	e9 81       	ldd	r30, Y+1	; 0x01
    33f6:	fa 81       	ldd	r31, Y+2	; 0x02
    33f8:	01 80       	ldd	r0, Z+1	; 0x01
    33fa:	f2 81       	ldd	r31, Z+2	; 0x02
    33fc:	e0 2d       	mov	r30, r0
    33fe:	86 81       	ldd	r24, Z+6	; 0x06
    3400:	97 81       	ldd	r25, Z+7	; 0x07
    3402:	90 93 5b 04 	sts	0x045B, r25
    3406:	80 93 5a 04 	sts	0x045A, r24
    340a:	8b 81       	ldd	r24, Y+3	; 0x03
    340c:	80 93 60 04 	sts	0x0460, r24
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3410:	0f 90       	pop	r0
    3412:	0f 90       	pop	r0
    3414:	0f 90       	pop	r0
    3416:	cf 91       	pop	r28
    3418:	df 91       	pop	r29
    341a:	08 95       	ret

0000341c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    341c:	df 93       	push	r29
    341e:	cf 93       	push	r28
    3420:	00 d0       	rcall	.+0      	; 0x3422 <vTaskPlaceOnEventList+0x6>
    3422:	00 d0       	rcall	.+0      	; 0x3424 <vTaskPlaceOnEventList+0x8>
    3424:	cd b7       	in	r28, 0x3d	; 61
    3426:	de b7       	in	r29, 0x3e	; 62
    3428:	9a 83       	std	Y+2, r25	; 0x02
    342a:	89 83       	std	Y+1, r24	; 0x01
    342c:	7c 83       	std	Y+4, r23	; 0x04
    342e:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3430:	80 91 5a 04 	lds	r24, 0x045A
    3434:	90 91 5b 04 	lds	r25, 0x045B
    3438:	9c 01       	movw	r18, r24
    343a:	24 5f       	subi	r18, 0xF4	; 244
    343c:	3f 4f       	sbci	r19, 0xFF	; 255
    343e:	89 81       	ldd	r24, Y+1	; 0x01
    3440:	9a 81       	ldd	r25, Y+2	; 0x02
    3442:	b9 01       	movw	r22, r18
    3444:	0e 94 49 07 	call	0xe92	; 0xe92 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3448:	8b 81       	ldd	r24, Y+3	; 0x03
    344a:	9c 81       	ldd	r25, Y+4	; 0x04
    344c:	61 e0       	ldi	r22, 0x01	; 1
    344e:	0e 94 bb 20 	call	0x4176	; 0x4176 <prvAddCurrentTaskToDelayedList>
}
    3452:	0f 90       	pop	r0
    3454:	0f 90       	pop	r0
    3456:	0f 90       	pop	r0
    3458:	0f 90       	pop	r0
    345a:	cf 91       	pop	r28
    345c:	df 91       	pop	r29
    345e:	08 95       	ret

00003460 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3460:	df 93       	push	r29
    3462:	cf 93       	push	r28
    3464:	00 d0       	rcall	.+0      	; 0x3466 <vTaskPlaceOnUnorderedEventList+0x6>
    3466:	00 d0       	rcall	.+0      	; 0x3468 <vTaskPlaceOnUnorderedEventList+0x8>
    3468:	00 d0       	rcall	.+0      	; 0x346a <vTaskPlaceOnUnorderedEventList+0xa>
    346a:	cd b7       	in	r28, 0x3d	; 61
    346c:	de b7       	in	r29, 0x3e	; 62
    346e:	9a 83       	std	Y+2, r25	; 0x02
    3470:	89 83       	std	Y+1, r24	; 0x01
    3472:	7c 83       	std	Y+4, r23	; 0x04
    3474:	6b 83       	std	Y+3, r22	; 0x03
    3476:	5e 83       	std	Y+6, r21	; 0x06
    3478:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    347a:	e0 91 5a 04 	lds	r30, 0x045A
    347e:	f0 91 5b 04 	lds	r31, 0x045B
    3482:	8b 81       	ldd	r24, Y+3	; 0x03
    3484:	9c 81       	ldd	r25, Y+4	; 0x04
    3486:	90 68       	ori	r25, 0x80	; 128
    3488:	95 87       	std	Z+13, r25	; 0x0d
    348a:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    348c:	80 91 5a 04 	lds	r24, 0x045A
    3490:	90 91 5b 04 	lds	r25, 0x045B
    3494:	9c 01       	movw	r18, r24
    3496:	24 5f       	subi	r18, 0xF4	; 244
    3498:	3f 4f       	sbci	r19, 0xFF	; 255
    349a:	89 81       	ldd	r24, Y+1	; 0x01
    349c:	9a 81       	ldd	r25, Y+2	; 0x02
    349e:	b9 01       	movw	r22, r18
    34a0:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    34a4:	8d 81       	ldd	r24, Y+5	; 0x05
    34a6:	9e 81       	ldd	r25, Y+6	; 0x06
    34a8:	61 e0       	ldi	r22, 0x01	; 1
    34aa:	0e 94 bb 20 	call	0x4176	; 0x4176 <prvAddCurrentTaskToDelayedList>
}
    34ae:	26 96       	adiw	r28, 0x06	; 6
    34b0:	0f b6       	in	r0, 0x3f	; 63
    34b2:	f8 94       	cli
    34b4:	de bf       	out	0x3e, r29	; 62
    34b6:	0f be       	out	0x3f, r0	; 63
    34b8:	cd bf       	out	0x3d, r28	; 61
    34ba:	cf 91       	pop	r28
    34bc:	df 91       	pop	r29
    34be:	08 95       	ret

000034c0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    34c0:	df 93       	push	r29
    34c2:	cf 93       	push	r28
    34c4:	00 d0       	rcall	.+0      	; 0x34c6 <xTaskRemoveFromEventList+0x6>
    34c6:	00 d0       	rcall	.+0      	; 0x34c8 <xTaskRemoveFromEventList+0x8>
    34c8:	0f 92       	push	r0
    34ca:	cd b7       	in	r28, 0x3d	; 61
    34cc:	de b7       	in	r29, 0x3e	; 62
    34ce:	9d 83       	std	Y+5, r25	; 0x05
    34d0:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34d2:	ec 81       	ldd	r30, Y+4	; 0x04
    34d4:	fd 81       	ldd	r31, Y+5	; 0x05
    34d6:	05 80       	ldd	r0, Z+5	; 0x05
    34d8:	f6 81       	ldd	r31, Z+6	; 0x06
    34da:	e0 2d       	mov	r30, r0
    34dc:	86 81       	ldd	r24, Z+6	; 0x06
    34de:	97 81       	ldd	r25, Z+7	; 0x07
    34e0:	9b 83       	std	Y+3, r25	; 0x03
    34e2:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    34e4:	8a 81       	ldd	r24, Y+2	; 0x02
    34e6:	9b 81       	ldd	r25, Y+3	; 0x03
    34e8:	0c 96       	adiw	r24, 0x0c	; 12
    34ea:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    34ee:	80 91 6b 04 	lds	r24, 0x046B
    34f2:	88 23       	and	r24, r24
    34f4:	61 f5       	brne	.+88     	; 0x354e <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    34f6:	8a 81       	ldd	r24, Y+2	; 0x02
    34f8:	9b 81       	ldd	r25, Y+3	; 0x03
    34fa:	02 96       	adiw	r24, 0x02	; 2
    34fc:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3500:	ea 81       	ldd	r30, Y+2	; 0x02
    3502:	fb 81       	ldd	r31, Y+3	; 0x03
    3504:	96 89       	ldd	r25, Z+22	; 0x16
    3506:	80 91 60 04 	lds	r24, 0x0460
    350a:	89 17       	cp	r24, r25
    350c:	28 f4       	brcc	.+10     	; 0x3518 <xTaskRemoveFromEventList+0x58>
    350e:	ea 81       	ldd	r30, Y+2	; 0x02
    3510:	fb 81       	ldd	r31, Y+3	; 0x03
    3512:	86 89       	ldd	r24, Z+22	; 0x16
    3514:	80 93 60 04 	sts	0x0460, r24
    3518:	ea 81       	ldd	r30, Y+2	; 0x02
    351a:	fb 81       	ldd	r31, Y+3	; 0x03
    351c:	86 89       	ldd	r24, Z+22	; 0x16
    351e:	28 2f       	mov	r18, r24
    3520:	30 e0       	ldi	r19, 0x00	; 0
    3522:	c9 01       	movw	r24, r18
    3524:	88 0f       	add	r24, r24
    3526:	99 1f       	adc	r25, r25
    3528:	88 0f       	add	r24, r24
    352a:	99 1f       	adc	r25, r25
    352c:	88 0f       	add	r24, r24
    352e:	99 1f       	adc	r25, r25
    3530:	82 0f       	add	r24, r18
    3532:	93 1f       	adc	r25, r19
    3534:	ac 01       	movw	r20, r24
    3536:	44 59       	subi	r20, 0x94	; 148
    3538:	5b 4f       	sbci	r21, 0xFB	; 251
    353a:	8a 81       	ldd	r24, Y+2	; 0x02
    353c:	9b 81       	ldd	r25, Y+3	; 0x03
    353e:	9c 01       	movw	r18, r24
    3540:	2e 5f       	subi	r18, 0xFE	; 254
    3542:	3f 4f       	sbci	r19, 0xFF	; 255
    3544:	ca 01       	movw	r24, r20
    3546:	b9 01       	movw	r22, r18
    3548:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
    354c:	0a c0       	rjmp	.+20     	; 0x3562 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    354e:	8a 81       	ldd	r24, Y+2	; 0x02
    3550:	9b 81       	ldd	r25, Y+3	; 0x03
    3552:	9c 01       	movw	r18, r24
    3554:	24 5f       	subi	r18, 0xF4	; 244
    3556:	3f 4f       	sbci	r19, 0xFF	; 255
    3558:	8f ea       	ldi	r24, 0xAF	; 175
    355a:	94 e0       	ldi	r25, 0x04	; 4
    355c:	b9 01       	movw	r22, r18
    355e:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3562:	ea 81       	ldd	r30, Y+2	; 0x02
    3564:	fb 81       	ldd	r31, Y+3	; 0x03
    3566:	96 89       	ldd	r25, Z+22	; 0x16
    3568:	e0 91 5a 04 	lds	r30, 0x045A
    356c:	f0 91 5b 04 	lds	r31, 0x045B
    3570:	86 89       	ldd	r24, Z+22	; 0x16
    3572:	89 17       	cp	r24, r25
    3574:	30 f4       	brcc	.+12     	; 0x3582 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3576:	81 e0       	ldi	r24, 0x01	; 1
    3578:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	80 93 64 04 	sts	0x0464, r24
    3580:	01 c0       	rjmp	.+2      	; 0x3584 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3582:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3584:	89 81       	ldd	r24, Y+1	; 0x01
}
    3586:	0f 90       	pop	r0
    3588:	0f 90       	pop	r0
    358a:	0f 90       	pop	r0
    358c:	0f 90       	pop	r0
    358e:	0f 90       	pop	r0
    3590:	cf 91       	pop	r28
    3592:	df 91       	pop	r29
    3594:	08 95       	ret

00003596 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3596:	df 93       	push	r29
    3598:	cf 93       	push	r28
    359a:	00 d0       	rcall	.+0      	; 0x359c <vTaskRemoveFromUnorderedEventList+0x6>
    359c:	00 d0       	rcall	.+0      	; 0x359e <vTaskRemoveFromUnorderedEventList+0x8>
    359e:	00 d0       	rcall	.+0      	; 0x35a0 <vTaskRemoveFromUnorderedEventList+0xa>
    35a0:	cd b7       	in	r28, 0x3d	; 61
    35a2:	de b7       	in	r29, 0x3e	; 62
    35a4:	9c 83       	std	Y+4, r25	; 0x04
    35a6:	8b 83       	std	Y+3, r24	; 0x03
    35a8:	7e 83       	std	Y+6, r23	; 0x06
    35aa:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    35ac:	8d 81       	ldd	r24, Y+5	; 0x05
    35ae:	9e 81       	ldd	r25, Y+6	; 0x06
    35b0:	90 68       	ori	r25, 0x80	; 128
    35b2:	eb 81       	ldd	r30, Y+3	; 0x03
    35b4:	fc 81       	ldd	r31, Y+4	; 0x04
    35b6:	91 83       	std	Z+1, r25	; 0x01
    35b8:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    35ba:	eb 81       	ldd	r30, Y+3	; 0x03
    35bc:	fc 81       	ldd	r31, Y+4	; 0x04
    35be:	86 81       	ldd	r24, Z+6	; 0x06
    35c0:	97 81       	ldd	r25, Z+7	; 0x07
    35c2:	9a 83       	std	Y+2, r25	; 0x02
    35c4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    35c6:	8b 81       	ldd	r24, Y+3	; 0x03
    35c8:	9c 81       	ldd	r25, Y+4	; 0x04
    35ca:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    35ce:	89 81       	ldd	r24, Y+1	; 0x01
    35d0:	9a 81       	ldd	r25, Y+2	; 0x02
    35d2:	02 96       	adiw	r24, 0x02	; 2
    35d4:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    35d8:	e9 81       	ldd	r30, Y+1	; 0x01
    35da:	fa 81       	ldd	r31, Y+2	; 0x02
    35dc:	96 89       	ldd	r25, Z+22	; 0x16
    35de:	80 91 60 04 	lds	r24, 0x0460
    35e2:	89 17       	cp	r24, r25
    35e4:	28 f4       	brcc	.+10     	; 0x35f0 <vTaskRemoveFromUnorderedEventList+0x5a>
    35e6:	e9 81       	ldd	r30, Y+1	; 0x01
    35e8:	fa 81       	ldd	r31, Y+2	; 0x02
    35ea:	86 89       	ldd	r24, Z+22	; 0x16
    35ec:	80 93 60 04 	sts	0x0460, r24
    35f0:	e9 81       	ldd	r30, Y+1	; 0x01
    35f2:	fa 81       	ldd	r31, Y+2	; 0x02
    35f4:	86 89       	ldd	r24, Z+22	; 0x16
    35f6:	28 2f       	mov	r18, r24
    35f8:	30 e0       	ldi	r19, 0x00	; 0
    35fa:	c9 01       	movw	r24, r18
    35fc:	88 0f       	add	r24, r24
    35fe:	99 1f       	adc	r25, r25
    3600:	88 0f       	add	r24, r24
    3602:	99 1f       	adc	r25, r25
    3604:	88 0f       	add	r24, r24
    3606:	99 1f       	adc	r25, r25
    3608:	82 0f       	add	r24, r18
    360a:	93 1f       	adc	r25, r19
    360c:	ac 01       	movw	r20, r24
    360e:	44 59       	subi	r20, 0x94	; 148
    3610:	5b 4f       	sbci	r21, 0xFB	; 251
    3612:	89 81       	ldd	r24, Y+1	; 0x01
    3614:	9a 81       	ldd	r25, Y+2	; 0x02
    3616:	9c 01       	movw	r18, r24
    3618:	2e 5f       	subi	r18, 0xFE	; 254
    361a:	3f 4f       	sbci	r19, 0xFF	; 255
    361c:	ca 01       	movw	r24, r20
    361e:	b9 01       	movw	r22, r18
    3620:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3624:	e9 81       	ldd	r30, Y+1	; 0x01
    3626:	fa 81       	ldd	r31, Y+2	; 0x02
    3628:	96 89       	ldd	r25, Z+22	; 0x16
    362a:	e0 91 5a 04 	lds	r30, 0x045A
    362e:	f0 91 5b 04 	lds	r31, 0x045B
    3632:	86 89       	ldd	r24, Z+22	; 0x16
    3634:	89 17       	cp	r24, r25
    3636:	18 f4       	brcc	.+6      	; 0x363e <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3638:	81 e0       	ldi	r24, 0x01	; 1
    363a:	80 93 64 04 	sts	0x0464, r24
	}
}
    363e:	26 96       	adiw	r28, 0x06	; 6
    3640:	0f b6       	in	r0, 0x3f	; 63
    3642:	f8 94       	cli
    3644:	de bf       	out	0x3e, r29	; 62
    3646:	0f be       	out	0x3f, r0	; 63
    3648:	cd bf       	out	0x3d, r28	; 61
    364a:	cf 91       	pop	r28
    364c:	df 91       	pop	r29
    364e:	08 95       	ret

00003650 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3650:	df 93       	push	r29
    3652:	cf 93       	push	r28
    3654:	00 d0       	rcall	.+0      	; 0x3656 <vTaskSetTimeOutState+0x6>
    3656:	cd b7       	in	r28, 0x3d	; 61
    3658:	de b7       	in	r29, 0x3e	; 62
    365a:	9a 83       	std	Y+2, r25	; 0x02
    365c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    365e:	0f b6       	in	r0, 0x3f	; 63
    3660:	f8 94       	cli
    3662:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3664:	80 91 65 04 	lds	r24, 0x0465
    3668:	e9 81       	ldd	r30, Y+1	; 0x01
    366a:	fa 81       	ldd	r31, Y+2	; 0x02
    366c:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    366e:	80 91 5e 04 	lds	r24, 0x045E
    3672:	90 91 5f 04 	lds	r25, 0x045F
    3676:	e9 81       	ldd	r30, Y+1	; 0x01
    3678:	fa 81       	ldd	r31, Y+2	; 0x02
    367a:	92 83       	std	Z+2, r25	; 0x02
    367c:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    367e:	0f 90       	pop	r0
    3680:	0f be       	out	0x3f, r0	; 63
}
    3682:	0f 90       	pop	r0
    3684:	0f 90       	pop	r0
    3686:	cf 91       	pop	r28
    3688:	df 91       	pop	r29
    368a:	08 95       	ret

0000368c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    368c:	df 93       	push	r29
    368e:	cf 93       	push	r28
    3690:	00 d0       	rcall	.+0      	; 0x3692 <vTaskInternalSetTimeOutState+0x6>
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
    3696:	9a 83       	std	Y+2, r25	; 0x02
    3698:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    369a:	80 91 65 04 	lds	r24, 0x0465
    369e:	e9 81       	ldd	r30, Y+1	; 0x01
    36a0:	fa 81       	ldd	r31, Y+2	; 0x02
    36a2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    36a4:	80 91 5e 04 	lds	r24, 0x045E
    36a8:	90 91 5f 04 	lds	r25, 0x045F
    36ac:	e9 81       	ldd	r30, Y+1	; 0x01
    36ae:	fa 81       	ldd	r31, Y+2	; 0x02
    36b0:	92 83       	std	Z+2, r25	; 0x02
    36b2:	81 83       	std	Z+1, r24	; 0x01
}
    36b4:	0f 90       	pop	r0
    36b6:	0f 90       	pop	r0
    36b8:	cf 91       	pop	r28
    36ba:	df 91       	pop	r29
    36bc:	08 95       	ret

000036be <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    36be:	df 93       	push	r29
    36c0:	cf 93       	push	r28
    36c2:	cd b7       	in	r28, 0x3d	; 61
    36c4:	de b7       	in	r29, 0x3e	; 62
    36c6:	29 97       	sbiw	r28, 0x09	; 9
    36c8:	0f b6       	in	r0, 0x3f	; 63
    36ca:	f8 94       	cli
    36cc:	de bf       	out	0x3e, r29	; 62
    36ce:	0f be       	out	0x3f, r0	; 63
    36d0:	cd bf       	out	0x3d, r28	; 61
    36d2:	9f 83       	std	Y+7, r25	; 0x07
    36d4:	8e 83       	std	Y+6, r24	; 0x06
    36d6:	79 87       	std	Y+9, r23	; 0x09
    36d8:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    36da:	0f b6       	in	r0, 0x3f	; 63
    36dc:	f8 94       	cli
    36de:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    36e0:	80 91 5e 04 	lds	r24, 0x045E
    36e4:	90 91 5f 04 	lds	r25, 0x045F
    36e8:	9c 83       	std	Y+4, r25	; 0x04
    36ea:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    36ec:	ee 81       	ldd	r30, Y+6	; 0x06
    36ee:	ff 81       	ldd	r31, Y+7	; 0x07
    36f0:	21 81       	ldd	r18, Z+1	; 0x01
    36f2:	32 81       	ldd	r19, Z+2	; 0x02
    36f4:	8b 81       	ldd	r24, Y+3	; 0x03
    36f6:	9c 81       	ldd	r25, Y+4	; 0x04
    36f8:	82 1b       	sub	r24, r18
    36fa:	93 0b       	sbc	r25, r19
    36fc:	9a 83       	std	Y+2, r25	; 0x02
    36fe:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3700:	e8 85       	ldd	r30, Y+8	; 0x08
    3702:	f9 85       	ldd	r31, Y+9	; 0x09
    3704:	80 81       	ld	r24, Z
    3706:	91 81       	ldd	r25, Z+1	; 0x01
    3708:	2f ef       	ldi	r18, 0xFF	; 255
    370a:	8f 3f       	cpi	r24, 0xFF	; 255
    370c:	92 07       	cpc	r25, r18
    370e:	11 f4       	brne	.+4      	; 0x3714 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3710:	1d 82       	std	Y+5, r1	; 0x05
    3712:	36 c0       	rjmp	.+108    	; 0x3780 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3714:	ee 81       	ldd	r30, Y+6	; 0x06
    3716:	ff 81       	ldd	r31, Y+7	; 0x07
    3718:	90 81       	ld	r25, Z
    371a:	80 91 65 04 	lds	r24, 0x0465
    371e:	98 17       	cp	r25, r24
    3720:	61 f0       	breq	.+24     	; 0x373a <xTaskCheckForTimeOut+0x7c>
    3722:	ee 81       	ldd	r30, Y+6	; 0x06
    3724:	ff 81       	ldd	r31, Y+7	; 0x07
    3726:	21 81       	ldd	r18, Z+1	; 0x01
    3728:	32 81       	ldd	r19, Z+2	; 0x02
    372a:	8b 81       	ldd	r24, Y+3	; 0x03
    372c:	9c 81       	ldd	r25, Y+4	; 0x04
    372e:	82 17       	cp	r24, r18
    3730:	93 07       	cpc	r25, r19
    3732:	18 f0       	brcs	.+6      	; 0x373a <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3734:	81 e0       	ldi	r24, 0x01	; 1
    3736:	8d 83       	std	Y+5, r24	; 0x05
    3738:	23 c0       	rjmp	.+70     	; 0x3780 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    373a:	e8 85       	ldd	r30, Y+8	; 0x08
    373c:	f9 85       	ldd	r31, Y+9	; 0x09
    373e:	20 81       	ld	r18, Z
    3740:	31 81       	ldd	r19, Z+1	; 0x01
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	9a 81       	ldd	r25, Y+2	; 0x02
    3746:	82 17       	cp	r24, r18
    3748:	93 07       	cpc	r25, r19
    374a:	a0 f4       	brcc	.+40     	; 0x3774 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    374c:	e8 85       	ldd	r30, Y+8	; 0x08
    374e:	f9 85       	ldd	r31, Y+9	; 0x09
    3750:	20 81       	ld	r18, Z
    3752:	31 81       	ldd	r19, Z+1	; 0x01
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	9a 81       	ldd	r25, Y+2	; 0x02
    3758:	a9 01       	movw	r20, r18
    375a:	48 1b       	sub	r20, r24
    375c:	59 0b       	sbc	r21, r25
    375e:	ca 01       	movw	r24, r20
    3760:	e8 85       	ldd	r30, Y+8	; 0x08
    3762:	f9 85       	ldd	r31, Y+9	; 0x09
    3764:	91 83       	std	Z+1, r25	; 0x01
    3766:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3768:	8e 81       	ldd	r24, Y+6	; 0x06
    376a:	9f 81       	ldd	r25, Y+7	; 0x07
    376c:	0e 94 46 1b 	call	0x368c	; 0x368c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3770:	1d 82       	std	Y+5, r1	; 0x05
    3772:	06 c0       	rjmp	.+12     	; 0x3780 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    3774:	e8 85       	ldd	r30, Y+8	; 0x08
    3776:	f9 85       	ldd	r31, Y+9	; 0x09
    3778:	11 82       	std	Z+1, r1	; 0x01
    377a:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    377c:	81 e0       	ldi	r24, 0x01	; 1
    377e:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3780:	0f 90       	pop	r0
    3782:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3784:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3786:	29 96       	adiw	r28, 0x09	; 9
    3788:	0f b6       	in	r0, 0x3f	; 63
    378a:	f8 94       	cli
    378c:	de bf       	out	0x3e, r29	; 62
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	cd bf       	out	0x3d, r28	; 61
    3792:	cf 91       	pop	r28
    3794:	df 91       	pop	r29
    3796:	08 95       	ret

00003798 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3798:	df 93       	push	r29
    379a:	cf 93       	push	r28
    379c:	cd b7       	in	r28, 0x3d	; 61
    379e:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    37a0:	81 e0       	ldi	r24, 0x01	; 1
    37a2:	80 93 64 04 	sts	0x0464, r24
}
    37a6:	cf 91       	pop	r28
    37a8:	df 91       	pop	r29
    37aa:	08 95       	ret

000037ac <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    37ac:	df 93       	push	r29
    37ae:	cf 93       	push	r28
    37b0:	00 d0       	rcall	.+0      	; 0x37b2 <prvIdleTask+0x6>
    37b2:	cd b7       	in	r28, 0x3d	; 61
    37b4:	de b7       	in	r29, 0x3e	; 62
    37b6:	9a 83       	std	Y+2, r25	; 0x02
    37b8:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    37ba:	0e 94 21 1c 	call	0x3842	; 0x3842 <prvCheckTasksWaitingTermination>
    37be:	fd cf       	rjmp	.-6      	; 0x37ba <prvIdleTask+0xe>

000037c0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    37c0:	df 93       	push	r29
    37c2:	cf 93       	push	r28
    37c4:	0f 92       	push	r0
    37c6:	cd b7       	in	r28, 0x3d	; 61
    37c8:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    37ca:	19 82       	std	Y+1, r1	; 0x01
    37cc:	13 c0       	rjmp	.+38     	; 0x37f4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    37ce:	89 81       	ldd	r24, Y+1	; 0x01
    37d0:	28 2f       	mov	r18, r24
    37d2:	30 e0       	ldi	r19, 0x00	; 0
    37d4:	c9 01       	movw	r24, r18
    37d6:	88 0f       	add	r24, r24
    37d8:	99 1f       	adc	r25, r25
    37da:	88 0f       	add	r24, r24
    37dc:	99 1f       	adc	r25, r25
    37de:	88 0f       	add	r24, r24
    37e0:	99 1f       	adc	r25, r25
    37e2:	82 0f       	add	r24, r18
    37e4:	93 1f       	adc	r25, r19
    37e6:	84 59       	subi	r24, 0x94	; 148
    37e8:	9b 4f       	sbci	r25, 0xFB	; 251
    37ea:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    37ee:	89 81       	ldd	r24, Y+1	; 0x01
    37f0:	8f 5f       	subi	r24, 0xFF	; 255
    37f2:	89 83       	std	Y+1, r24	; 0x01
    37f4:	89 81       	ldd	r24, Y+1	; 0x01
    37f6:	85 30       	cpi	r24, 0x05	; 5
    37f8:	50 f3       	brcs	.-44     	; 0x37ce <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    37fa:	89 e9       	ldi	r24, 0x99	; 153
    37fc:	94 e0       	ldi	r25, 0x04	; 4
    37fe:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3802:	82 ea       	ldi	r24, 0xA2	; 162
    3804:	94 e0       	ldi	r25, 0x04	; 4
    3806:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    380a:	8f ea       	ldi	r24, 0xAF	; 175
    380c:	94 e0       	ldi	r25, 0x04	; 4
    380e:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3812:	88 eb       	ldi	r24, 0xB8	; 184
    3814:	94 e0       	ldi	r25, 0x04	; 4
    3816:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    381a:	81 ec       	ldi	r24, 0xC1	; 193
    381c:	94 e0       	ldi	r25, 0x04	; 4
    381e:	0e 94 cb 06 	call	0xd96	; 0xd96 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3822:	89 e9       	ldi	r24, 0x99	; 153
    3824:	94 e0       	ldi	r25, 0x04	; 4
    3826:	90 93 ac 04 	sts	0x04AC, r25
    382a:	80 93 ab 04 	sts	0x04AB, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    382e:	82 ea       	ldi	r24, 0xA2	; 162
    3830:	94 e0       	ldi	r25, 0x04	; 4
    3832:	90 93 ae 04 	sts	0x04AE, r25
    3836:	80 93 ad 04 	sts	0x04AD, r24
}
    383a:	0f 90       	pop	r0
    383c:	cf 91       	pop	r28
    383e:	df 91       	pop	r29
    3840:	08 95       	ret

00003842 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3842:	df 93       	push	r29
    3844:	cf 93       	push	r28
    3846:	00 d0       	rcall	.+0      	; 0x3848 <prvCheckTasksWaitingTermination+0x6>
    3848:	cd b7       	in	r28, 0x3d	; 61
    384a:	de b7       	in	r29, 0x3e	; 62
    384c:	20 c0       	rjmp	.+64     	; 0x388e <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    384e:	0f b6       	in	r0, 0x3f	; 63
    3850:	f8 94       	cli
    3852:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3854:	e0 91 bd 04 	lds	r30, 0x04BD
    3858:	f0 91 be 04 	lds	r31, 0x04BE
    385c:	86 81       	ldd	r24, Z+6	; 0x06
    385e:	97 81       	ldd	r25, Z+7	; 0x07
    3860:	9a 83       	std	Y+2, r25	; 0x02
    3862:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3864:	89 81       	ldd	r24, Y+1	; 0x01
    3866:	9a 81       	ldd	r25, Y+2	; 0x02
    3868:	02 96       	adiw	r24, 0x02	; 2
    386a:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
				--uxCurrentNumberOfTasks;
    386e:	80 91 5d 04 	lds	r24, 0x045D
    3872:	81 50       	subi	r24, 0x01	; 1
    3874:	80 93 5d 04 	sts	0x045D, r24
				--uxDeletedTasksWaitingCleanUp;
    3878:	80 91 5c 04 	lds	r24, 0x045C
    387c:	81 50       	subi	r24, 0x01	; 1
    387e:	80 93 5c 04 	sts	0x045C, r24
			}
			taskEXIT_CRITICAL();
    3882:	0f 90       	pop	r0
    3884:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    3886:	89 81       	ldd	r24, Y+1	; 0x01
    3888:	9a 81       	ldd	r25, Y+2	; 0x02
    388a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    388e:	80 91 5c 04 	lds	r24, 0x045C
    3892:	88 23       	and	r24, r24
    3894:	e1 f6       	brne	.-72     	; 0x384e <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3896:	0f 90       	pop	r0
    3898:	0f 90       	pop	r0
    389a:	cf 91       	pop	r28
    389c:	df 91       	pop	r29
    389e:	08 95       	ret

000038a0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    38a0:	df 93       	push	r29
    38a2:	cf 93       	push	r28
    38a4:	00 d0       	rcall	.+0      	; 0x38a6 <prvDeleteTCB+0x6>
    38a6:	cd b7       	in	r28, 0x3d	; 61
    38a8:	de b7       	in	r29, 0x3e	; 62
    38aa:	9a 83       	std	Y+2, r25	; 0x02
    38ac:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    38ae:	e9 81       	ldd	r30, Y+1	; 0x01
    38b0:	fa 81       	ldd	r31, Y+2	; 0x02
    38b2:	87 89       	ldd	r24, Z+23	; 0x17
    38b4:	90 8d       	ldd	r25, Z+24	; 0x18
    38b6:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vPortFree>
			vPortFree( pxTCB );
    38ba:	89 81       	ldd	r24, Y+1	; 0x01
    38bc:	9a 81       	ldd	r25, Y+2	; 0x02
    38be:	0e 94 a5 06 	call	0xd4a	; 0xd4a <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    38c2:	0f 90       	pop	r0
    38c4:	0f 90       	pop	r0
    38c6:	cf 91       	pop	r28
    38c8:	df 91       	pop	r29
    38ca:	08 95       	ret

000038cc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    38cc:	df 93       	push	r29
    38ce:	cf 93       	push	r28
    38d0:	00 d0       	rcall	.+0      	; 0x38d2 <prvResetNextTaskUnblockTime+0x6>
    38d2:	cd b7       	in	r28, 0x3d	; 61
    38d4:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    38d6:	e0 91 ab 04 	lds	r30, 0x04AB
    38da:	f0 91 ac 04 	lds	r31, 0x04AC
    38de:	80 81       	ld	r24, Z
    38e0:	88 23       	and	r24, r24
    38e2:	39 f4       	brne	.+14     	; 0x38f2 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    38e4:	8f ef       	ldi	r24, 0xFF	; 255
    38e6:	9f ef       	ldi	r25, 0xFF	; 255
    38e8:	90 93 68 04 	sts	0x0468, r25
    38ec:	80 93 67 04 	sts	0x0467, r24
    38f0:	13 c0       	rjmp	.+38     	; 0x3918 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38f2:	e0 91 ab 04 	lds	r30, 0x04AB
    38f6:	f0 91 ac 04 	lds	r31, 0x04AC
    38fa:	05 80       	ldd	r0, Z+5	; 0x05
    38fc:	f6 81       	ldd	r31, Z+6	; 0x06
    38fe:	e0 2d       	mov	r30, r0
    3900:	86 81       	ldd	r24, Z+6	; 0x06
    3902:	97 81       	ldd	r25, Z+7	; 0x07
    3904:	9a 83       	std	Y+2, r25	; 0x02
    3906:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3908:	e9 81       	ldd	r30, Y+1	; 0x01
    390a:	fa 81       	ldd	r31, Y+2	; 0x02
    390c:	82 81       	ldd	r24, Z+2	; 0x02
    390e:	93 81       	ldd	r25, Z+3	; 0x03
    3910:	90 93 68 04 	sts	0x0468, r25
    3914:	80 93 67 04 	sts	0x0467, r24
	}
}
    3918:	0f 90       	pop	r0
    391a:	0f 90       	pop	r0
    391c:	cf 91       	pop	r28
    391e:	df 91       	pop	r29
    3920:	08 95       	ret

00003922 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3922:	df 93       	push	r29
    3924:	cf 93       	push	r28
    3926:	00 d0       	rcall	.+0      	; 0x3928 <uxTaskResetEventItemValue+0x6>
    3928:	cd b7       	in	r28, 0x3d	; 61
    392a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    392c:	e0 91 5a 04 	lds	r30, 0x045A
    3930:	f0 91 5b 04 	lds	r31, 0x045B
    3934:	84 85       	ldd	r24, Z+12	; 0x0c
    3936:	95 85       	ldd	r25, Z+13	; 0x0d
    3938:	9a 83       	std	Y+2, r25	; 0x02
    393a:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    393c:	a0 91 5a 04 	lds	r26, 0x045A
    3940:	b0 91 5b 04 	lds	r27, 0x045B
    3944:	e0 91 5a 04 	lds	r30, 0x045A
    3948:	f0 91 5b 04 	lds	r31, 0x045B
    394c:	86 89       	ldd	r24, Z+22	; 0x16
    394e:	28 2f       	mov	r18, r24
    3950:	30 e0       	ldi	r19, 0x00	; 0
    3952:	85 e0       	ldi	r24, 0x05	; 5
    3954:	90 e0       	ldi	r25, 0x00	; 0
    3956:	82 1b       	sub	r24, r18
    3958:	93 0b       	sbc	r25, r19
    395a:	1d 96       	adiw	r26, 0x0d	; 13
    395c:	9c 93       	st	X, r25
    395e:	8e 93       	st	-X, r24
    3960:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3962:	89 81       	ldd	r24, Y+1	; 0x01
    3964:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3966:	0f 90       	pop	r0
    3968:	0f 90       	pop	r0
    396a:	cf 91       	pop	r28
    396c:	df 91       	pop	r29
    396e:	08 95       	ret

00003970 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3970:	df 93       	push	r29
    3972:	cf 93       	push	r28
    3974:	cd b7       	in	r28, 0x3d	; 61
    3976:	de b7       	in	r29, 0x3e	; 62
    3978:	27 97       	sbiw	r28, 0x07	; 7
    397a:	0f b6       	in	r0, 0x3f	; 63
    397c:	f8 94       	cli
    397e:	de bf       	out	0x3e, r29	; 62
    3980:	0f be       	out	0x3f, r0	; 63
    3982:	cd bf       	out	0x3d, r28	; 61
    3984:	8d 83       	std	Y+5, r24	; 0x05
    3986:	7f 83       	std	Y+7, r23	; 0x07
    3988:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    398a:	0f b6       	in	r0, 0x3f	; 63
    398c:	f8 94       	cli
    398e:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3990:	e0 91 5a 04 	lds	r30, 0x045A
    3994:	f0 91 5b 04 	lds	r31, 0x045B
    3998:	81 a1       	ldd	r24, Z+33	; 0x21
    399a:	92 a1       	ldd	r25, Z+34	; 0x22
    399c:	a3 a1       	ldd	r26, Z+35	; 0x23
    399e:	b4 a1       	ldd	r27, Z+36	; 0x24
    39a0:	00 97       	sbiw	r24, 0x00	; 0
    39a2:	a1 05       	cpc	r26, r1
    39a4:	b1 05       	cpc	r27, r1
    39a6:	89 f4       	brne	.+34     	; 0x39ca <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    39a8:	e0 91 5a 04 	lds	r30, 0x045A
    39ac:	f0 91 5b 04 	lds	r31, 0x045B
    39b0:	81 e0       	ldi	r24, 0x01	; 1
    39b2:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    39b4:	8e 81       	ldd	r24, Y+6	; 0x06
    39b6:	9f 81       	ldd	r25, Y+7	; 0x07
    39b8:	00 97       	sbiw	r24, 0x00	; 0
    39ba:	39 f0       	breq	.+14     	; 0x39ca <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    39bc:	8e 81       	ldd	r24, Y+6	; 0x06
    39be:	9f 81       	ldd	r25, Y+7	; 0x07
    39c0:	61 e0       	ldi	r22, 0x01	; 1
    39c2:	0e 94 bb 20 	call	0x4176	; 0x4176 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    39c6:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    39ca:	0f 90       	pop	r0
    39cc:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    39ce:	0f b6       	in	r0, 0x3f	; 63
    39d0:	f8 94       	cli
    39d2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    39d4:	e0 91 5a 04 	lds	r30, 0x045A
    39d8:	f0 91 5b 04 	lds	r31, 0x045B
    39dc:	81 a1       	ldd	r24, Z+33	; 0x21
    39de:	92 a1       	ldd	r25, Z+34	; 0x22
    39e0:	a3 a1       	ldd	r26, Z+35	; 0x23
    39e2:	b4 a1       	ldd	r27, Z+36	; 0x24
    39e4:	89 83       	std	Y+1, r24	; 0x01
    39e6:	9a 83       	std	Y+2, r25	; 0x02
    39e8:	ab 83       	std	Y+3, r26	; 0x03
    39ea:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    39ec:	89 81       	ldd	r24, Y+1	; 0x01
    39ee:	9a 81       	ldd	r25, Y+2	; 0x02
    39f0:	ab 81       	ldd	r26, Y+3	; 0x03
    39f2:	bc 81       	ldd	r27, Y+4	; 0x04
    39f4:	00 97       	sbiw	r24, 0x00	; 0
    39f6:	a1 05       	cpc	r26, r1
    39f8:	b1 05       	cpc	r27, r1
    39fa:	d9 f0       	breq	.+54     	; 0x3a32 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    39fc:	8d 81       	ldd	r24, Y+5	; 0x05
    39fe:	88 23       	and	r24, r24
    3a00:	49 f0       	breq	.+18     	; 0x3a14 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3a02:	e0 91 5a 04 	lds	r30, 0x045A
    3a06:	f0 91 5b 04 	lds	r31, 0x045B
    3a0a:	11 a2       	std	Z+33, r1	; 0x21
    3a0c:	12 a2       	std	Z+34, r1	; 0x22
    3a0e:	13 a2       	std	Z+35, r1	; 0x23
    3a10:	14 a2       	std	Z+36, r1	; 0x24
    3a12:	0f c0       	rjmp	.+30     	; 0x3a32 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    3a14:	e0 91 5a 04 	lds	r30, 0x045A
    3a18:	f0 91 5b 04 	lds	r31, 0x045B
    3a1c:	89 81       	ldd	r24, Y+1	; 0x01
    3a1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a20:	ab 81       	ldd	r26, Y+3	; 0x03
    3a22:	bc 81       	ldd	r27, Y+4	; 0x04
    3a24:	01 97       	sbiw	r24, 0x01	; 1
    3a26:	a1 09       	sbc	r26, r1
    3a28:	b1 09       	sbc	r27, r1
    3a2a:	81 a3       	std	Z+33, r24	; 0x21
    3a2c:	92 a3       	std	Z+34, r25	; 0x22
    3a2e:	a3 a3       	std	Z+35, r26	; 0x23
    3a30:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3a32:	e0 91 5a 04 	lds	r30, 0x045A
    3a36:	f0 91 5b 04 	lds	r31, 0x045B
    3a3a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3a3c:	0f 90       	pop	r0
    3a3e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3a40:	89 81       	ldd	r24, Y+1	; 0x01
    3a42:	9a 81       	ldd	r25, Y+2	; 0x02
    3a44:	ab 81       	ldd	r26, Y+3	; 0x03
    3a46:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3a48:	bc 01       	movw	r22, r24
    3a4a:	cd 01       	movw	r24, r26
    3a4c:	27 96       	adiw	r28, 0x07	; 7
    3a4e:	0f b6       	in	r0, 0x3f	; 63
    3a50:	f8 94       	cli
    3a52:	de bf       	out	0x3e, r29	; 62
    3a54:	0f be       	out	0x3f, r0	; 63
    3a56:	cd bf       	out	0x3d, r28	; 61
    3a58:	cf 91       	pop	r28
    3a5a:	df 91       	pop	r29
    3a5c:	08 95       	ret

00003a5e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3a5e:	ef 92       	push	r14
    3a60:	ff 92       	push	r15
    3a62:	0f 93       	push	r16
    3a64:	1f 93       	push	r17
    3a66:	df 93       	push	r29
    3a68:	cf 93       	push	r28
    3a6a:	cd b7       	in	r28, 0x3d	; 61
    3a6c:	de b7       	in	r29, 0x3e	; 62
    3a6e:	2d 97       	sbiw	r28, 0x0d	; 13
    3a70:	0f b6       	in	r0, 0x3f	; 63
    3a72:	f8 94       	cli
    3a74:	de bf       	out	0x3e, r29	; 62
    3a76:	0f be       	out	0x3f, r0	; 63
    3a78:	cd bf       	out	0x3d, r28	; 61
    3a7a:	6a 83       	std	Y+2, r22	; 0x02
    3a7c:	7b 83       	std	Y+3, r23	; 0x03
    3a7e:	8c 83       	std	Y+4, r24	; 0x04
    3a80:	9d 83       	std	Y+5, r25	; 0x05
    3a82:	2e 83       	std	Y+6, r18	; 0x06
    3a84:	3f 83       	std	Y+7, r19	; 0x07
    3a86:	48 87       	std	Y+8, r20	; 0x08
    3a88:	59 87       	std	Y+9, r21	; 0x09
    3a8a:	1b 87       	std	Y+11, r17	; 0x0b
    3a8c:	0a 87       	std	Y+10, r16	; 0x0a
    3a8e:	fd 86       	std	Y+13, r15	; 0x0d
    3a90:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3a92:	0f b6       	in	r0, 0x3f	; 63
    3a94:	f8 94       	cli
    3a96:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3a98:	e0 91 5a 04 	lds	r30, 0x045A
    3a9c:	f0 91 5b 04 	lds	r31, 0x045B
    3aa0:	85 a1       	ldd	r24, Z+37	; 0x25
    3aa2:	82 30       	cpi	r24, 0x02	; 2
    3aa4:	49 f1       	breq	.+82     	; 0x3af8 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3aa6:	e0 91 5a 04 	lds	r30, 0x045A
    3aaa:	f0 91 5b 04 	lds	r31, 0x045B
    3aae:	21 a1       	ldd	r18, Z+33	; 0x21
    3ab0:	32 a1       	ldd	r19, Z+34	; 0x22
    3ab2:	43 a1       	ldd	r20, Z+35	; 0x23
    3ab4:	54 a1       	ldd	r21, Z+36	; 0x24
    3ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ab8:	9b 81       	ldd	r25, Y+3	; 0x03
    3aba:	ac 81       	ldd	r26, Y+4	; 0x04
    3abc:	bd 81       	ldd	r27, Y+5	; 0x05
    3abe:	80 95       	com	r24
    3ac0:	90 95       	com	r25
    3ac2:	a0 95       	com	r26
    3ac4:	b0 95       	com	r27
    3ac6:	82 23       	and	r24, r18
    3ac8:	93 23       	and	r25, r19
    3aca:	a4 23       	and	r26, r20
    3acc:	b5 23       	and	r27, r21
    3ace:	81 a3       	std	Z+33, r24	; 0x21
    3ad0:	92 a3       	std	Z+34, r25	; 0x22
    3ad2:	a3 a3       	std	Z+35, r26	; 0x23
    3ad4:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3ad6:	e0 91 5a 04 	lds	r30, 0x045A
    3ada:	f0 91 5b 04 	lds	r31, 0x045B
    3ade:	81 e0       	ldi	r24, 0x01	; 1
    3ae0:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3ae2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ae4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ae6:	00 97       	sbiw	r24, 0x00	; 0
    3ae8:	39 f0       	breq	.+14     	; 0x3af8 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3aea:	8c 85       	ldd	r24, Y+12	; 0x0c
    3aec:	9d 85       	ldd	r25, Y+13	; 0x0d
    3aee:	61 e0       	ldi	r22, 0x01	; 1
    3af0:	0e 94 bb 20 	call	0x4176	; 0x4176 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3af4:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3af8:	0f 90       	pop	r0
    3afa:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3afc:	0f b6       	in	r0, 0x3f	; 63
    3afe:	f8 94       	cli
    3b00:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3b02:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b04:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b06:	00 97       	sbiw	r24, 0x00	; 0
    3b08:	71 f0       	breq	.+28     	; 0x3b26 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3b0a:	e0 91 5a 04 	lds	r30, 0x045A
    3b0e:	f0 91 5b 04 	lds	r31, 0x045B
    3b12:	81 a1       	ldd	r24, Z+33	; 0x21
    3b14:	92 a1       	ldd	r25, Z+34	; 0x22
    3b16:	a3 a1       	ldd	r26, Z+35	; 0x23
    3b18:	b4 a1       	ldd	r27, Z+36	; 0x24
    3b1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3b1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3b1e:	80 83       	st	Z, r24
    3b20:	91 83       	std	Z+1, r25	; 0x01
    3b22:	a2 83       	std	Z+2, r26	; 0x02
    3b24:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3b26:	e0 91 5a 04 	lds	r30, 0x045A
    3b2a:	f0 91 5b 04 	lds	r31, 0x045B
    3b2e:	85 a1       	ldd	r24, Z+37	; 0x25
    3b30:	82 30       	cpi	r24, 0x02	; 2
    3b32:	11 f0       	breq	.+4      	; 0x3b38 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3b34:	19 82       	std	Y+1, r1	; 0x01
    3b36:	1a c0       	rjmp	.+52     	; 0x3b6c <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3b38:	e0 91 5a 04 	lds	r30, 0x045A
    3b3c:	f0 91 5b 04 	lds	r31, 0x045B
    3b40:	21 a1       	ldd	r18, Z+33	; 0x21
    3b42:	32 a1       	ldd	r19, Z+34	; 0x22
    3b44:	43 a1       	ldd	r20, Z+35	; 0x23
    3b46:	54 a1       	ldd	r21, Z+36	; 0x24
    3b48:	8e 81       	ldd	r24, Y+6	; 0x06
    3b4a:	9f 81       	ldd	r25, Y+7	; 0x07
    3b4c:	a8 85       	ldd	r26, Y+8	; 0x08
    3b4e:	b9 85       	ldd	r27, Y+9	; 0x09
    3b50:	80 95       	com	r24
    3b52:	90 95       	com	r25
    3b54:	a0 95       	com	r26
    3b56:	b0 95       	com	r27
    3b58:	82 23       	and	r24, r18
    3b5a:	93 23       	and	r25, r19
    3b5c:	a4 23       	and	r26, r20
    3b5e:	b5 23       	and	r27, r21
    3b60:	81 a3       	std	Z+33, r24	; 0x21
    3b62:	92 a3       	std	Z+34, r25	; 0x22
    3b64:	a3 a3       	std	Z+35, r26	; 0x23
    3b66:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3b68:	81 e0       	ldi	r24, 0x01	; 1
    3b6a:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3b6c:	e0 91 5a 04 	lds	r30, 0x045A
    3b70:	f0 91 5b 04 	lds	r31, 0x045B
    3b74:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3b76:	0f 90       	pop	r0
    3b78:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3b7c:	2d 96       	adiw	r28, 0x0d	; 13
    3b7e:	0f b6       	in	r0, 0x3f	; 63
    3b80:	f8 94       	cli
    3b82:	de bf       	out	0x3e, r29	; 62
    3b84:	0f be       	out	0x3f, r0	; 63
    3b86:	cd bf       	out	0x3d, r28	; 61
    3b88:	cf 91       	pop	r28
    3b8a:	df 91       	pop	r29
    3b8c:	1f 91       	pop	r17
    3b8e:	0f 91       	pop	r16
    3b90:	ff 90       	pop	r15
    3b92:	ef 90       	pop	r14
    3b94:	08 95       	ret

00003b96 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3b96:	0f 93       	push	r16
    3b98:	1f 93       	push	r17
    3b9a:	df 93       	push	r29
    3b9c:	cf 93       	push	r28
    3b9e:	cd b7       	in	r28, 0x3d	; 61
    3ba0:	de b7       	in	r29, 0x3e	; 62
    3ba2:	2f 97       	sbiw	r28, 0x0f	; 15
    3ba4:	0f b6       	in	r0, 0x3f	; 63
    3ba6:	f8 94       	cli
    3ba8:	de bf       	out	0x3e, r29	; 62
    3baa:	0f be       	out	0x3f, r0	; 63
    3bac:	cd bf       	out	0x3d, r28	; 61
    3bae:	9e 83       	std	Y+6, r25	; 0x06
    3bb0:	8d 83       	std	Y+5, r24	; 0x05
    3bb2:	4f 83       	std	Y+7, r20	; 0x07
    3bb4:	58 87       	std	Y+8, r21	; 0x08
    3bb6:	69 87       	std	Y+9, r22	; 0x09
    3bb8:	7a 87       	std	Y+10, r23	; 0x0a
    3bba:	2b 87       	std	Y+11, r18	; 0x0b
    3bbc:	1d 87       	std	Y+13, r17	; 0x0d
    3bbe:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    3bc0:	81 e0       	ldi	r24, 0x01	; 1
    3bc2:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    3bc4:	8d 81       	ldd	r24, Y+5	; 0x05
    3bc6:	9e 81       	ldd	r25, Y+6	; 0x06
    3bc8:	9c 83       	std	Y+4, r25	; 0x04
    3bca:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    3bcc:	0f b6       	in	r0, 0x3f	; 63
    3bce:	f8 94       	cli
    3bd0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    3bd2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3bd4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3bd6:	00 97       	sbiw	r24, 0x00	; 0
    3bd8:	61 f0       	breq	.+24     	; 0x3bf2 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3bda:	eb 81       	ldd	r30, Y+3	; 0x03
    3bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bde:	81 a1       	ldd	r24, Z+33	; 0x21
    3be0:	92 a1       	ldd	r25, Z+34	; 0x22
    3be2:	a3 a1       	ldd	r26, Z+35	; 0x23
    3be4:	b4 a1       	ldd	r27, Z+36	; 0x24
    3be6:	ec 85       	ldd	r30, Y+12	; 0x0c
    3be8:	fd 85       	ldd	r31, Y+13	; 0x0d
    3bea:	80 83       	st	Z, r24
    3bec:	91 83       	std	Z+1, r25	; 0x01
    3bee:	a2 83       	std	Z+2, r26	; 0x02
    3bf0:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3bf2:	eb 81       	ldd	r30, Y+3	; 0x03
    3bf4:	fc 81       	ldd	r31, Y+4	; 0x04
    3bf6:	85 a1       	ldd	r24, Z+37	; 0x25
    3bf8:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bfe:	82 e0       	ldi	r24, 0x02	; 2
    3c00:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3c02:	8b 85       	ldd	r24, Y+11	; 0x0b
    3c04:	28 2f       	mov	r18, r24
    3c06:	30 e0       	ldi	r19, 0x00	; 0
    3c08:	3f 87       	std	Y+15, r19	; 0x0f
    3c0a:	2e 87       	std	Y+14, r18	; 0x0e
    3c0c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c0e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c10:	82 30       	cpi	r24, 0x02	; 2
    3c12:	91 05       	cpc	r25, r1
    3c14:	59 f1       	breq	.+86     	; 0x3c6c <xTaskGenericNotify+0xd6>
    3c16:	2e 85       	ldd	r18, Y+14	; 0x0e
    3c18:	3f 85       	ldd	r19, Y+15	; 0x0f
    3c1a:	23 30       	cpi	r18, 0x03	; 3
    3c1c:	31 05       	cpc	r19, r1
    3c1e:	34 f4       	brge	.+12     	; 0x3c2c <xTaskGenericNotify+0x96>
    3c20:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c22:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c24:	81 30       	cpi	r24, 0x01	; 1
    3c26:	91 05       	cpc	r25, r1
    3c28:	61 f0       	breq	.+24     	; 0x3c42 <xTaskGenericNotify+0xac>
    3c2a:	4a c0       	rjmp	.+148    	; 0x3cc0 <xTaskGenericNotify+0x12a>
    3c2c:	2e 85       	ldd	r18, Y+14	; 0x0e
    3c2e:	3f 85       	ldd	r19, Y+15	; 0x0f
    3c30:	23 30       	cpi	r18, 0x03	; 3
    3c32:	31 05       	cpc	r19, r1
    3c34:	59 f1       	breq	.+86     	; 0x3c8c <xTaskGenericNotify+0xf6>
    3c36:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c38:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c3a:	84 30       	cpi	r24, 0x04	; 4
    3c3c:	91 05       	cpc	r25, r1
    3c3e:	89 f1       	breq	.+98     	; 0x3ca2 <xTaskGenericNotify+0x10c>
    3c40:	3f c0       	rjmp	.+126    	; 0x3cc0 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3c42:	eb 81       	ldd	r30, Y+3	; 0x03
    3c44:	fc 81       	ldd	r31, Y+4	; 0x04
    3c46:	21 a1       	ldd	r18, Z+33	; 0x21
    3c48:	32 a1       	ldd	r19, Z+34	; 0x22
    3c4a:	43 a1       	ldd	r20, Z+35	; 0x23
    3c4c:	54 a1       	ldd	r21, Z+36	; 0x24
    3c4e:	8f 81       	ldd	r24, Y+7	; 0x07
    3c50:	98 85       	ldd	r25, Y+8	; 0x08
    3c52:	a9 85       	ldd	r26, Y+9	; 0x09
    3c54:	ba 85       	ldd	r27, Y+10	; 0x0a
    3c56:	82 2b       	or	r24, r18
    3c58:	93 2b       	or	r25, r19
    3c5a:	a4 2b       	or	r26, r20
    3c5c:	b5 2b       	or	r27, r21
    3c5e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c60:	fc 81       	ldd	r31, Y+4	; 0x04
    3c62:	81 a3       	std	Z+33, r24	; 0x21
    3c64:	92 a3       	std	Z+34, r25	; 0x22
    3c66:	a3 a3       	std	Z+35, r26	; 0x23
    3c68:	b4 a3       	std	Z+36, r27	; 0x24
    3c6a:	2a c0       	rjmp	.+84     	; 0x3cc0 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3c6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c70:	81 a1       	ldd	r24, Z+33	; 0x21
    3c72:	92 a1       	ldd	r25, Z+34	; 0x22
    3c74:	a3 a1       	ldd	r26, Z+35	; 0x23
    3c76:	b4 a1       	ldd	r27, Z+36	; 0x24
    3c78:	01 96       	adiw	r24, 0x01	; 1
    3c7a:	a1 1d       	adc	r26, r1
    3c7c:	b1 1d       	adc	r27, r1
    3c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c80:	fc 81       	ldd	r31, Y+4	; 0x04
    3c82:	81 a3       	std	Z+33, r24	; 0x21
    3c84:	92 a3       	std	Z+34, r25	; 0x22
    3c86:	a3 a3       	std	Z+35, r26	; 0x23
    3c88:	b4 a3       	std	Z+36, r27	; 0x24
    3c8a:	1a c0       	rjmp	.+52     	; 0x3cc0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3c8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c90:	8f 81       	ldd	r24, Y+7	; 0x07
    3c92:	98 85       	ldd	r25, Y+8	; 0x08
    3c94:	a9 85       	ldd	r26, Y+9	; 0x09
    3c96:	ba 85       	ldd	r27, Y+10	; 0x0a
    3c98:	81 a3       	std	Z+33, r24	; 0x21
    3c9a:	92 a3       	std	Z+34, r25	; 0x22
    3c9c:	a3 a3       	std	Z+35, r26	; 0x23
    3c9e:	b4 a3       	std	Z+36, r27	; 0x24
    3ca0:	0f c0       	rjmp	.+30     	; 0x3cc0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3ca2:	89 81       	ldd	r24, Y+1	; 0x01
    3ca4:	82 30       	cpi	r24, 0x02	; 2
    3ca6:	59 f0       	breq	.+22     	; 0x3cbe <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    3caa:	fc 81       	ldd	r31, Y+4	; 0x04
    3cac:	8f 81       	ldd	r24, Y+7	; 0x07
    3cae:	98 85       	ldd	r25, Y+8	; 0x08
    3cb0:	a9 85       	ldd	r26, Y+9	; 0x09
    3cb2:	ba 85       	ldd	r27, Y+10	; 0x0a
    3cb4:	81 a3       	std	Z+33, r24	; 0x21
    3cb6:	92 a3       	std	Z+34, r25	; 0x22
    3cb8:	a3 a3       	std	Z+35, r26	; 0x23
    3cba:	b4 a3       	std	Z+36, r27	; 0x24
    3cbc:	01 c0       	rjmp	.+2      	; 0x3cc0 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3cbe:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	81 30       	cpi	r24, 0x01	; 1
    3cc4:	b9 f5       	brne	.+110    	; 0x3d34 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cca:	02 96       	adiw	r24, 0x02	; 2
    3ccc:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    3cd0:	eb 81       	ldd	r30, Y+3	; 0x03
    3cd2:	fc 81       	ldd	r31, Y+4	; 0x04
    3cd4:	96 89       	ldd	r25, Z+22	; 0x16
    3cd6:	80 91 60 04 	lds	r24, 0x0460
    3cda:	89 17       	cp	r24, r25
    3cdc:	28 f4       	brcc	.+10     	; 0x3ce8 <xTaskGenericNotify+0x152>
    3cde:	eb 81       	ldd	r30, Y+3	; 0x03
    3ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ce2:	86 89       	ldd	r24, Z+22	; 0x16
    3ce4:	80 93 60 04 	sts	0x0460, r24
    3ce8:	eb 81       	ldd	r30, Y+3	; 0x03
    3cea:	fc 81       	ldd	r31, Y+4	; 0x04
    3cec:	86 89       	ldd	r24, Z+22	; 0x16
    3cee:	28 2f       	mov	r18, r24
    3cf0:	30 e0       	ldi	r19, 0x00	; 0
    3cf2:	c9 01       	movw	r24, r18
    3cf4:	88 0f       	add	r24, r24
    3cf6:	99 1f       	adc	r25, r25
    3cf8:	88 0f       	add	r24, r24
    3cfa:	99 1f       	adc	r25, r25
    3cfc:	88 0f       	add	r24, r24
    3cfe:	99 1f       	adc	r25, r25
    3d00:	82 0f       	add	r24, r18
    3d02:	93 1f       	adc	r25, r19
    3d04:	ac 01       	movw	r20, r24
    3d06:	44 59       	subi	r20, 0x94	; 148
    3d08:	5b 4f       	sbci	r21, 0xFB	; 251
    3d0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0e:	9c 01       	movw	r18, r24
    3d10:	2e 5f       	subi	r18, 0xFE	; 254
    3d12:	3f 4f       	sbci	r19, 0xFF	; 255
    3d14:	ca 01       	movw	r24, r20
    3d16:	b9 01       	movw	r22, r18
    3d18:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d20:	96 89       	ldd	r25, Z+22	; 0x16
    3d22:	e0 91 5a 04 	lds	r30, 0x045A
    3d26:	f0 91 5b 04 	lds	r31, 0x045B
    3d2a:	86 89       	ldd	r24, Z+22	; 0x16
    3d2c:	89 17       	cp	r24, r25
    3d2e:	10 f4       	brcc	.+4      	; 0x3d34 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3d30:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3d34:	0f 90       	pop	r0
    3d36:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3d38:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3d3a:	2f 96       	adiw	r28, 0x0f	; 15
    3d3c:	0f b6       	in	r0, 0x3f	; 63
    3d3e:	f8 94       	cli
    3d40:	de bf       	out	0x3e, r29	; 62
    3d42:	0f be       	out	0x3f, r0	; 63
    3d44:	cd bf       	out	0x3d, r28	; 61
    3d46:	cf 91       	pop	r28
    3d48:	df 91       	pop	r29
    3d4a:	1f 91       	pop	r17
    3d4c:	0f 91       	pop	r16
    3d4e:	08 95       	ret

00003d50 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3d50:	ef 92       	push	r14
    3d52:	ff 92       	push	r15
    3d54:	0f 93       	push	r16
    3d56:	1f 93       	push	r17
    3d58:	df 93       	push	r29
    3d5a:	cf 93       	push	r28
    3d5c:	cd b7       	in	r28, 0x3d	; 61
    3d5e:	de b7       	in	r29, 0x3e	; 62
    3d60:	62 97       	sbiw	r28, 0x12	; 18
    3d62:	0f b6       	in	r0, 0x3f	; 63
    3d64:	f8 94       	cli
    3d66:	de bf       	out	0x3e, r29	; 62
    3d68:	0f be       	out	0x3f, r0	; 63
    3d6a:	cd bf       	out	0x3d, r28	; 61
    3d6c:	9f 83       	std	Y+7, r25	; 0x07
    3d6e:	8e 83       	std	Y+6, r24	; 0x06
    3d70:	48 87       	std	Y+8, r20	; 0x08
    3d72:	59 87       	std	Y+9, r21	; 0x09
    3d74:	6a 87       	std	Y+10, r22	; 0x0a
    3d76:	7b 87       	std	Y+11, r23	; 0x0b
    3d78:	2c 87       	std	Y+12, r18	; 0x0c
    3d7a:	1e 87       	std	Y+14, r17	; 0x0e
    3d7c:	0d 87       	std	Y+13, r16	; 0x0d
    3d7e:	f8 8a       	std	Y+16, r15	; 0x10
    3d80:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    3d82:	81 e0       	ldi	r24, 0x01	; 1
    3d84:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3d86:	8e 81       	ldd	r24, Y+6	; 0x06
    3d88:	9f 81       	ldd	r25, Y+7	; 0x07
    3d8a:	9d 83       	std	Y+5, r25	; 0x05
    3d8c:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d8e:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    3d90:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d92:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d94:	00 97       	sbiw	r24, 0x00	; 0
    3d96:	61 f0       	breq	.+24     	; 0x3db0 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3d98:	ec 81       	ldd	r30, Y+4	; 0x04
    3d9a:	fd 81       	ldd	r31, Y+5	; 0x05
    3d9c:	81 a1       	ldd	r24, Z+33	; 0x21
    3d9e:	92 a1       	ldd	r25, Z+34	; 0x22
    3da0:	a3 a1       	ldd	r26, Z+35	; 0x23
    3da2:	b4 a1       	ldd	r27, Z+36	; 0x24
    3da4:	ed 85       	ldd	r30, Y+13	; 0x0d
    3da6:	fe 85       	ldd	r31, Y+14	; 0x0e
    3da8:	80 83       	st	Z, r24
    3daa:	91 83       	std	Z+1, r25	; 0x01
    3dac:	a2 83       	std	Z+2, r26	; 0x02
    3dae:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3db0:	ec 81       	ldd	r30, Y+4	; 0x04
    3db2:	fd 81       	ldd	r31, Y+5	; 0x05
    3db4:	85 a1       	ldd	r24, Z+37	; 0x25
    3db6:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3db8:	ec 81       	ldd	r30, Y+4	; 0x04
    3dba:	fd 81       	ldd	r31, Y+5	; 0x05
    3dbc:	82 e0       	ldi	r24, 0x02	; 2
    3dbe:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3dc0:	8c 85       	ldd	r24, Y+12	; 0x0c
    3dc2:	28 2f       	mov	r18, r24
    3dc4:	30 e0       	ldi	r19, 0x00	; 0
    3dc6:	3a 8b       	std	Y+18, r19	; 0x12
    3dc8:	29 8b       	std	Y+17, r18	; 0x11
    3dca:	89 89       	ldd	r24, Y+17	; 0x11
    3dcc:	9a 89       	ldd	r25, Y+18	; 0x12
    3dce:	82 30       	cpi	r24, 0x02	; 2
    3dd0:	91 05       	cpc	r25, r1
    3dd2:	59 f1       	breq	.+86     	; 0x3e2a <xTaskGenericNotifyFromISR+0xda>
    3dd4:	29 89       	ldd	r18, Y+17	; 0x11
    3dd6:	3a 89       	ldd	r19, Y+18	; 0x12
    3dd8:	23 30       	cpi	r18, 0x03	; 3
    3dda:	31 05       	cpc	r19, r1
    3ddc:	34 f4       	brge	.+12     	; 0x3dea <xTaskGenericNotifyFromISR+0x9a>
    3dde:	89 89       	ldd	r24, Y+17	; 0x11
    3de0:	9a 89       	ldd	r25, Y+18	; 0x12
    3de2:	81 30       	cpi	r24, 0x01	; 1
    3de4:	91 05       	cpc	r25, r1
    3de6:	61 f0       	breq	.+24     	; 0x3e00 <xTaskGenericNotifyFromISR+0xb0>
    3de8:	4a c0       	rjmp	.+148    	; 0x3e7e <xTaskGenericNotifyFromISR+0x12e>
    3dea:	29 89       	ldd	r18, Y+17	; 0x11
    3dec:	3a 89       	ldd	r19, Y+18	; 0x12
    3dee:	23 30       	cpi	r18, 0x03	; 3
    3df0:	31 05       	cpc	r19, r1
    3df2:	59 f1       	breq	.+86     	; 0x3e4a <xTaskGenericNotifyFromISR+0xfa>
    3df4:	89 89       	ldd	r24, Y+17	; 0x11
    3df6:	9a 89       	ldd	r25, Y+18	; 0x12
    3df8:	84 30       	cpi	r24, 0x04	; 4
    3dfa:	91 05       	cpc	r25, r1
    3dfc:	89 f1       	breq	.+98     	; 0x3e60 <xTaskGenericNotifyFromISR+0x110>
    3dfe:	3f c0       	rjmp	.+126    	; 0x3e7e <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3e00:	ec 81       	ldd	r30, Y+4	; 0x04
    3e02:	fd 81       	ldd	r31, Y+5	; 0x05
    3e04:	21 a1       	ldd	r18, Z+33	; 0x21
    3e06:	32 a1       	ldd	r19, Z+34	; 0x22
    3e08:	43 a1       	ldd	r20, Z+35	; 0x23
    3e0a:	54 a1       	ldd	r21, Z+36	; 0x24
    3e0c:	88 85       	ldd	r24, Y+8	; 0x08
    3e0e:	99 85       	ldd	r25, Y+9	; 0x09
    3e10:	aa 85       	ldd	r26, Y+10	; 0x0a
    3e12:	bb 85       	ldd	r27, Y+11	; 0x0b
    3e14:	82 2b       	or	r24, r18
    3e16:	93 2b       	or	r25, r19
    3e18:	a4 2b       	or	r26, r20
    3e1a:	b5 2b       	or	r27, r21
    3e1c:	ec 81       	ldd	r30, Y+4	; 0x04
    3e1e:	fd 81       	ldd	r31, Y+5	; 0x05
    3e20:	81 a3       	std	Z+33, r24	; 0x21
    3e22:	92 a3       	std	Z+34, r25	; 0x22
    3e24:	a3 a3       	std	Z+35, r26	; 0x23
    3e26:	b4 a3       	std	Z+36, r27	; 0x24
    3e28:	2a c0       	rjmp	.+84     	; 0x3e7e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3e2a:	ec 81       	ldd	r30, Y+4	; 0x04
    3e2c:	fd 81       	ldd	r31, Y+5	; 0x05
    3e2e:	81 a1       	ldd	r24, Z+33	; 0x21
    3e30:	92 a1       	ldd	r25, Z+34	; 0x22
    3e32:	a3 a1       	ldd	r26, Z+35	; 0x23
    3e34:	b4 a1       	ldd	r27, Z+36	; 0x24
    3e36:	01 96       	adiw	r24, 0x01	; 1
    3e38:	a1 1d       	adc	r26, r1
    3e3a:	b1 1d       	adc	r27, r1
    3e3c:	ec 81       	ldd	r30, Y+4	; 0x04
    3e3e:	fd 81       	ldd	r31, Y+5	; 0x05
    3e40:	81 a3       	std	Z+33, r24	; 0x21
    3e42:	92 a3       	std	Z+34, r25	; 0x22
    3e44:	a3 a3       	std	Z+35, r26	; 0x23
    3e46:	b4 a3       	std	Z+36, r27	; 0x24
    3e48:	1a c0       	rjmp	.+52     	; 0x3e7e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3e4a:	ec 81       	ldd	r30, Y+4	; 0x04
    3e4c:	fd 81       	ldd	r31, Y+5	; 0x05
    3e4e:	88 85       	ldd	r24, Y+8	; 0x08
    3e50:	99 85       	ldd	r25, Y+9	; 0x09
    3e52:	aa 85       	ldd	r26, Y+10	; 0x0a
    3e54:	bb 85       	ldd	r27, Y+11	; 0x0b
    3e56:	81 a3       	std	Z+33, r24	; 0x21
    3e58:	92 a3       	std	Z+34, r25	; 0x22
    3e5a:	a3 a3       	std	Z+35, r26	; 0x23
    3e5c:	b4 a3       	std	Z+36, r27	; 0x24
    3e5e:	0f c0       	rjmp	.+30     	; 0x3e7e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3e60:	8b 81       	ldd	r24, Y+3	; 0x03
    3e62:	82 30       	cpi	r24, 0x02	; 2
    3e64:	59 f0       	breq	.+22     	; 0x3e7c <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3e66:	ec 81       	ldd	r30, Y+4	; 0x04
    3e68:	fd 81       	ldd	r31, Y+5	; 0x05
    3e6a:	88 85       	ldd	r24, Y+8	; 0x08
    3e6c:	99 85       	ldd	r25, Y+9	; 0x09
    3e6e:	aa 85       	ldd	r26, Y+10	; 0x0a
    3e70:	bb 85       	ldd	r27, Y+11	; 0x0b
    3e72:	81 a3       	std	Z+33, r24	; 0x21
    3e74:	92 a3       	std	Z+34, r25	; 0x22
    3e76:	a3 a3       	std	Z+35, r26	; 0x23
    3e78:	b4 a3       	std	Z+36, r27	; 0x24
    3e7a:	01 c0       	rjmp	.+2      	; 0x3e7e <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3e7c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e80:	81 30       	cpi	r24, 0x01	; 1
    3e82:	09 f0       	breq	.+2      	; 0x3e86 <xTaskGenericNotifyFromISR+0x136>
    3e84:	4f c0       	rjmp	.+158    	; 0x3f24 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3e86:	80 91 6b 04 	lds	r24, 0x046B
    3e8a:	88 23       	and	r24, r24
    3e8c:	61 f5       	brne	.+88     	; 0x3ee6 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3e8e:	8c 81       	ldd	r24, Y+4	; 0x04
    3e90:	9d 81       	ldd	r25, Y+5	; 0x05
    3e92:	02 96       	adiw	r24, 0x02	; 2
    3e94:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3e98:	ec 81       	ldd	r30, Y+4	; 0x04
    3e9a:	fd 81       	ldd	r31, Y+5	; 0x05
    3e9c:	96 89       	ldd	r25, Z+22	; 0x16
    3e9e:	80 91 60 04 	lds	r24, 0x0460
    3ea2:	89 17       	cp	r24, r25
    3ea4:	28 f4       	brcc	.+10     	; 0x3eb0 <xTaskGenericNotifyFromISR+0x160>
    3ea6:	ec 81       	ldd	r30, Y+4	; 0x04
    3ea8:	fd 81       	ldd	r31, Y+5	; 0x05
    3eaa:	86 89       	ldd	r24, Z+22	; 0x16
    3eac:	80 93 60 04 	sts	0x0460, r24
    3eb0:	ec 81       	ldd	r30, Y+4	; 0x04
    3eb2:	fd 81       	ldd	r31, Y+5	; 0x05
    3eb4:	86 89       	ldd	r24, Z+22	; 0x16
    3eb6:	28 2f       	mov	r18, r24
    3eb8:	30 e0       	ldi	r19, 0x00	; 0
    3eba:	c9 01       	movw	r24, r18
    3ebc:	88 0f       	add	r24, r24
    3ebe:	99 1f       	adc	r25, r25
    3ec0:	88 0f       	add	r24, r24
    3ec2:	99 1f       	adc	r25, r25
    3ec4:	88 0f       	add	r24, r24
    3ec6:	99 1f       	adc	r25, r25
    3ec8:	82 0f       	add	r24, r18
    3eca:	93 1f       	adc	r25, r19
    3ecc:	ac 01       	movw	r20, r24
    3ece:	44 59       	subi	r20, 0x94	; 148
    3ed0:	5b 4f       	sbci	r21, 0xFB	; 251
    3ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    3ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    3ed6:	9c 01       	movw	r18, r24
    3ed8:	2e 5f       	subi	r18, 0xFE	; 254
    3eda:	3f 4f       	sbci	r19, 0xFF	; 255
    3edc:	ca 01       	movw	r24, r20
    3ede:	b9 01       	movw	r22, r18
    3ee0:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
    3ee4:	0a c0       	rjmp	.+20     	; 0x3efa <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3ee6:	8c 81       	ldd	r24, Y+4	; 0x04
    3ee8:	9d 81       	ldd	r25, Y+5	; 0x05
    3eea:	9c 01       	movw	r18, r24
    3eec:	24 5f       	subi	r18, 0xF4	; 244
    3eee:	3f 4f       	sbci	r19, 0xFF	; 255
    3ef0:	8f ea       	ldi	r24, 0xAF	; 175
    3ef2:	94 e0       	ldi	r25, 0x04	; 4
    3ef4:	b9 01       	movw	r22, r18
    3ef6:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3efa:	ec 81       	ldd	r30, Y+4	; 0x04
    3efc:	fd 81       	ldd	r31, Y+5	; 0x05
    3efe:	96 89       	ldd	r25, Z+22	; 0x16
    3f00:	e0 91 5a 04 	lds	r30, 0x045A
    3f04:	f0 91 5b 04 	lds	r31, 0x045B
    3f08:	86 89       	ldd	r24, Z+22	; 0x16
    3f0a:	89 17       	cp	r24, r25
    3f0c:	58 f4       	brcc	.+22     	; 0x3f24 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3f0e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f10:	98 89       	ldd	r25, Y+16	; 0x10
    3f12:	00 97       	sbiw	r24, 0x00	; 0
    3f14:	21 f0       	breq	.+8      	; 0x3f1e <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3f16:	ef 85       	ldd	r30, Y+15	; 0x0f
    3f18:	f8 89       	ldd	r31, Y+16	; 0x10
    3f1a:	81 e0       	ldi	r24, 0x01	; 1
    3f1c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3f1e:	81 e0       	ldi	r24, 0x01	; 1
    3f20:	80 93 64 04 	sts	0x0464, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    3f24:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3f26:	62 96       	adiw	r28, 0x12	; 18
    3f28:	0f b6       	in	r0, 0x3f	; 63
    3f2a:	f8 94       	cli
    3f2c:	de bf       	out	0x3e, r29	; 62
    3f2e:	0f be       	out	0x3f, r0	; 63
    3f30:	cd bf       	out	0x3d, r28	; 61
    3f32:	cf 91       	pop	r28
    3f34:	df 91       	pop	r29
    3f36:	1f 91       	pop	r17
    3f38:	0f 91       	pop	r16
    3f3a:	ff 90       	pop	r15
    3f3c:	ef 90       	pop	r14
    3f3e:	08 95       	ret

00003f40 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3f40:	df 93       	push	r29
    3f42:	cf 93       	push	r28
    3f44:	cd b7       	in	r28, 0x3d	; 61
    3f46:	de b7       	in	r29, 0x3e	; 62
    3f48:	28 97       	sbiw	r28, 0x08	; 8
    3f4a:	0f b6       	in	r0, 0x3f	; 63
    3f4c:	f8 94       	cli
    3f4e:	de bf       	out	0x3e, r29	; 62
    3f50:	0f be       	out	0x3f, r0	; 63
    3f52:	cd bf       	out	0x3d, r28	; 61
    3f54:	9e 83       	std	Y+6, r25	; 0x06
    3f56:	8d 83       	std	Y+5, r24	; 0x05
    3f58:	78 87       	std	Y+8, r23	; 0x08
    3f5a:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3f5c:	8d 81       	ldd	r24, Y+5	; 0x05
    3f5e:	9e 81       	ldd	r25, Y+6	; 0x06
    3f60:	9c 83       	std	Y+4, r25	; 0x04
    3f62:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3f64:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3f66:	eb 81       	ldd	r30, Y+3	; 0x03
    3f68:	fc 81       	ldd	r31, Y+4	; 0x04
    3f6a:	85 a1       	ldd	r24, Z+37	; 0x25
    3f6c:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3f6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f70:	fc 81       	ldd	r31, Y+4	; 0x04
    3f72:	82 e0       	ldi	r24, 0x02	; 2
    3f74:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3f76:	eb 81       	ldd	r30, Y+3	; 0x03
    3f78:	fc 81       	ldd	r31, Y+4	; 0x04
    3f7a:	81 a1       	ldd	r24, Z+33	; 0x21
    3f7c:	92 a1       	ldd	r25, Z+34	; 0x22
    3f7e:	a3 a1       	ldd	r26, Z+35	; 0x23
    3f80:	b4 a1       	ldd	r27, Z+36	; 0x24
    3f82:	01 96       	adiw	r24, 0x01	; 1
    3f84:	a1 1d       	adc	r26, r1
    3f86:	b1 1d       	adc	r27, r1
    3f88:	eb 81       	ldd	r30, Y+3	; 0x03
    3f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f8c:	81 a3       	std	Z+33, r24	; 0x21
    3f8e:	92 a3       	std	Z+34, r25	; 0x22
    3f90:	a3 a3       	std	Z+35, r26	; 0x23
    3f92:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3f94:	8a 81       	ldd	r24, Y+2	; 0x02
    3f96:	81 30       	cpi	r24, 0x01	; 1
    3f98:	09 f0       	breq	.+2      	; 0x3f9c <vTaskNotifyGiveFromISR+0x5c>
    3f9a:	4f c0       	rjmp	.+158    	; 0x403a <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3f9c:	80 91 6b 04 	lds	r24, 0x046B
    3fa0:	88 23       	and	r24, r24
    3fa2:	61 f5       	brne	.+88     	; 0x3ffc <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    3fa8:	02 96       	adiw	r24, 0x02	; 2
    3faa:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3fae:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb2:	96 89       	ldd	r25, Z+22	; 0x16
    3fb4:	80 91 60 04 	lds	r24, 0x0460
    3fb8:	89 17       	cp	r24, r25
    3fba:	28 f4       	brcc	.+10     	; 0x3fc6 <vTaskNotifyGiveFromISR+0x86>
    3fbc:	eb 81       	ldd	r30, Y+3	; 0x03
    3fbe:	fc 81       	ldd	r31, Y+4	; 0x04
    3fc0:	86 89       	ldd	r24, Z+22	; 0x16
    3fc2:	80 93 60 04 	sts	0x0460, r24
    3fc6:	eb 81       	ldd	r30, Y+3	; 0x03
    3fc8:	fc 81       	ldd	r31, Y+4	; 0x04
    3fca:	86 89       	ldd	r24, Z+22	; 0x16
    3fcc:	28 2f       	mov	r18, r24
    3fce:	30 e0       	ldi	r19, 0x00	; 0
    3fd0:	c9 01       	movw	r24, r18
    3fd2:	88 0f       	add	r24, r24
    3fd4:	99 1f       	adc	r25, r25
    3fd6:	88 0f       	add	r24, r24
    3fd8:	99 1f       	adc	r25, r25
    3fda:	88 0f       	add	r24, r24
    3fdc:	99 1f       	adc	r25, r25
    3fde:	82 0f       	add	r24, r18
    3fe0:	93 1f       	adc	r25, r19
    3fe2:	ac 01       	movw	r20, r24
    3fe4:	44 59       	subi	r20, 0x94	; 148
    3fe6:	5b 4f       	sbci	r21, 0xFB	; 251
    3fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fea:	9c 81       	ldd	r25, Y+4	; 0x04
    3fec:	9c 01       	movw	r18, r24
    3fee:	2e 5f       	subi	r18, 0xFE	; 254
    3ff0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ff2:	ca 01       	movw	r24, r20
    3ff4:	b9 01       	movw	r22, r18
    3ff6:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
    3ffa:	0a c0       	rjmp	.+20     	; 0x4010 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    4000:	9c 01       	movw	r18, r24
    4002:	24 5f       	subi	r18, 0xF4	; 244
    4004:	3f 4f       	sbci	r19, 0xFF	; 255
    4006:	8f ea       	ldi	r24, 0xAF	; 175
    4008:	94 e0       	ldi	r25, 0x04	; 4
    400a:	b9 01       	movw	r22, r18
    400c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4010:	eb 81       	ldd	r30, Y+3	; 0x03
    4012:	fc 81       	ldd	r31, Y+4	; 0x04
    4014:	96 89       	ldd	r25, Z+22	; 0x16
    4016:	e0 91 5a 04 	lds	r30, 0x045A
    401a:	f0 91 5b 04 	lds	r31, 0x045B
    401e:	86 89       	ldd	r24, Z+22	; 0x16
    4020:	89 17       	cp	r24, r25
    4022:	58 f4       	brcc	.+22     	; 0x403a <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4024:	8f 81       	ldd	r24, Y+7	; 0x07
    4026:	98 85       	ldd	r25, Y+8	; 0x08
    4028:	00 97       	sbiw	r24, 0x00	; 0
    402a:	21 f0       	breq	.+8      	; 0x4034 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    402c:	ef 81       	ldd	r30, Y+7	; 0x07
    402e:	f8 85       	ldd	r31, Y+8	; 0x08
    4030:	81 e0       	ldi	r24, 0x01	; 1
    4032:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4034:	81 e0       	ldi	r24, 0x01	; 1
    4036:	80 93 64 04 	sts	0x0464, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    403a:	28 96       	adiw	r28, 0x08	; 8
    403c:	0f b6       	in	r0, 0x3f	; 63
    403e:	f8 94       	cli
    4040:	de bf       	out	0x3e, r29	; 62
    4042:	0f be       	out	0x3f, r0	; 63
    4044:	cd bf       	out	0x3d, r28	; 61
    4046:	cf 91       	pop	r28
    4048:	df 91       	pop	r29
    404a:	08 95       	ret

0000404c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    404c:	df 93       	push	r29
    404e:	cf 93       	push	r28
    4050:	cd b7       	in	r28, 0x3d	; 61
    4052:	de b7       	in	r29, 0x3e	; 62
    4054:	27 97       	sbiw	r28, 0x07	; 7
    4056:	0f b6       	in	r0, 0x3f	; 63
    4058:	f8 94       	cli
    405a:	de bf       	out	0x3e, r29	; 62
    405c:	0f be       	out	0x3f, r0	; 63
    405e:	cd bf       	out	0x3d, r28	; 61
    4060:	9d 83       	std	Y+5, r25	; 0x05
    4062:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4064:	8c 81       	ldd	r24, Y+4	; 0x04
    4066:	9d 81       	ldd	r25, Y+5	; 0x05
    4068:	00 97       	sbiw	r24, 0x00	; 0
    406a:	39 f4       	brne	.+14     	; 0x407a <xTaskNotifyStateClear+0x2e>
    406c:	80 91 5a 04 	lds	r24, 0x045A
    4070:	90 91 5b 04 	lds	r25, 0x045B
    4074:	9f 83       	std	Y+7, r25	; 0x07
    4076:	8e 83       	std	Y+6, r24	; 0x06
    4078:	04 c0       	rjmp	.+8      	; 0x4082 <xTaskNotifyStateClear+0x36>
    407a:	8c 81       	ldd	r24, Y+4	; 0x04
    407c:	9d 81       	ldd	r25, Y+5	; 0x05
    407e:	9f 83       	std	Y+7, r25	; 0x07
    4080:	8e 83       	std	Y+6, r24	; 0x06
    4082:	8e 81       	ldd	r24, Y+6	; 0x06
    4084:	9f 81       	ldd	r25, Y+7	; 0x07
    4086:	9b 83       	std	Y+3, r25	; 0x03
    4088:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    408a:	0f b6       	in	r0, 0x3f	; 63
    408c:	f8 94       	cli
    408e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4090:	ea 81       	ldd	r30, Y+2	; 0x02
    4092:	fb 81       	ldd	r31, Y+3	; 0x03
    4094:	85 a1       	ldd	r24, Z+37	; 0x25
    4096:	82 30       	cpi	r24, 0x02	; 2
    4098:	31 f4       	brne	.+12     	; 0x40a6 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    409a:	ea 81       	ldd	r30, Y+2	; 0x02
    409c:	fb 81       	ldd	r31, Y+3	; 0x03
    409e:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    40a0:	81 e0       	ldi	r24, 0x01	; 1
    40a2:	89 83       	std	Y+1, r24	; 0x01
    40a4:	01 c0       	rjmp	.+2      	; 0x40a8 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    40a6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    40a8:	0f 90       	pop	r0
    40aa:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    40ac:	89 81       	ldd	r24, Y+1	; 0x01
	}
    40ae:	27 96       	adiw	r28, 0x07	; 7
    40b0:	0f b6       	in	r0, 0x3f	; 63
    40b2:	f8 94       	cli
    40b4:	de bf       	out	0x3e, r29	; 62
    40b6:	0f be       	out	0x3f, r0	; 63
    40b8:	cd bf       	out	0x3d, r28	; 61
    40ba:	cf 91       	pop	r28
    40bc:	df 91       	pop	r29
    40be:	08 95       	ret

000040c0 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    40c0:	df 93       	push	r29
    40c2:	cf 93       	push	r28
    40c4:	cd b7       	in	r28, 0x3d	; 61
    40c6:	de b7       	in	r29, 0x3e	; 62
    40c8:	2e 97       	sbiw	r28, 0x0e	; 14
    40ca:	0f b6       	in	r0, 0x3f	; 63
    40cc:	f8 94       	cli
    40ce:	de bf       	out	0x3e, r29	; 62
    40d0:	0f be       	out	0x3f, r0	; 63
    40d2:	cd bf       	out	0x3d, r28	; 61
    40d4:	98 87       	std	Y+8, r25	; 0x08
    40d6:	8f 83       	std	Y+7, r24	; 0x07
    40d8:	49 87       	std	Y+9, r20	; 0x09
    40da:	5a 87       	std	Y+10, r21	; 0x0a
    40dc:	6b 87       	std	Y+11, r22	; 0x0b
    40de:	7c 87       	std	Y+12, r23	; 0x0c
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    40e0:	8f 81       	ldd	r24, Y+7	; 0x07
    40e2:	98 85       	ldd	r25, Y+8	; 0x08
    40e4:	00 97       	sbiw	r24, 0x00	; 0
    40e6:	39 f4       	brne	.+14     	; 0x40f6 <ulTaskNotifyValueClear+0x36>
    40e8:	80 91 5a 04 	lds	r24, 0x045A
    40ec:	90 91 5b 04 	lds	r25, 0x045B
    40f0:	9e 87       	std	Y+14, r25	; 0x0e
    40f2:	8d 87       	std	Y+13, r24	; 0x0d
    40f4:	04 c0       	rjmp	.+8      	; 0x40fe <ulTaskNotifyValueClear+0x3e>
    40f6:	8f 81       	ldd	r24, Y+7	; 0x07
    40f8:	98 85       	ldd	r25, Y+8	; 0x08
    40fa:	9e 87       	std	Y+14, r25	; 0x0e
    40fc:	8d 87       	std	Y+13, r24	; 0x0d
    40fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4100:	9e 85       	ldd	r25, Y+14	; 0x0e
    4102:	9e 83       	std	Y+6, r25	; 0x06
    4104:	8d 83       	std	Y+5, r24	; 0x05

		taskENTER_CRITICAL();
    4106:	0f b6       	in	r0, 0x3f	; 63
    4108:	f8 94       	cli
    410a:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    410c:	e0 91 5a 04 	lds	r30, 0x045A
    4110:	f0 91 5b 04 	lds	r31, 0x045B
    4114:	81 a1       	ldd	r24, Z+33	; 0x21
    4116:	92 a1       	ldd	r25, Z+34	; 0x22
    4118:	a3 a1       	ldd	r26, Z+35	; 0x23
    411a:	b4 a1       	ldd	r27, Z+36	; 0x24
    411c:	89 83       	std	Y+1, r24	; 0x01
    411e:	9a 83       	std	Y+2, r25	; 0x02
    4120:	ab 83       	std	Y+3, r26	; 0x03
    4122:	bc 83       	std	Y+4, r27	; 0x04
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    4124:	ed 81       	ldd	r30, Y+5	; 0x05
    4126:	fe 81       	ldd	r31, Y+6	; 0x06
    4128:	21 a1       	ldd	r18, Z+33	; 0x21
    412a:	32 a1       	ldd	r19, Z+34	; 0x22
    412c:	43 a1       	ldd	r20, Z+35	; 0x23
    412e:	54 a1       	ldd	r21, Z+36	; 0x24
    4130:	89 85       	ldd	r24, Y+9	; 0x09
    4132:	9a 85       	ldd	r25, Y+10	; 0x0a
    4134:	ab 85       	ldd	r26, Y+11	; 0x0b
    4136:	bc 85       	ldd	r27, Y+12	; 0x0c
    4138:	80 95       	com	r24
    413a:	90 95       	com	r25
    413c:	a0 95       	com	r26
    413e:	b0 95       	com	r27
    4140:	82 23       	and	r24, r18
    4142:	93 23       	and	r25, r19
    4144:	a4 23       	and	r26, r20
    4146:	b5 23       	and	r27, r21
    4148:	ed 81       	ldd	r30, Y+5	; 0x05
    414a:	fe 81       	ldd	r31, Y+6	; 0x06
    414c:	81 a3       	std	Z+33, r24	; 0x21
    414e:	92 a3       	std	Z+34, r25	; 0x22
    4150:	a3 a3       	std	Z+35, r26	; 0x23
    4152:	b4 a3       	std	Z+36, r27	; 0x24
		}
		taskEXIT_CRITICAL();
    4154:	0f 90       	pop	r0
    4156:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4158:	89 81       	ldd	r24, Y+1	; 0x01
    415a:	9a 81       	ldd	r25, Y+2	; 0x02
    415c:	ab 81       	ldd	r26, Y+3	; 0x03
    415e:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4160:	bc 01       	movw	r22, r24
    4162:	cd 01       	movw	r24, r26
    4164:	2e 96       	adiw	r28, 0x0e	; 14
    4166:	0f b6       	in	r0, 0x3f	; 63
    4168:	f8 94       	cli
    416a:	de bf       	out	0x3e, r29	; 62
    416c:	0f be       	out	0x3f, r0	; 63
    416e:	cd bf       	out	0x3d, r28	; 61
    4170:	cf 91       	pop	r28
    4172:	df 91       	pop	r29
    4174:	08 95       	ret

00004176 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4176:	df 93       	push	r29
    4178:	cf 93       	push	r28
    417a:	cd b7       	in	r28, 0x3d	; 61
    417c:	de b7       	in	r29, 0x3e	; 62
    417e:	27 97       	sbiw	r28, 0x07	; 7
    4180:	0f b6       	in	r0, 0x3f	; 63
    4182:	f8 94       	cli
    4184:	de bf       	out	0x3e, r29	; 62
    4186:	0f be       	out	0x3f, r0	; 63
    4188:	cd bf       	out	0x3d, r28	; 61
    418a:	9e 83       	std	Y+6, r25	; 0x06
    418c:	8d 83       	std	Y+5, r24	; 0x05
    418e:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4190:	80 91 5e 04 	lds	r24, 0x045E
    4194:	90 91 5f 04 	lds	r25, 0x045F
    4198:	9a 83       	std	Y+2, r25	; 0x02
    419a:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    419c:	80 91 5a 04 	lds	r24, 0x045A
    41a0:	90 91 5b 04 	lds	r25, 0x045B
    41a4:	02 96       	adiw	r24, 0x02	; 2
    41a6:	0e 94 b5 07 	call	0xf6a	; 0xf6a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    41aa:	8d 81       	ldd	r24, Y+5	; 0x05
    41ac:	9e 81       	ldd	r25, Y+6	; 0x06
    41ae:	2f ef       	ldi	r18, 0xFF	; 255
    41b0:	8f 3f       	cpi	r24, 0xFF	; 255
    41b2:	92 07       	cpc	r25, r18
    41b4:	81 f4       	brne	.+32     	; 0x41d6 <prvAddCurrentTaskToDelayedList+0x60>
    41b6:	8f 81       	ldd	r24, Y+7	; 0x07
    41b8:	88 23       	and	r24, r24
    41ba:	69 f0       	breq	.+26     	; 0x41d6 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    41bc:	80 91 5a 04 	lds	r24, 0x045A
    41c0:	90 91 5b 04 	lds	r25, 0x045B
    41c4:	9c 01       	movw	r18, r24
    41c6:	2e 5f       	subi	r18, 0xFE	; 254
    41c8:	3f 4f       	sbci	r19, 0xFF	; 255
    41ca:	81 ec       	ldi	r24, 0xC1	; 193
    41cc:	94 e0       	ldi	r25, 0x04	; 4
    41ce:	b9 01       	movw	r22, r18
    41d0:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsertEnd>
    41d4:	43 c0       	rjmp	.+134    	; 0x425c <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    41d6:	29 81       	ldd	r18, Y+1	; 0x01
    41d8:	3a 81       	ldd	r19, Y+2	; 0x02
    41da:	8d 81       	ldd	r24, Y+5	; 0x05
    41dc:	9e 81       	ldd	r25, Y+6	; 0x06
    41de:	82 0f       	add	r24, r18
    41e0:	93 1f       	adc	r25, r19
    41e2:	9c 83       	std	Y+4, r25	; 0x04
    41e4:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    41e6:	e0 91 5a 04 	lds	r30, 0x045A
    41ea:	f0 91 5b 04 	lds	r31, 0x045B
    41ee:	8b 81       	ldd	r24, Y+3	; 0x03
    41f0:	9c 81       	ldd	r25, Y+4	; 0x04
    41f2:	93 83       	std	Z+3, r25	; 0x03
    41f4:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    41f6:	2b 81       	ldd	r18, Y+3	; 0x03
    41f8:	3c 81       	ldd	r19, Y+4	; 0x04
    41fa:	89 81       	ldd	r24, Y+1	; 0x01
    41fc:	9a 81       	ldd	r25, Y+2	; 0x02
    41fe:	28 17       	cp	r18, r24
    4200:	39 07       	cpc	r19, r25
    4202:	70 f4       	brcc	.+28     	; 0x4220 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4204:	80 91 ad 04 	lds	r24, 0x04AD
    4208:	90 91 ae 04 	lds	r25, 0x04AE
    420c:	20 91 5a 04 	lds	r18, 0x045A
    4210:	30 91 5b 04 	lds	r19, 0x045B
    4214:	2e 5f       	subi	r18, 0xFE	; 254
    4216:	3f 4f       	sbci	r19, 0xFF	; 255
    4218:	b9 01       	movw	r22, r18
    421a:	0e 94 49 07 	call	0xe92	; 0xe92 <vListInsert>
    421e:	1e c0       	rjmp	.+60     	; 0x425c <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4220:	40 91 ab 04 	lds	r20, 0x04AB
    4224:	50 91 ac 04 	lds	r21, 0x04AC
    4228:	80 91 5a 04 	lds	r24, 0x045A
    422c:	90 91 5b 04 	lds	r25, 0x045B
    4230:	9c 01       	movw	r18, r24
    4232:	2e 5f       	subi	r18, 0xFE	; 254
    4234:	3f 4f       	sbci	r19, 0xFF	; 255
    4236:	ca 01       	movw	r24, r20
    4238:	b9 01       	movw	r22, r18
    423a:	0e 94 49 07 	call	0xe92	; 0xe92 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    423e:	20 91 67 04 	lds	r18, 0x0467
    4242:	30 91 68 04 	lds	r19, 0x0468
    4246:	8b 81       	ldd	r24, Y+3	; 0x03
    4248:	9c 81       	ldd	r25, Y+4	; 0x04
    424a:	82 17       	cp	r24, r18
    424c:	93 07       	cpc	r25, r19
    424e:	30 f4       	brcc	.+12     	; 0x425c <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    4250:	8b 81       	ldd	r24, Y+3	; 0x03
    4252:	9c 81       	ldd	r25, Y+4	; 0x04
    4254:	90 93 68 04 	sts	0x0468, r25
    4258:	80 93 67 04 	sts	0x0467, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    425c:	27 96       	adiw	r28, 0x07	; 7
    425e:	0f b6       	in	r0, 0x3f	; 63
    4260:	f8 94       	cli
    4262:	de bf       	out	0x3e, r29	; 62
    4264:	0f be       	out	0x3f, r0	; 63
    4266:	cd bf       	out	0x3d, r28	; 61
    4268:	cf 91       	pop	r28
    426a:	df 91       	pop	r29
    426c:	08 95       	ret

0000426e <GPIO_voidSetPinValue>:

#include "GPIO_Interface.h"
#include "GPIO_Private.h"

void GPIO_voidSetPinValue(u8 port_id , u8 pin , u8 value)
{
    426e:	df 93       	push	r29
    4270:	cf 93       	push	r28
    4272:	cd b7       	in	r28, 0x3d	; 61
    4274:	de b7       	in	r29, 0x3e	; 62
    4276:	27 97       	sbiw	r28, 0x07	; 7
    4278:	0f b6       	in	r0, 0x3f	; 63
    427a:	f8 94       	cli
    427c:	de bf       	out	0x3e, r29	; 62
    427e:	0f be       	out	0x3f, r0	; 63
    4280:	cd bf       	out	0x3d, r28	; 61
    4282:	89 83       	std	Y+1, r24	; 0x01
    4284:	6a 83       	std	Y+2, r22	; 0x02
    4286:	4b 83       	std	Y+3, r20	; 0x03
	if (value == HIGH)
    4288:	8b 81       	ldd	r24, Y+3	; 0x03
    428a:	81 30       	cpi	r24, 0x01	; 1
    428c:	09 f0       	breq	.+2      	; 0x4290 <GPIO_voidSetPinValue+0x22>
    428e:	6f c0       	rjmp	.+222    	; 0x436e <GPIO_voidSetPinValue+0x100>
	{
		switch (port_id)
    4290:	89 81       	ldd	r24, Y+1	; 0x01
    4292:	28 2f       	mov	r18, r24
    4294:	30 e0       	ldi	r19, 0x00	; 0
    4296:	3f 83       	std	Y+7, r19	; 0x07
    4298:	2e 83       	std	Y+6, r18	; 0x06
    429a:	8e 81       	ldd	r24, Y+6	; 0x06
    429c:	9f 81       	ldd	r25, Y+7	; 0x07
    429e:	81 30       	cpi	r24, 0x01	; 1
    42a0:	91 05       	cpc	r25, r1
    42a2:	49 f1       	breq	.+82     	; 0x42f6 <GPIO_voidSetPinValue+0x88>
    42a4:	2e 81       	ldd	r18, Y+6	; 0x06
    42a6:	3f 81       	ldd	r19, Y+7	; 0x07
    42a8:	22 30       	cpi	r18, 0x02	; 2
    42aa:	31 05       	cpc	r19, r1
    42ac:	2c f4       	brge	.+10     	; 0x42b8 <GPIO_voidSetPinValue+0x4a>
    42ae:	8e 81       	ldd	r24, Y+6	; 0x06
    42b0:	9f 81       	ldd	r25, Y+7	; 0x07
    42b2:	00 97       	sbiw	r24, 0x00	; 0
    42b4:	61 f0       	breq	.+24     	; 0x42ce <GPIO_voidSetPinValue+0x60>
    42b6:	d2 c0       	rjmp	.+420    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
    42b8:	2e 81       	ldd	r18, Y+6	; 0x06
    42ba:	3f 81       	ldd	r19, Y+7	; 0x07
    42bc:	22 30       	cpi	r18, 0x02	; 2
    42be:	31 05       	cpc	r19, r1
    42c0:	71 f1       	breq	.+92     	; 0x431e <GPIO_voidSetPinValue+0xb0>
    42c2:	8e 81       	ldd	r24, Y+6	; 0x06
    42c4:	9f 81       	ldd	r25, Y+7	; 0x07
    42c6:	83 30       	cpi	r24, 0x03	; 3
    42c8:	91 05       	cpc	r25, r1
    42ca:	e9 f1       	breq	.+122    	; 0x4346 <GPIO_voidSetPinValue+0xd8>
    42cc:	c7 c0       	rjmp	.+398    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
		{
			case PORT_A :
			SET_BIT (GPIO_PORTA , pin);
    42ce:	ab e3       	ldi	r26, 0x3B	; 59
    42d0:	b0 e0       	ldi	r27, 0x00	; 0
    42d2:	eb e3       	ldi	r30, 0x3B	; 59
    42d4:	f0 e0       	ldi	r31, 0x00	; 0
    42d6:	80 81       	ld	r24, Z
    42d8:	48 2f       	mov	r20, r24
    42da:	8a 81       	ldd	r24, Y+2	; 0x02
    42dc:	28 2f       	mov	r18, r24
    42de:	30 e0       	ldi	r19, 0x00	; 0
    42e0:	81 e0       	ldi	r24, 0x01	; 1
    42e2:	90 e0       	ldi	r25, 0x00	; 0
    42e4:	02 2e       	mov	r0, r18
    42e6:	02 c0       	rjmp	.+4      	; 0x42ec <GPIO_voidSetPinValue+0x7e>
    42e8:	88 0f       	add	r24, r24
    42ea:	99 1f       	adc	r25, r25
    42ec:	0a 94       	dec	r0
    42ee:	e2 f7       	brpl	.-8      	; 0x42e8 <GPIO_voidSetPinValue+0x7a>
    42f0:	84 2b       	or	r24, r20
    42f2:	8c 93       	st	X, r24
    42f4:	b3 c0       	rjmp	.+358    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_B :
			SET_BIT (GPIO_PORTB , pin);
    42f6:	a8 e3       	ldi	r26, 0x38	; 56
    42f8:	b0 e0       	ldi	r27, 0x00	; 0
    42fa:	e8 e3       	ldi	r30, 0x38	; 56
    42fc:	f0 e0       	ldi	r31, 0x00	; 0
    42fe:	80 81       	ld	r24, Z
    4300:	48 2f       	mov	r20, r24
    4302:	8a 81       	ldd	r24, Y+2	; 0x02
    4304:	28 2f       	mov	r18, r24
    4306:	30 e0       	ldi	r19, 0x00	; 0
    4308:	81 e0       	ldi	r24, 0x01	; 1
    430a:	90 e0       	ldi	r25, 0x00	; 0
    430c:	02 2e       	mov	r0, r18
    430e:	02 c0       	rjmp	.+4      	; 0x4314 <GPIO_voidSetPinValue+0xa6>
    4310:	88 0f       	add	r24, r24
    4312:	99 1f       	adc	r25, r25
    4314:	0a 94       	dec	r0
    4316:	e2 f7       	brpl	.-8      	; 0x4310 <GPIO_voidSetPinValue+0xa2>
    4318:	84 2b       	or	r24, r20
    431a:	8c 93       	st	X, r24
    431c:	9f c0       	rjmp	.+318    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_C :
			SET_BIT (GPIO_PORTC , pin);
    431e:	a5 e3       	ldi	r26, 0x35	; 53
    4320:	b0 e0       	ldi	r27, 0x00	; 0
    4322:	e5 e3       	ldi	r30, 0x35	; 53
    4324:	f0 e0       	ldi	r31, 0x00	; 0
    4326:	80 81       	ld	r24, Z
    4328:	48 2f       	mov	r20, r24
    432a:	8a 81       	ldd	r24, Y+2	; 0x02
    432c:	28 2f       	mov	r18, r24
    432e:	30 e0       	ldi	r19, 0x00	; 0
    4330:	81 e0       	ldi	r24, 0x01	; 1
    4332:	90 e0       	ldi	r25, 0x00	; 0
    4334:	02 2e       	mov	r0, r18
    4336:	02 c0       	rjmp	.+4      	; 0x433c <GPIO_voidSetPinValue+0xce>
    4338:	88 0f       	add	r24, r24
    433a:	99 1f       	adc	r25, r25
    433c:	0a 94       	dec	r0
    433e:	e2 f7       	brpl	.-8      	; 0x4338 <GPIO_voidSetPinValue+0xca>
    4340:	84 2b       	or	r24, r20
    4342:	8c 93       	st	X, r24
    4344:	8b c0       	rjmp	.+278    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_D :
			SET_BIT (GPIO_PORTD , pin);
    4346:	a2 e3       	ldi	r26, 0x32	; 50
    4348:	b0 e0       	ldi	r27, 0x00	; 0
    434a:	e2 e3       	ldi	r30, 0x32	; 50
    434c:	f0 e0       	ldi	r31, 0x00	; 0
    434e:	80 81       	ld	r24, Z
    4350:	48 2f       	mov	r20, r24
    4352:	8a 81       	ldd	r24, Y+2	; 0x02
    4354:	28 2f       	mov	r18, r24
    4356:	30 e0       	ldi	r19, 0x00	; 0
    4358:	81 e0       	ldi	r24, 0x01	; 1
    435a:	90 e0       	ldi	r25, 0x00	; 0
    435c:	02 2e       	mov	r0, r18
    435e:	02 c0       	rjmp	.+4      	; 0x4364 <GPIO_voidSetPinValue+0xf6>
    4360:	88 0f       	add	r24, r24
    4362:	99 1f       	adc	r25, r25
    4364:	0a 94       	dec	r0
    4366:	e2 f7       	brpl	.-8      	; 0x4360 <GPIO_voidSetPinValue+0xf2>
    4368:	84 2b       	or	r24, r20
    436a:	8c 93       	st	X, r24
    436c:	77 c0       	rjmp	.+238    	; 0x445c <GPIO_voidSetPinValue+0x1ee>

			default:
			break;
		}
	}
	else if (value == LOW)
    436e:	8b 81       	ldd	r24, Y+3	; 0x03
    4370:	88 23       	and	r24, r24
    4372:	09 f0       	breq	.+2      	; 0x4376 <GPIO_voidSetPinValue+0x108>
    4374:	73 c0       	rjmp	.+230    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
	{
		switch (port_id)
    4376:	89 81       	ldd	r24, Y+1	; 0x01
    4378:	28 2f       	mov	r18, r24
    437a:	30 e0       	ldi	r19, 0x00	; 0
    437c:	3d 83       	std	Y+5, r19	; 0x05
    437e:	2c 83       	std	Y+4, r18	; 0x04
    4380:	8c 81       	ldd	r24, Y+4	; 0x04
    4382:	9d 81       	ldd	r25, Y+5	; 0x05
    4384:	81 30       	cpi	r24, 0x01	; 1
    4386:	91 05       	cpc	r25, r1
    4388:	59 f1       	breq	.+86     	; 0x43e0 <GPIO_voidSetPinValue+0x172>
    438a:	2c 81       	ldd	r18, Y+4	; 0x04
    438c:	3d 81       	ldd	r19, Y+5	; 0x05
    438e:	22 30       	cpi	r18, 0x02	; 2
    4390:	31 05       	cpc	r19, r1
    4392:	2c f4       	brge	.+10     	; 0x439e <GPIO_voidSetPinValue+0x130>
    4394:	8c 81       	ldd	r24, Y+4	; 0x04
    4396:	9d 81       	ldd	r25, Y+5	; 0x05
    4398:	00 97       	sbiw	r24, 0x00	; 0
    439a:	69 f0       	breq	.+26     	; 0x43b6 <GPIO_voidSetPinValue+0x148>
    439c:	5f c0       	rjmp	.+190    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
    439e:	2c 81       	ldd	r18, Y+4	; 0x04
    43a0:	3d 81       	ldd	r19, Y+5	; 0x05
    43a2:	22 30       	cpi	r18, 0x02	; 2
    43a4:	31 05       	cpc	r19, r1
    43a6:	89 f1       	breq	.+98     	; 0x440a <GPIO_voidSetPinValue+0x19c>
    43a8:	8c 81       	ldd	r24, Y+4	; 0x04
    43aa:	9d 81       	ldd	r25, Y+5	; 0x05
    43ac:	83 30       	cpi	r24, 0x03	; 3
    43ae:	91 05       	cpc	r25, r1
    43b0:	09 f4       	brne	.+2      	; 0x43b4 <GPIO_voidSetPinValue+0x146>
    43b2:	40 c0       	rjmp	.+128    	; 0x4434 <GPIO_voidSetPinValue+0x1c6>
    43b4:	53 c0       	rjmp	.+166    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
		{
			case PORT_A :
			CLR_BIT (GPIO_PORTA , pin);
    43b6:	ab e3       	ldi	r26, 0x3B	; 59
    43b8:	b0 e0       	ldi	r27, 0x00	; 0
    43ba:	eb e3       	ldi	r30, 0x3B	; 59
    43bc:	f0 e0       	ldi	r31, 0x00	; 0
    43be:	80 81       	ld	r24, Z
    43c0:	48 2f       	mov	r20, r24
    43c2:	8a 81       	ldd	r24, Y+2	; 0x02
    43c4:	28 2f       	mov	r18, r24
    43c6:	30 e0       	ldi	r19, 0x00	; 0
    43c8:	81 e0       	ldi	r24, 0x01	; 1
    43ca:	90 e0       	ldi	r25, 0x00	; 0
    43cc:	02 2e       	mov	r0, r18
    43ce:	02 c0       	rjmp	.+4      	; 0x43d4 <GPIO_voidSetPinValue+0x166>
    43d0:	88 0f       	add	r24, r24
    43d2:	99 1f       	adc	r25, r25
    43d4:	0a 94       	dec	r0
    43d6:	e2 f7       	brpl	.-8      	; 0x43d0 <GPIO_voidSetPinValue+0x162>
    43d8:	80 95       	com	r24
    43da:	84 23       	and	r24, r20
    43dc:	8c 93       	st	X, r24
    43de:	3e c0       	rjmp	.+124    	; 0x445c <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_B :
			CLR_BIT (GPIO_PORTB , pin);
    43e0:	a8 e3       	ldi	r26, 0x38	; 56
    43e2:	b0 e0       	ldi	r27, 0x00	; 0
    43e4:	e8 e3       	ldi	r30, 0x38	; 56
    43e6:	f0 e0       	ldi	r31, 0x00	; 0
    43e8:	80 81       	ld	r24, Z
    43ea:	48 2f       	mov	r20, r24
    43ec:	8a 81       	ldd	r24, Y+2	; 0x02
    43ee:	28 2f       	mov	r18, r24
    43f0:	30 e0       	ldi	r19, 0x00	; 0
    43f2:	81 e0       	ldi	r24, 0x01	; 1
    43f4:	90 e0       	ldi	r25, 0x00	; 0
    43f6:	02 2e       	mov	r0, r18
    43f8:	02 c0       	rjmp	.+4      	; 0x43fe <GPIO_voidSetPinValue+0x190>
    43fa:	88 0f       	add	r24, r24
    43fc:	99 1f       	adc	r25, r25
    43fe:	0a 94       	dec	r0
    4400:	e2 f7       	brpl	.-8      	; 0x43fa <GPIO_voidSetPinValue+0x18c>
    4402:	80 95       	com	r24
    4404:	84 23       	and	r24, r20
    4406:	8c 93       	st	X, r24
    4408:	29 c0       	rjmp	.+82     	; 0x445c <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_C :
			CLR_BIT (GPIO_PORTC , pin);
    440a:	a5 e3       	ldi	r26, 0x35	; 53
    440c:	b0 e0       	ldi	r27, 0x00	; 0
    440e:	e5 e3       	ldi	r30, 0x35	; 53
    4410:	f0 e0       	ldi	r31, 0x00	; 0
    4412:	80 81       	ld	r24, Z
    4414:	48 2f       	mov	r20, r24
    4416:	8a 81       	ldd	r24, Y+2	; 0x02
    4418:	28 2f       	mov	r18, r24
    441a:	30 e0       	ldi	r19, 0x00	; 0
    441c:	81 e0       	ldi	r24, 0x01	; 1
    441e:	90 e0       	ldi	r25, 0x00	; 0
    4420:	02 2e       	mov	r0, r18
    4422:	02 c0       	rjmp	.+4      	; 0x4428 <GPIO_voidSetPinValue+0x1ba>
    4424:	88 0f       	add	r24, r24
    4426:	99 1f       	adc	r25, r25
    4428:	0a 94       	dec	r0
    442a:	e2 f7       	brpl	.-8      	; 0x4424 <GPIO_voidSetPinValue+0x1b6>
    442c:	80 95       	com	r24
    442e:	84 23       	and	r24, r20
    4430:	8c 93       	st	X, r24
    4432:	14 c0       	rjmp	.+40     	; 0x445c <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_D :
			CLR_BIT (GPIO_PORTD , pin);
    4434:	a2 e3       	ldi	r26, 0x32	; 50
    4436:	b0 e0       	ldi	r27, 0x00	; 0
    4438:	e2 e3       	ldi	r30, 0x32	; 50
    443a:	f0 e0       	ldi	r31, 0x00	; 0
    443c:	80 81       	ld	r24, Z
    443e:	48 2f       	mov	r20, r24
    4440:	8a 81       	ldd	r24, Y+2	; 0x02
    4442:	28 2f       	mov	r18, r24
    4444:	30 e0       	ldi	r19, 0x00	; 0
    4446:	81 e0       	ldi	r24, 0x01	; 1
    4448:	90 e0       	ldi	r25, 0x00	; 0
    444a:	02 2e       	mov	r0, r18
    444c:	02 c0       	rjmp	.+4      	; 0x4452 <GPIO_voidSetPinValue+0x1e4>
    444e:	88 0f       	add	r24, r24
    4450:	99 1f       	adc	r25, r25
    4452:	0a 94       	dec	r0
    4454:	e2 f7       	brpl	.-8      	; 0x444e <GPIO_voidSetPinValue+0x1e0>
    4456:	80 95       	com	r24
    4458:	84 23       	and	r24, r20
    445a:	8c 93       	st	X, r24
	{
		/* Should not be here */
	}


}
    445c:	27 96       	adiw	r28, 0x07	; 7
    445e:	0f b6       	in	r0, 0x3f	; 63
    4460:	f8 94       	cli
    4462:	de bf       	out	0x3e, r29	; 62
    4464:	0f be       	out	0x3f, r0	; 63
    4466:	cd bf       	out	0x3d, r28	; 61
    4468:	cf 91       	pop	r28
    446a:	df 91       	pop	r29
    446c:	08 95       	ret

0000446e <GPIO_voidSetPinDirection>:

void GPIO_voidSetPinDirection(u8 port_id , u8 pin , u8 dirc )
{
    446e:	df 93       	push	r29
    4470:	cf 93       	push	r28
    4472:	cd b7       	in	r28, 0x3d	; 61
    4474:	de b7       	in	r29, 0x3e	; 62
    4476:	27 97       	sbiw	r28, 0x07	; 7
    4478:	0f b6       	in	r0, 0x3f	; 63
    447a:	f8 94       	cli
    447c:	de bf       	out	0x3e, r29	; 62
    447e:	0f be       	out	0x3f, r0	; 63
    4480:	cd bf       	out	0x3d, r28	; 61
    4482:	89 83       	std	Y+1, r24	; 0x01
    4484:	6a 83       	std	Y+2, r22	; 0x02
    4486:	4b 83       	std	Y+3, r20	; 0x03
	if (dirc == OUTPUT)
    4488:	8b 81       	ldd	r24, Y+3	; 0x03
    448a:	81 30       	cpi	r24, 0x01	; 1
    448c:	09 f0       	breq	.+2      	; 0x4490 <GPIO_voidSetPinDirection+0x22>
    448e:	6f c0       	rjmp	.+222    	; 0x456e <GPIO_voidSetPinDirection+0x100>
	{
		switch (port_id)
    4490:	89 81       	ldd	r24, Y+1	; 0x01
    4492:	28 2f       	mov	r18, r24
    4494:	30 e0       	ldi	r19, 0x00	; 0
    4496:	3f 83       	std	Y+7, r19	; 0x07
    4498:	2e 83       	std	Y+6, r18	; 0x06
    449a:	8e 81       	ldd	r24, Y+6	; 0x06
    449c:	9f 81       	ldd	r25, Y+7	; 0x07
    449e:	81 30       	cpi	r24, 0x01	; 1
    44a0:	91 05       	cpc	r25, r1
    44a2:	49 f1       	breq	.+82     	; 0x44f6 <GPIO_voidSetPinDirection+0x88>
    44a4:	2e 81       	ldd	r18, Y+6	; 0x06
    44a6:	3f 81       	ldd	r19, Y+7	; 0x07
    44a8:	22 30       	cpi	r18, 0x02	; 2
    44aa:	31 05       	cpc	r19, r1
    44ac:	2c f4       	brge	.+10     	; 0x44b8 <GPIO_voidSetPinDirection+0x4a>
    44ae:	8e 81       	ldd	r24, Y+6	; 0x06
    44b0:	9f 81       	ldd	r25, Y+7	; 0x07
    44b2:	00 97       	sbiw	r24, 0x00	; 0
    44b4:	61 f0       	breq	.+24     	; 0x44ce <GPIO_voidSetPinDirection+0x60>
    44b6:	d2 c0       	rjmp	.+420    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
    44b8:	2e 81       	ldd	r18, Y+6	; 0x06
    44ba:	3f 81       	ldd	r19, Y+7	; 0x07
    44bc:	22 30       	cpi	r18, 0x02	; 2
    44be:	31 05       	cpc	r19, r1
    44c0:	71 f1       	breq	.+92     	; 0x451e <GPIO_voidSetPinDirection+0xb0>
    44c2:	8e 81       	ldd	r24, Y+6	; 0x06
    44c4:	9f 81       	ldd	r25, Y+7	; 0x07
    44c6:	83 30       	cpi	r24, 0x03	; 3
    44c8:	91 05       	cpc	r25, r1
    44ca:	e9 f1       	breq	.+122    	; 0x4546 <GPIO_voidSetPinDirection+0xd8>
    44cc:	c7 c0       	rjmp	.+398    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
		{
			case PORT_A :
			SET_BIT (GPIO_DDRA , pin);
    44ce:	aa e3       	ldi	r26, 0x3A	; 58
    44d0:	b0 e0       	ldi	r27, 0x00	; 0
    44d2:	ea e3       	ldi	r30, 0x3A	; 58
    44d4:	f0 e0       	ldi	r31, 0x00	; 0
    44d6:	80 81       	ld	r24, Z
    44d8:	48 2f       	mov	r20, r24
    44da:	8a 81       	ldd	r24, Y+2	; 0x02
    44dc:	28 2f       	mov	r18, r24
    44de:	30 e0       	ldi	r19, 0x00	; 0
    44e0:	81 e0       	ldi	r24, 0x01	; 1
    44e2:	90 e0       	ldi	r25, 0x00	; 0
    44e4:	02 2e       	mov	r0, r18
    44e6:	02 c0       	rjmp	.+4      	; 0x44ec <GPIO_voidSetPinDirection+0x7e>
    44e8:	88 0f       	add	r24, r24
    44ea:	99 1f       	adc	r25, r25
    44ec:	0a 94       	dec	r0
    44ee:	e2 f7       	brpl	.-8      	; 0x44e8 <GPIO_voidSetPinDirection+0x7a>
    44f0:	84 2b       	or	r24, r20
    44f2:	8c 93       	st	X, r24
    44f4:	b3 c0       	rjmp	.+358    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_B :
			SET_BIT (GPIO_DDRB , pin);
    44f6:	a7 e3       	ldi	r26, 0x37	; 55
    44f8:	b0 e0       	ldi	r27, 0x00	; 0
    44fa:	e7 e3       	ldi	r30, 0x37	; 55
    44fc:	f0 e0       	ldi	r31, 0x00	; 0
    44fe:	80 81       	ld	r24, Z
    4500:	48 2f       	mov	r20, r24
    4502:	8a 81       	ldd	r24, Y+2	; 0x02
    4504:	28 2f       	mov	r18, r24
    4506:	30 e0       	ldi	r19, 0x00	; 0
    4508:	81 e0       	ldi	r24, 0x01	; 1
    450a:	90 e0       	ldi	r25, 0x00	; 0
    450c:	02 2e       	mov	r0, r18
    450e:	02 c0       	rjmp	.+4      	; 0x4514 <GPIO_voidSetPinDirection+0xa6>
    4510:	88 0f       	add	r24, r24
    4512:	99 1f       	adc	r25, r25
    4514:	0a 94       	dec	r0
    4516:	e2 f7       	brpl	.-8      	; 0x4510 <GPIO_voidSetPinDirection+0xa2>
    4518:	84 2b       	or	r24, r20
    451a:	8c 93       	st	X, r24
    451c:	9f c0       	rjmp	.+318    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_C :
			SET_BIT (GPIO_DDRC , pin);
    451e:	a4 e3       	ldi	r26, 0x34	; 52
    4520:	b0 e0       	ldi	r27, 0x00	; 0
    4522:	e4 e3       	ldi	r30, 0x34	; 52
    4524:	f0 e0       	ldi	r31, 0x00	; 0
    4526:	80 81       	ld	r24, Z
    4528:	48 2f       	mov	r20, r24
    452a:	8a 81       	ldd	r24, Y+2	; 0x02
    452c:	28 2f       	mov	r18, r24
    452e:	30 e0       	ldi	r19, 0x00	; 0
    4530:	81 e0       	ldi	r24, 0x01	; 1
    4532:	90 e0       	ldi	r25, 0x00	; 0
    4534:	02 2e       	mov	r0, r18
    4536:	02 c0       	rjmp	.+4      	; 0x453c <GPIO_voidSetPinDirection+0xce>
    4538:	88 0f       	add	r24, r24
    453a:	99 1f       	adc	r25, r25
    453c:	0a 94       	dec	r0
    453e:	e2 f7       	brpl	.-8      	; 0x4538 <GPIO_voidSetPinDirection+0xca>
    4540:	84 2b       	or	r24, r20
    4542:	8c 93       	st	X, r24
    4544:	8b c0       	rjmp	.+278    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_D :
			SET_BIT (GPIO_DDRD , pin);
    4546:	a1 e3       	ldi	r26, 0x31	; 49
    4548:	b0 e0       	ldi	r27, 0x00	; 0
    454a:	e1 e3       	ldi	r30, 0x31	; 49
    454c:	f0 e0       	ldi	r31, 0x00	; 0
    454e:	80 81       	ld	r24, Z
    4550:	48 2f       	mov	r20, r24
    4552:	8a 81       	ldd	r24, Y+2	; 0x02
    4554:	28 2f       	mov	r18, r24
    4556:	30 e0       	ldi	r19, 0x00	; 0
    4558:	81 e0       	ldi	r24, 0x01	; 1
    455a:	90 e0       	ldi	r25, 0x00	; 0
    455c:	02 2e       	mov	r0, r18
    455e:	02 c0       	rjmp	.+4      	; 0x4564 <GPIO_voidSetPinDirection+0xf6>
    4560:	88 0f       	add	r24, r24
    4562:	99 1f       	adc	r25, r25
    4564:	0a 94       	dec	r0
    4566:	e2 f7       	brpl	.-8      	; 0x4560 <GPIO_voidSetPinDirection+0xf2>
    4568:	84 2b       	or	r24, r20
    456a:	8c 93       	st	X, r24
    456c:	77 c0       	rjmp	.+238    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>

			default:
			break;
		}
	}
	else if (dirc == INPUT)
    456e:	8b 81       	ldd	r24, Y+3	; 0x03
    4570:	88 23       	and	r24, r24
    4572:	09 f0       	breq	.+2      	; 0x4576 <GPIO_voidSetPinDirection+0x108>
    4574:	73 c0       	rjmp	.+230    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
	{
		switch (port_id)
    4576:	89 81       	ldd	r24, Y+1	; 0x01
    4578:	28 2f       	mov	r18, r24
    457a:	30 e0       	ldi	r19, 0x00	; 0
    457c:	3d 83       	std	Y+5, r19	; 0x05
    457e:	2c 83       	std	Y+4, r18	; 0x04
    4580:	8c 81       	ldd	r24, Y+4	; 0x04
    4582:	9d 81       	ldd	r25, Y+5	; 0x05
    4584:	81 30       	cpi	r24, 0x01	; 1
    4586:	91 05       	cpc	r25, r1
    4588:	59 f1       	breq	.+86     	; 0x45e0 <GPIO_voidSetPinDirection+0x172>
    458a:	2c 81       	ldd	r18, Y+4	; 0x04
    458c:	3d 81       	ldd	r19, Y+5	; 0x05
    458e:	22 30       	cpi	r18, 0x02	; 2
    4590:	31 05       	cpc	r19, r1
    4592:	2c f4       	brge	.+10     	; 0x459e <GPIO_voidSetPinDirection+0x130>
    4594:	8c 81       	ldd	r24, Y+4	; 0x04
    4596:	9d 81       	ldd	r25, Y+5	; 0x05
    4598:	00 97       	sbiw	r24, 0x00	; 0
    459a:	69 f0       	breq	.+26     	; 0x45b6 <GPIO_voidSetPinDirection+0x148>
    459c:	5f c0       	rjmp	.+190    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
    459e:	2c 81       	ldd	r18, Y+4	; 0x04
    45a0:	3d 81       	ldd	r19, Y+5	; 0x05
    45a2:	22 30       	cpi	r18, 0x02	; 2
    45a4:	31 05       	cpc	r19, r1
    45a6:	89 f1       	breq	.+98     	; 0x460a <GPIO_voidSetPinDirection+0x19c>
    45a8:	8c 81       	ldd	r24, Y+4	; 0x04
    45aa:	9d 81       	ldd	r25, Y+5	; 0x05
    45ac:	83 30       	cpi	r24, 0x03	; 3
    45ae:	91 05       	cpc	r25, r1
    45b0:	09 f4       	brne	.+2      	; 0x45b4 <GPIO_voidSetPinDirection+0x146>
    45b2:	40 c0       	rjmp	.+128    	; 0x4634 <GPIO_voidSetPinDirection+0x1c6>
    45b4:	53 c0       	rjmp	.+166    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
		{
			case PORT_A :
			CLR_BIT (GPIO_DDRA , pin);
    45b6:	aa e3       	ldi	r26, 0x3A	; 58
    45b8:	b0 e0       	ldi	r27, 0x00	; 0
    45ba:	ea e3       	ldi	r30, 0x3A	; 58
    45bc:	f0 e0       	ldi	r31, 0x00	; 0
    45be:	80 81       	ld	r24, Z
    45c0:	48 2f       	mov	r20, r24
    45c2:	8a 81       	ldd	r24, Y+2	; 0x02
    45c4:	28 2f       	mov	r18, r24
    45c6:	30 e0       	ldi	r19, 0x00	; 0
    45c8:	81 e0       	ldi	r24, 0x01	; 1
    45ca:	90 e0       	ldi	r25, 0x00	; 0
    45cc:	02 2e       	mov	r0, r18
    45ce:	02 c0       	rjmp	.+4      	; 0x45d4 <GPIO_voidSetPinDirection+0x166>
    45d0:	88 0f       	add	r24, r24
    45d2:	99 1f       	adc	r25, r25
    45d4:	0a 94       	dec	r0
    45d6:	e2 f7       	brpl	.-8      	; 0x45d0 <GPIO_voidSetPinDirection+0x162>
    45d8:	80 95       	com	r24
    45da:	84 23       	and	r24, r20
    45dc:	8c 93       	st	X, r24
    45de:	3e c0       	rjmp	.+124    	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_B :
			CLR_BIT (GPIO_DDRB , pin);
    45e0:	a7 e3       	ldi	r26, 0x37	; 55
    45e2:	b0 e0       	ldi	r27, 0x00	; 0
    45e4:	e7 e3       	ldi	r30, 0x37	; 55
    45e6:	f0 e0       	ldi	r31, 0x00	; 0
    45e8:	80 81       	ld	r24, Z
    45ea:	48 2f       	mov	r20, r24
    45ec:	8a 81       	ldd	r24, Y+2	; 0x02
    45ee:	28 2f       	mov	r18, r24
    45f0:	30 e0       	ldi	r19, 0x00	; 0
    45f2:	81 e0       	ldi	r24, 0x01	; 1
    45f4:	90 e0       	ldi	r25, 0x00	; 0
    45f6:	02 2e       	mov	r0, r18
    45f8:	02 c0       	rjmp	.+4      	; 0x45fe <GPIO_voidSetPinDirection+0x190>
    45fa:	88 0f       	add	r24, r24
    45fc:	99 1f       	adc	r25, r25
    45fe:	0a 94       	dec	r0
    4600:	e2 f7       	brpl	.-8      	; 0x45fa <GPIO_voidSetPinDirection+0x18c>
    4602:	80 95       	com	r24
    4604:	84 23       	and	r24, r20
    4606:	8c 93       	st	X, r24
    4608:	29 c0       	rjmp	.+82     	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_C :
			CLR_BIT (GPIO_DDRC , pin);
    460a:	a4 e3       	ldi	r26, 0x34	; 52
    460c:	b0 e0       	ldi	r27, 0x00	; 0
    460e:	e4 e3       	ldi	r30, 0x34	; 52
    4610:	f0 e0       	ldi	r31, 0x00	; 0
    4612:	80 81       	ld	r24, Z
    4614:	48 2f       	mov	r20, r24
    4616:	8a 81       	ldd	r24, Y+2	; 0x02
    4618:	28 2f       	mov	r18, r24
    461a:	30 e0       	ldi	r19, 0x00	; 0
    461c:	81 e0       	ldi	r24, 0x01	; 1
    461e:	90 e0       	ldi	r25, 0x00	; 0
    4620:	02 2e       	mov	r0, r18
    4622:	02 c0       	rjmp	.+4      	; 0x4628 <GPIO_voidSetPinDirection+0x1ba>
    4624:	88 0f       	add	r24, r24
    4626:	99 1f       	adc	r25, r25
    4628:	0a 94       	dec	r0
    462a:	e2 f7       	brpl	.-8      	; 0x4624 <GPIO_voidSetPinDirection+0x1b6>
    462c:	80 95       	com	r24
    462e:	84 23       	and	r24, r20
    4630:	8c 93       	st	X, r24
    4632:	14 c0       	rjmp	.+40     	; 0x465c <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_D :
			CLR_BIT (GPIO_DDRD , pin);
    4634:	a1 e3       	ldi	r26, 0x31	; 49
    4636:	b0 e0       	ldi	r27, 0x00	; 0
    4638:	e1 e3       	ldi	r30, 0x31	; 49
    463a:	f0 e0       	ldi	r31, 0x00	; 0
    463c:	80 81       	ld	r24, Z
    463e:	48 2f       	mov	r20, r24
    4640:	8a 81       	ldd	r24, Y+2	; 0x02
    4642:	28 2f       	mov	r18, r24
    4644:	30 e0       	ldi	r19, 0x00	; 0
    4646:	81 e0       	ldi	r24, 0x01	; 1
    4648:	90 e0       	ldi	r25, 0x00	; 0
    464a:	02 2e       	mov	r0, r18
    464c:	02 c0       	rjmp	.+4      	; 0x4652 <GPIO_voidSetPinDirection+0x1e4>
    464e:	88 0f       	add	r24, r24
    4650:	99 1f       	adc	r25, r25
    4652:	0a 94       	dec	r0
    4654:	e2 f7       	brpl	.-8      	; 0x464e <GPIO_voidSetPinDirection+0x1e0>
    4656:	80 95       	com	r24
    4658:	84 23       	and	r24, r20
    465a:	8c 93       	st	X, r24
	}
	else
	{
		/* Should not be here */
	}
}
    465c:	27 96       	adiw	r28, 0x07	; 7
    465e:	0f b6       	in	r0, 0x3f	; 63
    4660:	f8 94       	cli
    4662:	de bf       	out	0x3e, r29	; 62
    4664:	0f be       	out	0x3f, r0	; 63
    4666:	cd bf       	out	0x3d, r28	; 61
    4668:	cf 91       	pop	r28
    466a:	df 91       	pop	r29
    466c:	08 95       	ret

0000466e <GPIO_voidSetPortValue>:

void GPIO_voidSetPortValue(u8 port_id , u8 value)
{
    466e:	df 93       	push	r29
    4670:	cf 93       	push	r28
    4672:	00 d0       	rcall	.+0      	; 0x4674 <GPIO_voidSetPortValue+0x6>
    4674:	00 d0       	rcall	.+0      	; 0x4676 <GPIO_voidSetPortValue+0x8>
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
    467a:	89 83       	std	Y+1, r24	; 0x01
    467c:	6a 83       	std	Y+2, r22	; 0x02
	switch (port_id){
    467e:	89 81       	ldd	r24, Y+1	; 0x01
    4680:	28 2f       	mov	r18, r24
    4682:	30 e0       	ldi	r19, 0x00	; 0
    4684:	3c 83       	std	Y+4, r19	; 0x04
    4686:	2b 83       	std	Y+3, r18	; 0x03
    4688:	8b 81       	ldd	r24, Y+3	; 0x03
    468a:	9c 81       	ldd	r25, Y+4	; 0x04
    468c:	81 30       	cpi	r24, 0x01	; 1
    468e:	91 05       	cpc	r25, r1
    4690:	d1 f0       	breq	.+52     	; 0x46c6 <GPIO_voidSetPortValue+0x58>
    4692:	2b 81       	ldd	r18, Y+3	; 0x03
    4694:	3c 81       	ldd	r19, Y+4	; 0x04
    4696:	22 30       	cpi	r18, 0x02	; 2
    4698:	31 05       	cpc	r19, r1
    469a:	2c f4       	brge	.+10     	; 0x46a6 <GPIO_voidSetPortValue+0x38>
    469c:	8b 81       	ldd	r24, Y+3	; 0x03
    469e:	9c 81       	ldd	r25, Y+4	; 0x04
    46a0:	00 97       	sbiw	r24, 0x00	; 0
    46a2:	61 f0       	breq	.+24     	; 0x46bc <GPIO_voidSetPortValue+0x4e>
    46a4:	1e c0       	rjmp	.+60     	; 0x46e2 <GPIO_voidSetPortValue+0x74>
    46a6:	2b 81       	ldd	r18, Y+3	; 0x03
    46a8:	3c 81       	ldd	r19, Y+4	; 0x04
    46aa:	22 30       	cpi	r18, 0x02	; 2
    46ac:	31 05       	cpc	r19, r1
    46ae:	81 f0       	breq	.+32     	; 0x46d0 <GPIO_voidSetPortValue+0x62>
    46b0:	8b 81       	ldd	r24, Y+3	; 0x03
    46b2:	9c 81       	ldd	r25, Y+4	; 0x04
    46b4:	83 30       	cpi	r24, 0x03	; 3
    46b6:	91 05       	cpc	r25, r1
    46b8:	81 f0       	breq	.+32     	; 0x46da <GPIO_voidSetPortValue+0x6c>
    46ba:	13 c0       	rjmp	.+38     	; 0x46e2 <GPIO_voidSetPortValue+0x74>
		case PORT_A :
			GPIO_PORTA = value ;
    46bc:	eb e3       	ldi	r30, 0x3B	; 59
    46be:	f0 e0       	ldi	r31, 0x00	; 0
    46c0:	8a 81       	ldd	r24, Y+2	; 0x02
    46c2:	80 83       	st	Z, r24
    46c4:	0e c0       	rjmp	.+28     	; 0x46e2 <GPIO_voidSetPortValue+0x74>
			break;

		case PORT_B :
			GPIO_PORTB = value ;
    46c6:	e8 e3       	ldi	r30, 0x38	; 56
    46c8:	f0 e0       	ldi	r31, 0x00	; 0
    46ca:	8a 81       	ldd	r24, Y+2	; 0x02
    46cc:	80 83       	st	Z, r24
    46ce:	09 c0       	rjmp	.+18     	; 0x46e2 <GPIO_voidSetPortValue+0x74>
			break;

		case PORT_C :
			GPIO_PORTC = value ;
    46d0:	e5 e3       	ldi	r30, 0x35	; 53
    46d2:	f0 e0       	ldi	r31, 0x00	; 0
    46d4:	8a 81       	ldd	r24, Y+2	; 0x02
    46d6:	80 83       	st	Z, r24
    46d8:	04 c0       	rjmp	.+8      	; 0x46e2 <GPIO_voidSetPortValue+0x74>
			break;

		case PORT_D :
			GPIO_PORTD = value ;
    46da:	e2 e3       	ldi	r30, 0x32	; 50
    46dc:	f0 e0       	ldi	r31, 0x00	; 0
    46de:	8a 81       	ldd	r24, Y+2	; 0x02
    46e0:	80 83       	st	Z, r24
			break;

		default:
			break;
	}
}
    46e2:	0f 90       	pop	r0
    46e4:	0f 90       	pop	r0
    46e6:	0f 90       	pop	r0
    46e8:	0f 90       	pop	r0
    46ea:	cf 91       	pop	r28
    46ec:	df 91       	pop	r29
    46ee:	08 95       	ret

000046f0 <GPIO_voidSetPortDirection>:

void GPIO_voidSetPortDirection(u8 port_id , u8 dirc)
{
    46f0:	df 93       	push	r29
    46f2:	cf 93       	push	r28
    46f4:	00 d0       	rcall	.+0      	; 0x46f6 <GPIO_voidSetPortDirection+0x6>
    46f6:	00 d0       	rcall	.+0      	; 0x46f8 <GPIO_voidSetPortDirection+0x8>
    46f8:	00 d0       	rcall	.+0      	; 0x46fa <GPIO_voidSetPortDirection+0xa>
    46fa:	cd b7       	in	r28, 0x3d	; 61
    46fc:	de b7       	in	r29, 0x3e	; 62
    46fe:	89 83       	std	Y+1, r24	; 0x01
    4700:	6a 83       	std	Y+2, r22	; 0x02
	if (dirc == OUTPUT)
    4702:	8a 81       	ldd	r24, Y+2	; 0x02
    4704:	81 30       	cpi	r24, 0x01	; 1
    4706:	99 f5       	brne	.+102    	; 0x476e <GPIO_voidSetPortDirection+0x7e>
	{
		switch (port_id){
    4708:	89 81       	ldd	r24, Y+1	; 0x01
    470a:	28 2f       	mov	r18, r24
    470c:	30 e0       	ldi	r19, 0x00	; 0
    470e:	3e 83       	std	Y+6, r19	; 0x06
    4710:	2d 83       	std	Y+5, r18	; 0x05
    4712:	8d 81       	ldd	r24, Y+5	; 0x05
    4714:	9e 81       	ldd	r25, Y+6	; 0x06
    4716:	81 30       	cpi	r24, 0x01	; 1
    4718:	91 05       	cpc	r25, r1
    471a:	d1 f0       	breq	.+52     	; 0x4750 <GPIO_voidSetPortDirection+0x60>
    471c:	2d 81       	ldd	r18, Y+5	; 0x05
    471e:	3e 81       	ldd	r19, Y+6	; 0x06
    4720:	22 30       	cpi	r18, 0x02	; 2
    4722:	31 05       	cpc	r19, r1
    4724:	2c f4       	brge	.+10     	; 0x4730 <GPIO_voidSetPortDirection+0x40>
    4726:	8d 81       	ldd	r24, Y+5	; 0x05
    4728:	9e 81       	ldd	r25, Y+6	; 0x06
    472a:	00 97       	sbiw	r24, 0x00	; 0
    472c:	61 f0       	breq	.+24     	; 0x4746 <GPIO_voidSetPortDirection+0x56>
    472e:	50 c0       	rjmp	.+160    	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
    4730:	2d 81       	ldd	r18, Y+5	; 0x05
    4732:	3e 81       	ldd	r19, Y+6	; 0x06
    4734:	22 30       	cpi	r18, 0x02	; 2
    4736:	31 05       	cpc	r19, r1
    4738:	81 f0       	breq	.+32     	; 0x475a <GPIO_voidSetPortDirection+0x6a>
    473a:	8d 81       	ldd	r24, Y+5	; 0x05
    473c:	9e 81       	ldd	r25, Y+6	; 0x06
    473e:	83 30       	cpi	r24, 0x03	; 3
    4740:	91 05       	cpc	r25, r1
    4742:	81 f0       	breq	.+32     	; 0x4764 <GPIO_voidSetPortDirection+0x74>
    4744:	45 c0       	rjmp	.+138    	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
			case PORT_A :
				GPIO_DDRA = 255;
    4746:	ea e3       	ldi	r30, 0x3A	; 58
    4748:	f0 e0       	ldi	r31, 0x00	; 0
    474a:	8f ef       	ldi	r24, 0xFF	; 255
    474c:	80 83       	st	Z, r24
    474e:	40 c0       	rjmp	.+128    	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;
			case PORT_B :
				GPIO_DDRB = 255;
    4750:	e7 e3       	ldi	r30, 0x37	; 55
    4752:	f0 e0       	ldi	r31, 0x00	; 0
    4754:	8f ef       	ldi	r24, 0xFF	; 255
    4756:	80 83       	st	Z, r24
    4758:	3b c0       	rjmp	.+118    	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;
			case PORT_C :
				GPIO_DDRC = 255;
    475a:	e4 e3       	ldi	r30, 0x34	; 52
    475c:	f0 e0       	ldi	r31, 0x00	; 0
    475e:	8f ef       	ldi	r24, 0xFF	; 255
    4760:	80 83       	st	Z, r24
    4762:	36 c0       	rjmp	.+108    	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;
			case PORT_D :
				GPIO_DDRD = 255;
    4764:	e1 e3       	ldi	r30, 0x31	; 49
    4766:	f0 e0       	ldi	r31, 0x00	; 0
    4768:	8f ef       	ldi	r24, 0xFF	; 255
    476a:	80 83       	st	Z, r24
    476c:	31 c0       	rjmp	.+98     	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;
			default:
				break;
		}
	}
	else if (dirc == INPUT)
    476e:	8a 81       	ldd	r24, Y+2	; 0x02
    4770:	88 23       	and	r24, r24
    4772:	71 f5       	brne	.+92     	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
	{
		switch (port_id){
    4774:	89 81       	ldd	r24, Y+1	; 0x01
    4776:	28 2f       	mov	r18, r24
    4778:	30 e0       	ldi	r19, 0x00	; 0
    477a:	3c 83       	std	Y+4, r19	; 0x04
    477c:	2b 83       	std	Y+3, r18	; 0x03
    477e:	8b 81       	ldd	r24, Y+3	; 0x03
    4780:	9c 81       	ldd	r25, Y+4	; 0x04
    4782:	81 30       	cpi	r24, 0x01	; 1
    4784:	91 05       	cpc	r25, r1
    4786:	c9 f0       	breq	.+50     	; 0x47ba <GPIO_voidSetPortDirection+0xca>
    4788:	2b 81       	ldd	r18, Y+3	; 0x03
    478a:	3c 81       	ldd	r19, Y+4	; 0x04
    478c:	22 30       	cpi	r18, 0x02	; 2
    478e:	31 05       	cpc	r19, r1
    4790:	2c f4       	brge	.+10     	; 0x479c <GPIO_voidSetPortDirection+0xac>
    4792:	8b 81       	ldd	r24, Y+3	; 0x03
    4794:	9c 81       	ldd	r25, Y+4	; 0x04
    4796:	00 97       	sbiw	r24, 0x00	; 0
    4798:	61 f0       	breq	.+24     	; 0x47b2 <GPIO_voidSetPortDirection+0xc2>
    479a:	1a c0       	rjmp	.+52     	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
    479c:	2b 81       	ldd	r18, Y+3	; 0x03
    479e:	3c 81       	ldd	r19, Y+4	; 0x04
    47a0:	22 30       	cpi	r18, 0x02	; 2
    47a2:	31 05       	cpc	r19, r1
    47a4:	71 f0       	breq	.+28     	; 0x47c2 <GPIO_voidSetPortDirection+0xd2>
    47a6:	8b 81       	ldd	r24, Y+3	; 0x03
    47a8:	9c 81       	ldd	r25, Y+4	; 0x04
    47aa:	83 30       	cpi	r24, 0x03	; 3
    47ac:	91 05       	cpc	r25, r1
    47ae:	69 f0       	breq	.+26     	; 0x47ca <GPIO_voidSetPortDirection+0xda>
    47b0:	0f c0       	rjmp	.+30     	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
			case PORT_A :
				GPIO_DDRA = 0;
    47b2:	ea e3       	ldi	r30, 0x3A	; 58
    47b4:	f0 e0       	ldi	r31, 0x00	; 0
    47b6:	10 82       	st	Z, r1
    47b8:	0b c0       	rjmp	.+22     	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;

			case PORT_B :
				GPIO_DDRB = 0;
    47ba:	e7 e3       	ldi	r30, 0x37	; 55
    47bc:	f0 e0       	ldi	r31, 0x00	; 0
    47be:	10 82       	st	Z, r1
    47c0:	07 c0       	rjmp	.+14     	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;

			case PORT_C :
				GPIO_DDRC = 0;
    47c2:	e4 e3       	ldi	r30, 0x34	; 52
    47c4:	f0 e0       	ldi	r31, 0x00	; 0
    47c6:	10 82       	st	Z, r1
    47c8:	03 c0       	rjmp	.+6      	; 0x47d0 <GPIO_voidSetPortDirection+0xe0>
				break;

			case PORT_D :
				GPIO_DDRD = 0;
    47ca:	e1 e3       	ldi	r30, 0x31	; 49
    47cc:	f0 e0       	ldi	r31, 0x00	; 0
    47ce:	10 82       	st	Z, r1
		}
	}
	else {

	}
}
    47d0:	26 96       	adiw	r28, 0x06	; 6
    47d2:	0f b6       	in	r0, 0x3f	; 63
    47d4:	f8 94       	cli
    47d6:	de bf       	out	0x3e, r29	; 62
    47d8:	0f be       	out	0x3f, r0	; 63
    47da:	cd bf       	out	0x3d, r28	; 61
    47dc:	cf 91       	pop	r28
    47de:	df 91       	pop	r29
    47e0:	08 95       	ret

000047e2 <GPIO_u8GetPinValue>:

u8 GPIO_u8GetPinValue(u8 port_id , u8 pin)
{
    47e2:	df 93       	push	r29
    47e4:	cf 93       	push	r28
    47e6:	00 d0       	rcall	.+0      	; 0x47e8 <GPIO_u8GetPinValue+0x6>
    47e8:	00 d0       	rcall	.+0      	; 0x47ea <GPIO_u8GetPinValue+0x8>
    47ea:	0f 92       	push	r0
    47ec:	cd b7       	in	r28, 0x3d	; 61
    47ee:	de b7       	in	r29, 0x3e	; 62
    47f0:	8a 83       	std	Y+2, r24	; 0x02
    47f2:	6b 83       	std	Y+3, r22	; 0x03
	u8 value ;
	switch (port_id)
    47f4:	8a 81       	ldd	r24, Y+2	; 0x02
    47f6:	28 2f       	mov	r18, r24
    47f8:	30 e0       	ldi	r19, 0x00	; 0
    47fa:	3d 83       	std	Y+5, r19	; 0x05
    47fc:	2c 83       	std	Y+4, r18	; 0x04
    47fe:	4c 81       	ldd	r20, Y+4	; 0x04
    4800:	5d 81       	ldd	r21, Y+5	; 0x05
    4802:	41 30       	cpi	r20, 0x01	; 1
    4804:	51 05       	cpc	r21, r1
    4806:	41 f1       	breq	.+80     	; 0x4858 <GPIO_u8GetPinValue+0x76>
    4808:	8c 81       	ldd	r24, Y+4	; 0x04
    480a:	9d 81       	ldd	r25, Y+5	; 0x05
    480c:	82 30       	cpi	r24, 0x02	; 2
    480e:	91 05       	cpc	r25, r1
    4810:	34 f4       	brge	.+12     	; 0x481e <GPIO_u8GetPinValue+0x3c>
    4812:	2c 81       	ldd	r18, Y+4	; 0x04
    4814:	3d 81       	ldd	r19, Y+5	; 0x05
    4816:	21 15       	cp	r18, r1
    4818:	31 05       	cpc	r19, r1
    481a:	61 f0       	breq	.+24     	; 0x4834 <GPIO_u8GetPinValue+0x52>
    481c:	52 c0       	rjmp	.+164    	; 0x48c2 <GPIO_u8GetPinValue+0xe0>
    481e:	4c 81       	ldd	r20, Y+4	; 0x04
    4820:	5d 81       	ldd	r21, Y+5	; 0x05
    4822:	42 30       	cpi	r20, 0x02	; 2
    4824:	51 05       	cpc	r21, r1
    4826:	51 f1       	breq	.+84     	; 0x487c <GPIO_u8GetPinValue+0x9a>
    4828:	8c 81       	ldd	r24, Y+4	; 0x04
    482a:	9d 81       	ldd	r25, Y+5	; 0x05
    482c:	83 30       	cpi	r24, 0x03	; 3
    482e:	91 05       	cpc	r25, r1
    4830:	b9 f1       	breq	.+110    	; 0x48a0 <GPIO_u8GetPinValue+0xbe>
    4832:	47 c0       	rjmp	.+142    	; 0x48c2 <GPIO_u8GetPinValue+0xe0>
	{
		case PORT_A :
		value = GET_BIT(GPIO_PINA , pin);
    4834:	e9 e3       	ldi	r30, 0x39	; 57
    4836:	f0 e0       	ldi	r31, 0x00	; 0
    4838:	80 81       	ld	r24, Z
    483a:	28 2f       	mov	r18, r24
    483c:	30 e0       	ldi	r19, 0x00	; 0
    483e:	8b 81       	ldd	r24, Y+3	; 0x03
    4840:	88 2f       	mov	r24, r24
    4842:	90 e0       	ldi	r25, 0x00	; 0
    4844:	a9 01       	movw	r20, r18
    4846:	02 c0       	rjmp	.+4      	; 0x484c <GPIO_u8GetPinValue+0x6a>
    4848:	55 95       	asr	r21
    484a:	47 95       	ror	r20
    484c:	8a 95       	dec	r24
    484e:	e2 f7       	brpl	.-8      	; 0x4848 <GPIO_u8GetPinValue+0x66>
    4850:	ca 01       	movw	r24, r20
    4852:	81 70       	andi	r24, 0x01	; 1
    4854:	89 83       	std	Y+1, r24	; 0x01
    4856:	35 c0       	rjmp	.+106    	; 0x48c2 <GPIO_u8GetPinValue+0xe0>
		break;

		case PORT_B :
		value = GET_BIT(GPIO_PINB , pin);
    4858:	e6 e3       	ldi	r30, 0x36	; 54
    485a:	f0 e0       	ldi	r31, 0x00	; 0
    485c:	80 81       	ld	r24, Z
    485e:	28 2f       	mov	r18, r24
    4860:	30 e0       	ldi	r19, 0x00	; 0
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
    4864:	88 2f       	mov	r24, r24
    4866:	90 e0       	ldi	r25, 0x00	; 0
    4868:	a9 01       	movw	r20, r18
    486a:	02 c0       	rjmp	.+4      	; 0x4870 <GPIO_u8GetPinValue+0x8e>
    486c:	55 95       	asr	r21
    486e:	47 95       	ror	r20
    4870:	8a 95       	dec	r24
    4872:	e2 f7       	brpl	.-8      	; 0x486c <GPIO_u8GetPinValue+0x8a>
    4874:	ca 01       	movw	r24, r20
    4876:	81 70       	andi	r24, 0x01	; 1
    4878:	89 83       	std	Y+1, r24	; 0x01
    487a:	23 c0       	rjmp	.+70     	; 0x48c2 <GPIO_u8GetPinValue+0xe0>
		break;

		case PORT_C :
		value = GET_BIT(GPIO_PINC , pin);
    487c:	e3 e3       	ldi	r30, 0x33	; 51
    487e:	f0 e0       	ldi	r31, 0x00	; 0
    4880:	80 81       	ld	r24, Z
    4882:	28 2f       	mov	r18, r24
    4884:	30 e0       	ldi	r19, 0x00	; 0
    4886:	8b 81       	ldd	r24, Y+3	; 0x03
    4888:	88 2f       	mov	r24, r24
    488a:	90 e0       	ldi	r25, 0x00	; 0
    488c:	a9 01       	movw	r20, r18
    488e:	02 c0       	rjmp	.+4      	; 0x4894 <GPIO_u8GetPinValue+0xb2>
    4890:	55 95       	asr	r21
    4892:	47 95       	ror	r20
    4894:	8a 95       	dec	r24
    4896:	e2 f7       	brpl	.-8      	; 0x4890 <GPIO_u8GetPinValue+0xae>
    4898:	ca 01       	movw	r24, r20
    489a:	81 70       	andi	r24, 0x01	; 1
    489c:	89 83       	std	Y+1, r24	; 0x01
    489e:	11 c0       	rjmp	.+34     	; 0x48c2 <GPIO_u8GetPinValue+0xe0>
		break;

		case PORT_D :
		value = GET_BIT(GPIO_PIND , pin);
    48a0:	e0 e3       	ldi	r30, 0x30	; 48
    48a2:	f0 e0       	ldi	r31, 0x00	; 0
    48a4:	80 81       	ld	r24, Z
    48a6:	28 2f       	mov	r18, r24
    48a8:	30 e0       	ldi	r19, 0x00	; 0
    48aa:	8b 81       	ldd	r24, Y+3	; 0x03
    48ac:	88 2f       	mov	r24, r24
    48ae:	90 e0       	ldi	r25, 0x00	; 0
    48b0:	a9 01       	movw	r20, r18
    48b2:	02 c0       	rjmp	.+4      	; 0x48b8 <GPIO_u8GetPinValue+0xd6>
    48b4:	55 95       	asr	r21
    48b6:	47 95       	ror	r20
    48b8:	8a 95       	dec	r24
    48ba:	e2 f7       	brpl	.-8      	; 0x48b4 <GPIO_u8GetPinValue+0xd2>
    48bc:	ca 01       	movw	r24, r20
    48be:	81 70       	andi	r24, 0x01	; 1
    48c0:	89 83       	std	Y+1, r24	; 0x01
		break;

		default:
		break;
	}
	return value ;
    48c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    48c4:	0f 90       	pop	r0
    48c6:	0f 90       	pop	r0
    48c8:	0f 90       	pop	r0
    48ca:	0f 90       	pop	r0
    48cc:	0f 90       	pop	r0
    48ce:	cf 91       	pop	r28
    48d0:	df 91       	pop	r29
    48d2:	08 95       	ret

000048d4 <LCD_voidInit>:
#include "LCD_Private.h"
#include "LCD_Cfg.h"


void LCD_voidInit(void)
{
    48d4:	0f 93       	push	r16
    48d6:	1f 93       	push	r17
    48d8:	df 93       	push	r29
    48da:	cf 93       	push	r28
    48dc:	cd b7       	in	r28, 0x3d	; 61
    48de:	de b7       	in	r29, 0x3e	; 62
    48e0:	c4 55       	subi	r28, 0x54	; 84
    48e2:	d0 40       	sbci	r29, 0x00	; 0
    48e4:	0f b6       	in	r0, 0x3f	; 63
    48e6:	f8 94       	cli
    48e8:	de bf       	out	0x3e, r29	; 62
    48ea:	0f be       	out	0x3f, r0	; 63
    48ec:	cd bf       	out	0x3d, r28	; 61
    48ee:	fe 01       	movw	r30, r28
    48f0:	ef 5a       	subi	r30, 0xAF	; 175
    48f2:	ff 4f       	sbci	r31, 0xFF	; 255
    48f4:	80 e0       	ldi	r24, 0x00	; 0
    48f6:	90 e0       	ldi	r25, 0x00	; 0
    48f8:	a0 ef       	ldi	r26, 0xF0	; 240
    48fa:	b1 e4       	ldi	r27, 0x41	; 65
    48fc:	80 83       	st	Z, r24
    48fe:	91 83       	std	Z+1, r25	; 0x01
    4900:	a2 83       	std	Z+2, r26	; 0x02
    4902:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4904:	8e 01       	movw	r16, r28
    4906:	03 5b       	subi	r16, 0xB3	; 179
    4908:	1f 4f       	sbci	r17, 0xFF	; 255
    490a:	fe 01       	movw	r30, r28
    490c:	ef 5a       	subi	r30, 0xAF	; 175
    490e:	ff 4f       	sbci	r31, 0xFF	; 255
    4910:	60 81       	ld	r22, Z
    4912:	71 81       	ldd	r23, Z+1	; 0x01
    4914:	82 81       	ldd	r24, Z+2	; 0x02
    4916:	93 81       	ldd	r25, Z+3	; 0x03
    4918:	20 e0       	ldi	r18, 0x00	; 0
    491a:	30 e0       	ldi	r19, 0x00	; 0
    491c:	4a ef       	ldi	r20, 0xFA	; 250
    491e:	54 e4       	ldi	r21, 0x44	; 68
    4920:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4924:	dc 01       	movw	r26, r24
    4926:	cb 01       	movw	r24, r22
    4928:	f8 01       	movw	r30, r16
    492a:	80 83       	st	Z, r24
    492c:	91 83       	std	Z+1, r25	; 0x01
    492e:	a2 83       	std	Z+2, r26	; 0x02
    4930:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    4932:	fe 01       	movw	r30, r28
    4934:	e3 5b       	subi	r30, 0xB3	; 179
    4936:	ff 4f       	sbci	r31, 0xFF	; 255
    4938:	60 81       	ld	r22, Z
    493a:	71 81       	ldd	r23, Z+1	; 0x01
    493c:	82 81       	ldd	r24, Z+2	; 0x02
    493e:	93 81       	ldd	r25, Z+3	; 0x03
    4940:	20 e0       	ldi	r18, 0x00	; 0
    4942:	30 e0       	ldi	r19, 0x00	; 0
    4944:	40 e8       	ldi	r20, 0x80	; 128
    4946:	5f e3       	ldi	r21, 0x3F	; 63
    4948:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    494c:	88 23       	and	r24, r24
    494e:	44 f4       	brge	.+16     	; 0x4960 <LCD_voidInit+0x8c>
		__ticks = 1;
    4950:	fe 01       	movw	r30, r28
    4952:	e5 5b       	subi	r30, 0xB5	; 181
    4954:	ff 4f       	sbci	r31, 0xFF	; 255
    4956:	81 e0       	ldi	r24, 0x01	; 1
    4958:	90 e0       	ldi	r25, 0x00	; 0
    495a:	91 83       	std	Z+1, r25	; 0x01
    495c:	80 83       	st	Z, r24
    495e:	64 c0       	rjmp	.+200    	; 0x4a28 <LCD_voidInit+0x154>
	else if (__tmp > 65535)
    4960:	fe 01       	movw	r30, r28
    4962:	e3 5b       	subi	r30, 0xB3	; 179
    4964:	ff 4f       	sbci	r31, 0xFF	; 255
    4966:	60 81       	ld	r22, Z
    4968:	71 81       	ldd	r23, Z+1	; 0x01
    496a:	82 81       	ldd	r24, Z+2	; 0x02
    496c:	93 81       	ldd	r25, Z+3	; 0x03
    496e:	20 e0       	ldi	r18, 0x00	; 0
    4970:	3f ef       	ldi	r19, 0xFF	; 255
    4972:	4f e7       	ldi	r20, 0x7F	; 127
    4974:	57 e4       	ldi	r21, 0x47	; 71
    4976:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    497a:	18 16       	cp	r1, r24
    497c:	0c f0       	brlt	.+2      	; 0x4980 <LCD_voidInit+0xac>
    497e:	43 c0       	rjmp	.+134    	; 0x4a06 <LCD_voidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4980:	fe 01       	movw	r30, r28
    4982:	ef 5a       	subi	r30, 0xAF	; 175
    4984:	ff 4f       	sbci	r31, 0xFF	; 255
    4986:	60 81       	ld	r22, Z
    4988:	71 81       	ldd	r23, Z+1	; 0x01
    498a:	82 81       	ldd	r24, Z+2	; 0x02
    498c:	93 81       	ldd	r25, Z+3	; 0x03
    498e:	20 e0       	ldi	r18, 0x00	; 0
    4990:	30 e0       	ldi	r19, 0x00	; 0
    4992:	40 e2       	ldi	r20, 0x20	; 32
    4994:	51 e4       	ldi	r21, 0x41	; 65
    4996:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    499a:	dc 01       	movw	r26, r24
    499c:	cb 01       	movw	r24, r22
    499e:	8e 01       	movw	r16, r28
    49a0:	05 5b       	subi	r16, 0xB5	; 181
    49a2:	1f 4f       	sbci	r17, 0xFF	; 255
    49a4:	bc 01       	movw	r22, r24
    49a6:	cd 01       	movw	r24, r26
    49a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    49ac:	dc 01       	movw	r26, r24
    49ae:	cb 01       	movw	r24, r22
    49b0:	f8 01       	movw	r30, r16
    49b2:	91 83       	std	Z+1, r25	; 0x01
    49b4:	80 83       	st	Z, r24
    49b6:	1f c0       	rjmp	.+62     	; 0x49f6 <LCD_voidInit+0x122>
    49b8:	fe 01       	movw	r30, r28
    49ba:	e7 5b       	subi	r30, 0xB7	; 183
    49bc:	ff 4f       	sbci	r31, 0xFF	; 255
    49be:	88 ec       	ldi	r24, 0xC8	; 200
    49c0:	90 e0       	ldi	r25, 0x00	; 0
    49c2:	91 83       	std	Z+1, r25	; 0x01
    49c4:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    49c6:	fe 01       	movw	r30, r28
    49c8:	e7 5b       	subi	r30, 0xB7	; 183
    49ca:	ff 4f       	sbci	r31, 0xFF	; 255
    49cc:	80 81       	ld	r24, Z
    49ce:	91 81       	ldd	r25, Z+1	; 0x01
    49d0:	01 97       	sbiw	r24, 0x01	; 1
    49d2:	f1 f7       	brne	.-4      	; 0x49d0 <LCD_voidInit+0xfc>
    49d4:	fe 01       	movw	r30, r28
    49d6:	e7 5b       	subi	r30, 0xB7	; 183
    49d8:	ff 4f       	sbci	r31, 0xFF	; 255
    49da:	91 83       	std	Z+1, r25	; 0x01
    49dc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    49de:	de 01       	movw	r26, r28
    49e0:	a5 5b       	subi	r26, 0xB5	; 181
    49e2:	bf 4f       	sbci	r27, 0xFF	; 255
    49e4:	fe 01       	movw	r30, r28
    49e6:	e5 5b       	subi	r30, 0xB5	; 181
    49e8:	ff 4f       	sbci	r31, 0xFF	; 255
    49ea:	80 81       	ld	r24, Z
    49ec:	91 81       	ldd	r25, Z+1	; 0x01
    49ee:	01 97       	sbiw	r24, 0x01	; 1
    49f0:	11 96       	adiw	r26, 0x01	; 1
    49f2:	9c 93       	st	X, r25
    49f4:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    49f6:	fe 01       	movw	r30, r28
    49f8:	e5 5b       	subi	r30, 0xB5	; 181
    49fa:	ff 4f       	sbci	r31, 0xFF	; 255
    49fc:	80 81       	ld	r24, Z
    49fe:	91 81       	ldd	r25, Z+1	; 0x01
    4a00:	00 97       	sbiw	r24, 0x00	; 0
    4a02:	d1 f6       	brne	.-76     	; 0x49b8 <LCD_voidInit+0xe4>
    4a04:	27 c0       	rjmp	.+78     	; 0x4a54 <LCD_voidInit+0x180>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a06:	8e 01       	movw	r16, r28
    4a08:	05 5b       	subi	r16, 0xB5	; 181
    4a0a:	1f 4f       	sbci	r17, 0xFF	; 255
    4a0c:	fe 01       	movw	r30, r28
    4a0e:	e3 5b       	subi	r30, 0xB3	; 179
    4a10:	ff 4f       	sbci	r31, 0xFF	; 255
    4a12:	60 81       	ld	r22, Z
    4a14:	71 81       	ldd	r23, Z+1	; 0x01
    4a16:	82 81       	ldd	r24, Z+2	; 0x02
    4a18:	93 81       	ldd	r25, Z+3	; 0x03
    4a1a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a1e:	dc 01       	movw	r26, r24
    4a20:	cb 01       	movw	r24, r22
    4a22:	f8 01       	movw	r30, r16
    4a24:	91 83       	std	Z+1, r25	; 0x01
    4a26:	80 83       	st	Z, r24
    4a28:	de 01       	movw	r26, r28
    4a2a:	a9 5b       	subi	r26, 0xB9	; 185
    4a2c:	bf 4f       	sbci	r27, 0xFF	; 255
    4a2e:	fe 01       	movw	r30, r28
    4a30:	e5 5b       	subi	r30, 0xB5	; 181
    4a32:	ff 4f       	sbci	r31, 0xFF	; 255
    4a34:	80 81       	ld	r24, Z
    4a36:	91 81       	ldd	r25, Z+1	; 0x01
    4a38:	8d 93       	st	X+, r24
    4a3a:	9c 93       	st	X, r25
    4a3c:	fe 01       	movw	r30, r28
    4a3e:	e9 5b       	subi	r30, 0xB9	; 185
    4a40:	ff 4f       	sbci	r31, 0xFF	; 255
    4a42:	80 81       	ld	r24, Z
    4a44:	91 81       	ldd	r25, Z+1	; 0x01
    4a46:	01 97       	sbiw	r24, 0x01	; 1
    4a48:	f1 f7       	brne	.-4      	; 0x4a46 <LCD_voidInit+0x172>
    4a4a:	fe 01       	movw	r30, r28
    4a4c:	e9 5b       	subi	r30, 0xB9	; 185
    4a4e:	ff 4f       	sbci	r31, 0xFF	; 255
    4a50:	91 83       	std	Z+1, r25	; 0x01
    4a52:	80 83       	st	Z, r24
	_delay_ms(30);

	/* Send command function set */
	LCD_voidSendCommand(lcd_FunctionSet8bit);
    4a54:	88 e3       	ldi	r24, 0x38	; 56
    4a56:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
    4a5a:	fe 01       	movw	r30, r28
    4a5c:	ed 5b       	subi	r30, 0xBD	; 189
    4a5e:	ff 4f       	sbci	r31, 0xFF	; 255
    4a60:	80 e0       	ldi	r24, 0x00	; 0
    4a62:	90 e0       	ldi	r25, 0x00	; 0
    4a64:	a0 e2       	ldi	r26, 0x20	; 32
    4a66:	b1 e4       	ldi	r27, 0x41	; 65
    4a68:	80 83       	st	Z, r24
    4a6a:	91 83       	std	Z+1, r25	; 0x01
    4a6c:	a2 83       	std	Z+2, r26	; 0x02
    4a6e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4a70:	8e 01       	movw	r16, r28
    4a72:	01 5c       	subi	r16, 0xC1	; 193
    4a74:	1f 4f       	sbci	r17, 0xFF	; 255
    4a76:	fe 01       	movw	r30, r28
    4a78:	ed 5b       	subi	r30, 0xBD	; 189
    4a7a:	ff 4f       	sbci	r31, 0xFF	; 255
    4a7c:	60 81       	ld	r22, Z
    4a7e:	71 81       	ldd	r23, Z+1	; 0x01
    4a80:	82 81       	ldd	r24, Z+2	; 0x02
    4a82:	93 81       	ldd	r25, Z+3	; 0x03
    4a84:	20 e0       	ldi	r18, 0x00	; 0
    4a86:	30 e0       	ldi	r19, 0x00	; 0
    4a88:	4a ef       	ldi	r20, 0xFA	; 250
    4a8a:	54 e4       	ldi	r21, 0x44	; 68
    4a8c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4a90:	dc 01       	movw	r26, r24
    4a92:	cb 01       	movw	r24, r22
    4a94:	f8 01       	movw	r30, r16
    4a96:	80 83       	st	Z, r24
    4a98:	91 83       	std	Z+1, r25	; 0x01
    4a9a:	a2 83       	std	Z+2, r26	; 0x02
    4a9c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    4a9e:	fe 01       	movw	r30, r28
    4aa0:	ff 96       	adiw	r30, 0x3f	; 63
    4aa2:	60 81       	ld	r22, Z
    4aa4:	71 81       	ldd	r23, Z+1	; 0x01
    4aa6:	82 81       	ldd	r24, Z+2	; 0x02
    4aa8:	93 81       	ldd	r25, Z+3	; 0x03
    4aaa:	20 e0       	ldi	r18, 0x00	; 0
    4aac:	30 e0       	ldi	r19, 0x00	; 0
    4aae:	40 e8       	ldi	r20, 0x80	; 128
    4ab0:	5f e3       	ldi	r21, 0x3F	; 63
    4ab2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4ab6:	88 23       	and	r24, r24
    4ab8:	2c f4       	brge	.+10     	; 0x4ac4 <LCD_voidInit+0x1f0>
		__ticks = 1;
    4aba:	81 e0       	ldi	r24, 0x01	; 1
    4abc:	90 e0       	ldi	r25, 0x00	; 0
    4abe:	9e af       	std	Y+62, r25	; 0x3e
    4ac0:	8d af       	std	Y+61, r24	; 0x3d
    4ac2:	46 c0       	rjmp	.+140    	; 0x4b50 <LCD_voidInit+0x27c>
	else if (__tmp > 65535)
    4ac4:	fe 01       	movw	r30, r28
    4ac6:	ff 96       	adiw	r30, 0x3f	; 63
    4ac8:	60 81       	ld	r22, Z
    4aca:	71 81       	ldd	r23, Z+1	; 0x01
    4acc:	82 81       	ldd	r24, Z+2	; 0x02
    4ace:	93 81       	ldd	r25, Z+3	; 0x03
    4ad0:	20 e0       	ldi	r18, 0x00	; 0
    4ad2:	3f ef       	ldi	r19, 0xFF	; 255
    4ad4:	4f e7       	ldi	r20, 0x7F	; 127
    4ad6:	57 e4       	ldi	r21, 0x47	; 71
    4ad8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4adc:	18 16       	cp	r1, r24
    4ade:	64 f5       	brge	.+88     	; 0x4b38 <LCD_voidInit+0x264>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4ae0:	fe 01       	movw	r30, r28
    4ae2:	ed 5b       	subi	r30, 0xBD	; 189
    4ae4:	ff 4f       	sbci	r31, 0xFF	; 255
    4ae6:	60 81       	ld	r22, Z
    4ae8:	71 81       	ldd	r23, Z+1	; 0x01
    4aea:	82 81       	ldd	r24, Z+2	; 0x02
    4aec:	93 81       	ldd	r25, Z+3	; 0x03
    4aee:	20 e0       	ldi	r18, 0x00	; 0
    4af0:	30 e0       	ldi	r19, 0x00	; 0
    4af2:	40 e2       	ldi	r20, 0x20	; 32
    4af4:	51 e4       	ldi	r21, 0x41	; 65
    4af6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4afa:	dc 01       	movw	r26, r24
    4afc:	cb 01       	movw	r24, r22
    4afe:	bc 01       	movw	r22, r24
    4b00:	cd 01       	movw	r24, r26
    4b02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b06:	dc 01       	movw	r26, r24
    4b08:	cb 01       	movw	r24, r22
    4b0a:	9e af       	std	Y+62, r25	; 0x3e
    4b0c:	8d af       	std	Y+61, r24	; 0x3d
    4b0e:	0f c0       	rjmp	.+30     	; 0x4b2e <LCD_voidInit+0x25a>
    4b10:	88 ec       	ldi	r24, 0xC8	; 200
    4b12:	90 e0       	ldi	r25, 0x00	; 0
    4b14:	9c af       	std	Y+60, r25	; 0x3c
    4b16:	8b af       	std	Y+59, r24	; 0x3b
    4b18:	8b ad       	ldd	r24, Y+59	; 0x3b
    4b1a:	9c ad       	ldd	r25, Y+60	; 0x3c
    4b1c:	01 97       	sbiw	r24, 0x01	; 1
    4b1e:	f1 f7       	brne	.-4      	; 0x4b1c <LCD_voidInit+0x248>
    4b20:	9c af       	std	Y+60, r25	; 0x3c
    4b22:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b24:	8d ad       	ldd	r24, Y+61	; 0x3d
    4b26:	9e ad       	ldd	r25, Y+62	; 0x3e
    4b28:	01 97       	sbiw	r24, 0x01	; 1
    4b2a:	9e af       	std	Y+62, r25	; 0x3e
    4b2c:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b2e:	8d ad       	ldd	r24, Y+61	; 0x3d
    4b30:	9e ad       	ldd	r25, Y+62	; 0x3e
    4b32:	00 97       	sbiw	r24, 0x00	; 0
    4b34:	69 f7       	brne	.-38     	; 0x4b10 <LCD_voidInit+0x23c>
    4b36:	16 c0       	rjmp	.+44     	; 0x4b64 <LCD_voidInit+0x290>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b38:	fe 01       	movw	r30, r28
    4b3a:	ff 96       	adiw	r30, 0x3f	; 63
    4b3c:	60 81       	ld	r22, Z
    4b3e:	71 81       	ldd	r23, Z+1	; 0x01
    4b40:	82 81       	ldd	r24, Z+2	; 0x02
    4b42:	93 81       	ldd	r25, Z+3	; 0x03
    4b44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b48:	dc 01       	movw	r26, r24
    4b4a:	cb 01       	movw	r24, r22
    4b4c:	9e af       	std	Y+62, r25	; 0x3e
    4b4e:	8d af       	std	Y+61, r24	; 0x3d
    4b50:	8d ad       	ldd	r24, Y+61	; 0x3d
    4b52:	9e ad       	ldd	r25, Y+62	; 0x3e
    4b54:	9a af       	std	Y+58, r25	; 0x3a
    4b56:	89 af       	std	Y+57, r24	; 0x39
    4b58:	89 ad       	ldd	r24, Y+57	; 0x39
    4b5a:	9a ad       	ldd	r25, Y+58	; 0x3a
    4b5c:	01 97       	sbiw	r24, 0x01	; 1
    4b5e:	f1 f7       	brne	.-4      	; 0x4b5c <LCD_voidInit+0x288>
    4b60:	9a af       	std	Y+58, r25	; 0x3a
    4b62:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(10);

	/* Send command dispaly on */
	LCD_voidSendCommand(lcd_DisplayOn);
    4b64:	8c e0       	ldi	r24, 0x0C	; 12
    4b66:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
    4b6a:	80 e0       	ldi	r24, 0x00	; 0
    4b6c:	90 e0       	ldi	r25, 0x00	; 0
    4b6e:	a0 e2       	ldi	r26, 0x20	; 32
    4b70:	b1 e4       	ldi	r27, 0x41	; 65
    4b72:	8d ab       	std	Y+53, r24	; 0x35
    4b74:	9e ab       	std	Y+54, r25	; 0x36
    4b76:	af ab       	std	Y+55, r26	; 0x37
    4b78:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4b7a:	6d a9       	ldd	r22, Y+53	; 0x35
    4b7c:	7e a9       	ldd	r23, Y+54	; 0x36
    4b7e:	8f a9       	ldd	r24, Y+55	; 0x37
    4b80:	98 ad       	ldd	r25, Y+56	; 0x38
    4b82:	20 e0       	ldi	r18, 0x00	; 0
    4b84:	30 e0       	ldi	r19, 0x00	; 0
    4b86:	4a ef       	ldi	r20, 0xFA	; 250
    4b88:	54 e4       	ldi	r21, 0x44	; 68
    4b8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b8e:	dc 01       	movw	r26, r24
    4b90:	cb 01       	movw	r24, r22
    4b92:	89 ab       	std	Y+49, r24	; 0x31
    4b94:	9a ab       	std	Y+50, r25	; 0x32
    4b96:	ab ab       	std	Y+51, r26	; 0x33
    4b98:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    4b9a:	69 a9       	ldd	r22, Y+49	; 0x31
    4b9c:	7a a9       	ldd	r23, Y+50	; 0x32
    4b9e:	8b a9       	ldd	r24, Y+51	; 0x33
    4ba0:	9c a9       	ldd	r25, Y+52	; 0x34
    4ba2:	20 e0       	ldi	r18, 0x00	; 0
    4ba4:	30 e0       	ldi	r19, 0x00	; 0
    4ba6:	40 e8       	ldi	r20, 0x80	; 128
    4ba8:	5f e3       	ldi	r21, 0x3F	; 63
    4baa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4bae:	88 23       	and	r24, r24
    4bb0:	2c f4       	brge	.+10     	; 0x4bbc <LCD_voidInit+0x2e8>
		__ticks = 1;
    4bb2:	81 e0       	ldi	r24, 0x01	; 1
    4bb4:	90 e0       	ldi	r25, 0x00	; 0
    4bb6:	98 ab       	std	Y+48, r25	; 0x30
    4bb8:	8f a7       	std	Y+47, r24	; 0x2f
    4bba:	3f c0       	rjmp	.+126    	; 0x4c3a <LCD_voidInit+0x366>
	else if (__tmp > 65535)
    4bbc:	69 a9       	ldd	r22, Y+49	; 0x31
    4bbe:	7a a9       	ldd	r23, Y+50	; 0x32
    4bc0:	8b a9       	ldd	r24, Y+51	; 0x33
    4bc2:	9c a9       	ldd	r25, Y+52	; 0x34
    4bc4:	20 e0       	ldi	r18, 0x00	; 0
    4bc6:	3f ef       	ldi	r19, 0xFF	; 255
    4bc8:	4f e7       	ldi	r20, 0x7F	; 127
    4bca:	57 e4       	ldi	r21, 0x47	; 71
    4bcc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4bd0:	18 16       	cp	r1, r24
    4bd2:	4c f5       	brge	.+82     	; 0x4c26 <LCD_voidInit+0x352>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4bd4:	6d a9       	ldd	r22, Y+53	; 0x35
    4bd6:	7e a9       	ldd	r23, Y+54	; 0x36
    4bd8:	8f a9       	ldd	r24, Y+55	; 0x37
    4bda:	98 ad       	ldd	r25, Y+56	; 0x38
    4bdc:	20 e0       	ldi	r18, 0x00	; 0
    4bde:	30 e0       	ldi	r19, 0x00	; 0
    4be0:	40 e2       	ldi	r20, 0x20	; 32
    4be2:	51 e4       	ldi	r21, 0x41	; 65
    4be4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4be8:	dc 01       	movw	r26, r24
    4bea:	cb 01       	movw	r24, r22
    4bec:	bc 01       	movw	r22, r24
    4bee:	cd 01       	movw	r24, r26
    4bf0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4bf4:	dc 01       	movw	r26, r24
    4bf6:	cb 01       	movw	r24, r22
    4bf8:	98 ab       	std	Y+48, r25	; 0x30
    4bfa:	8f a7       	std	Y+47, r24	; 0x2f
    4bfc:	0f c0       	rjmp	.+30     	; 0x4c1c <LCD_voidInit+0x348>
    4bfe:	88 ec       	ldi	r24, 0xC8	; 200
    4c00:	90 e0       	ldi	r25, 0x00	; 0
    4c02:	9e a7       	std	Y+46, r25	; 0x2e
    4c04:	8d a7       	std	Y+45, r24	; 0x2d
    4c06:	8d a5       	ldd	r24, Y+45	; 0x2d
    4c08:	9e a5       	ldd	r25, Y+46	; 0x2e
    4c0a:	01 97       	sbiw	r24, 0x01	; 1
    4c0c:	f1 f7       	brne	.-4      	; 0x4c0a <LCD_voidInit+0x336>
    4c0e:	9e a7       	std	Y+46, r25	; 0x2e
    4c10:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c12:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c14:	98 a9       	ldd	r25, Y+48	; 0x30
    4c16:	01 97       	sbiw	r24, 0x01	; 1
    4c18:	98 ab       	std	Y+48, r25	; 0x30
    4c1a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c1c:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c1e:	98 a9       	ldd	r25, Y+48	; 0x30
    4c20:	00 97       	sbiw	r24, 0x00	; 0
    4c22:	69 f7       	brne	.-38     	; 0x4bfe <LCD_voidInit+0x32a>
    4c24:	14 c0       	rjmp	.+40     	; 0x4c4e <LCD_voidInit+0x37a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4c26:	69 a9       	ldd	r22, Y+49	; 0x31
    4c28:	7a a9       	ldd	r23, Y+50	; 0x32
    4c2a:	8b a9       	ldd	r24, Y+51	; 0x33
    4c2c:	9c a9       	ldd	r25, Y+52	; 0x34
    4c2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c32:	dc 01       	movw	r26, r24
    4c34:	cb 01       	movw	r24, r22
    4c36:	98 ab       	std	Y+48, r25	; 0x30
    4c38:	8f a7       	std	Y+47, r24	; 0x2f
    4c3a:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c3c:	98 a9       	ldd	r25, Y+48	; 0x30
    4c3e:	9c a7       	std	Y+44, r25	; 0x2c
    4c40:	8b a7       	std	Y+43, r24	; 0x2b
    4c42:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c44:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c46:	01 97       	sbiw	r24, 0x01	; 1
    4c48:	f1 f7       	brne	.-4      	; 0x4c46 <LCD_voidInit+0x372>
    4c4a:	9c a7       	std	Y+44, r25	; 0x2c
    4c4c:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(10);

	/* Clear the display  */
	LCD_voidSendCommand(lcd_Clear);
    4c4e:	81 e0       	ldi	r24, 0x01	; 1
    4c50:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
    4c54:	80 e0       	ldi	r24, 0x00	; 0
    4c56:	90 e0       	ldi	r25, 0x00	; 0
    4c58:	a0 e2       	ldi	r26, 0x20	; 32
    4c5a:	b1 e4       	ldi	r27, 0x41	; 65
    4c5c:	8f a3       	std	Y+39, r24	; 0x27
    4c5e:	98 a7       	std	Y+40, r25	; 0x28
    4c60:	a9 a7       	std	Y+41, r26	; 0x29
    4c62:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4c64:	6f a1       	ldd	r22, Y+39	; 0x27
    4c66:	78 a5       	ldd	r23, Y+40	; 0x28
    4c68:	89 a5       	ldd	r24, Y+41	; 0x29
    4c6a:	9a a5       	ldd	r25, Y+42	; 0x2a
    4c6c:	20 e0       	ldi	r18, 0x00	; 0
    4c6e:	30 e0       	ldi	r19, 0x00	; 0
    4c70:	4a ef       	ldi	r20, 0xFA	; 250
    4c72:	54 e4       	ldi	r21, 0x44	; 68
    4c74:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c78:	dc 01       	movw	r26, r24
    4c7a:	cb 01       	movw	r24, r22
    4c7c:	8b a3       	std	Y+35, r24	; 0x23
    4c7e:	9c a3       	std	Y+36, r25	; 0x24
    4c80:	ad a3       	std	Y+37, r26	; 0x25
    4c82:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4c84:	6b a1       	ldd	r22, Y+35	; 0x23
    4c86:	7c a1       	ldd	r23, Y+36	; 0x24
    4c88:	8d a1       	ldd	r24, Y+37	; 0x25
    4c8a:	9e a1       	ldd	r25, Y+38	; 0x26
    4c8c:	20 e0       	ldi	r18, 0x00	; 0
    4c8e:	30 e0       	ldi	r19, 0x00	; 0
    4c90:	40 e8       	ldi	r20, 0x80	; 128
    4c92:	5f e3       	ldi	r21, 0x3F	; 63
    4c94:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4c98:	88 23       	and	r24, r24
    4c9a:	2c f4       	brge	.+10     	; 0x4ca6 <LCD_voidInit+0x3d2>
		__ticks = 1;
    4c9c:	81 e0       	ldi	r24, 0x01	; 1
    4c9e:	90 e0       	ldi	r25, 0x00	; 0
    4ca0:	9a a3       	std	Y+34, r25	; 0x22
    4ca2:	89 a3       	std	Y+33, r24	; 0x21
    4ca4:	3f c0       	rjmp	.+126    	; 0x4d24 <LCD_voidInit+0x450>
	else if (__tmp > 65535)
    4ca6:	6b a1       	ldd	r22, Y+35	; 0x23
    4ca8:	7c a1       	ldd	r23, Y+36	; 0x24
    4caa:	8d a1       	ldd	r24, Y+37	; 0x25
    4cac:	9e a1       	ldd	r25, Y+38	; 0x26
    4cae:	20 e0       	ldi	r18, 0x00	; 0
    4cb0:	3f ef       	ldi	r19, 0xFF	; 255
    4cb2:	4f e7       	ldi	r20, 0x7F	; 127
    4cb4:	57 e4       	ldi	r21, 0x47	; 71
    4cb6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4cba:	18 16       	cp	r1, r24
    4cbc:	4c f5       	brge	.+82     	; 0x4d10 <LCD_voidInit+0x43c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4cbe:	6f a1       	ldd	r22, Y+39	; 0x27
    4cc0:	78 a5       	ldd	r23, Y+40	; 0x28
    4cc2:	89 a5       	ldd	r24, Y+41	; 0x29
    4cc4:	9a a5       	ldd	r25, Y+42	; 0x2a
    4cc6:	20 e0       	ldi	r18, 0x00	; 0
    4cc8:	30 e0       	ldi	r19, 0x00	; 0
    4cca:	40 e2       	ldi	r20, 0x20	; 32
    4ccc:	51 e4       	ldi	r21, 0x41	; 65
    4cce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4cd2:	dc 01       	movw	r26, r24
    4cd4:	cb 01       	movw	r24, r22
    4cd6:	bc 01       	movw	r22, r24
    4cd8:	cd 01       	movw	r24, r26
    4cda:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4cde:	dc 01       	movw	r26, r24
    4ce0:	cb 01       	movw	r24, r22
    4ce2:	9a a3       	std	Y+34, r25	; 0x22
    4ce4:	89 a3       	std	Y+33, r24	; 0x21
    4ce6:	0f c0       	rjmp	.+30     	; 0x4d06 <LCD_voidInit+0x432>
    4ce8:	88 ec       	ldi	r24, 0xC8	; 200
    4cea:	90 e0       	ldi	r25, 0x00	; 0
    4cec:	98 a3       	std	Y+32, r25	; 0x20
    4cee:	8f 8f       	std	Y+31, r24	; 0x1f
    4cf0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4cf2:	98 a1       	ldd	r25, Y+32	; 0x20
    4cf4:	01 97       	sbiw	r24, 0x01	; 1
    4cf6:	f1 f7       	brne	.-4      	; 0x4cf4 <LCD_voidInit+0x420>
    4cf8:	98 a3       	std	Y+32, r25	; 0x20
    4cfa:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4cfc:	89 a1       	ldd	r24, Y+33	; 0x21
    4cfe:	9a a1       	ldd	r25, Y+34	; 0x22
    4d00:	01 97       	sbiw	r24, 0x01	; 1
    4d02:	9a a3       	std	Y+34, r25	; 0x22
    4d04:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d06:	89 a1       	ldd	r24, Y+33	; 0x21
    4d08:	9a a1       	ldd	r25, Y+34	; 0x22
    4d0a:	00 97       	sbiw	r24, 0x00	; 0
    4d0c:	69 f7       	brne	.-38     	; 0x4ce8 <LCD_voidInit+0x414>
    4d0e:	14 c0       	rjmp	.+40     	; 0x4d38 <LCD_voidInit+0x464>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4d10:	6b a1       	ldd	r22, Y+35	; 0x23
    4d12:	7c a1       	ldd	r23, Y+36	; 0x24
    4d14:	8d a1       	ldd	r24, Y+37	; 0x25
    4d16:	9e a1       	ldd	r25, Y+38	; 0x26
    4d18:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d1c:	dc 01       	movw	r26, r24
    4d1e:	cb 01       	movw	r24, r22
    4d20:	9a a3       	std	Y+34, r25	; 0x22
    4d22:	89 a3       	std	Y+33, r24	; 0x21
    4d24:	89 a1       	ldd	r24, Y+33	; 0x21
    4d26:	9a a1       	ldd	r25, Y+34	; 0x22
    4d28:	9e 8f       	std	Y+30, r25	; 0x1e
    4d2a:	8d 8f       	std	Y+29, r24	; 0x1d
    4d2c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d2e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d30:	01 97       	sbiw	r24, 0x01	; 1
    4d32:	f1 f7       	brne	.-4      	; 0x4d30 <LCD_voidInit+0x45c>
    4d34:	9e 8f       	std	Y+30, r25	; 0x1e
    4d36:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(10);

	/* Entry mode set  */
	LCD_voidSendCommand(lcd_EntryMode);
    4d38:	86 e0       	ldi	r24, 0x06	; 6
    4d3a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
    4d3e:	80 e0       	ldi	r24, 0x00	; 0
    4d40:	90 e0       	ldi	r25, 0x00	; 0
    4d42:	a0 e2       	ldi	r26, 0x20	; 32
    4d44:	b1 e4       	ldi	r27, 0x41	; 65
    4d46:	89 8f       	std	Y+25, r24	; 0x19
    4d48:	9a 8f       	std	Y+26, r25	; 0x1a
    4d4a:	ab 8f       	std	Y+27, r26	; 0x1b
    4d4c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4d4e:	69 8d       	ldd	r22, Y+25	; 0x19
    4d50:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4d52:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4d54:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4d56:	20 e0       	ldi	r18, 0x00	; 0
    4d58:	30 e0       	ldi	r19, 0x00	; 0
    4d5a:	4a ef       	ldi	r20, 0xFA	; 250
    4d5c:	54 e4       	ldi	r21, 0x44	; 68
    4d5e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d62:	dc 01       	movw	r26, r24
    4d64:	cb 01       	movw	r24, r22
    4d66:	8d 8b       	std	Y+21, r24	; 0x15
    4d68:	9e 8b       	std	Y+22, r25	; 0x16
    4d6a:	af 8b       	std	Y+23, r26	; 0x17
    4d6c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4d6e:	6d 89       	ldd	r22, Y+21	; 0x15
    4d70:	7e 89       	ldd	r23, Y+22	; 0x16
    4d72:	8f 89       	ldd	r24, Y+23	; 0x17
    4d74:	98 8d       	ldd	r25, Y+24	; 0x18
    4d76:	20 e0       	ldi	r18, 0x00	; 0
    4d78:	30 e0       	ldi	r19, 0x00	; 0
    4d7a:	40 e8       	ldi	r20, 0x80	; 128
    4d7c:	5f e3       	ldi	r21, 0x3F	; 63
    4d7e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4d82:	88 23       	and	r24, r24
    4d84:	2c f4       	brge	.+10     	; 0x4d90 <LCD_voidInit+0x4bc>
		__ticks = 1;
    4d86:	81 e0       	ldi	r24, 0x01	; 1
    4d88:	90 e0       	ldi	r25, 0x00	; 0
    4d8a:	9c 8b       	std	Y+20, r25	; 0x14
    4d8c:	8b 8b       	std	Y+19, r24	; 0x13
    4d8e:	3f c0       	rjmp	.+126    	; 0x4e0e <LCD_voidInit+0x53a>
	else if (__tmp > 65535)
    4d90:	6d 89       	ldd	r22, Y+21	; 0x15
    4d92:	7e 89       	ldd	r23, Y+22	; 0x16
    4d94:	8f 89       	ldd	r24, Y+23	; 0x17
    4d96:	98 8d       	ldd	r25, Y+24	; 0x18
    4d98:	20 e0       	ldi	r18, 0x00	; 0
    4d9a:	3f ef       	ldi	r19, 0xFF	; 255
    4d9c:	4f e7       	ldi	r20, 0x7F	; 127
    4d9e:	57 e4       	ldi	r21, 0x47	; 71
    4da0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4da4:	18 16       	cp	r1, r24
    4da6:	4c f5       	brge	.+82     	; 0x4dfa <LCD_voidInit+0x526>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4da8:	69 8d       	ldd	r22, Y+25	; 0x19
    4daa:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4dac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4dae:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4db0:	20 e0       	ldi	r18, 0x00	; 0
    4db2:	30 e0       	ldi	r19, 0x00	; 0
    4db4:	40 e2       	ldi	r20, 0x20	; 32
    4db6:	51 e4       	ldi	r21, 0x41	; 65
    4db8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4dbc:	dc 01       	movw	r26, r24
    4dbe:	cb 01       	movw	r24, r22
    4dc0:	bc 01       	movw	r22, r24
    4dc2:	cd 01       	movw	r24, r26
    4dc4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4dc8:	dc 01       	movw	r26, r24
    4dca:	cb 01       	movw	r24, r22
    4dcc:	9c 8b       	std	Y+20, r25	; 0x14
    4dce:	8b 8b       	std	Y+19, r24	; 0x13
    4dd0:	0f c0       	rjmp	.+30     	; 0x4df0 <LCD_voidInit+0x51c>
    4dd2:	88 ec       	ldi	r24, 0xC8	; 200
    4dd4:	90 e0       	ldi	r25, 0x00	; 0
    4dd6:	9a 8b       	std	Y+18, r25	; 0x12
    4dd8:	89 8b       	std	Y+17, r24	; 0x11
    4dda:	89 89       	ldd	r24, Y+17	; 0x11
    4ddc:	9a 89       	ldd	r25, Y+18	; 0x12
    4dde:	01 97       	sbiw	r24, 0x01	; 1
    4de0:	f1 f7       	brne	.-4      	; 0x4dde <LCD_voidInit+0x50a>
    4de2:	9a 8b       	std	Y+18, r25	; 0x12
    4de4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4de6:	8b 89       	ldd	r24, Y+19	; 0x13
    4de8:	9c 89       	ldd	r25, Y+20	; 0x14
    4dea:	01 97       	sbiw	r24, 0x01	; 1
    4dec:	9c 8b       	std	Y+20, r25	; 0x14
    4dee:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4df0:	8b 89       	ldd	r24, Y+19	; 0x13
    4df2:	9c 89       	ldd	r25, Y+20	; 0x14
    4df4:	00 97       	sbiw	r24, 0x00	; 0
    4df6:	69 f7       	brne	.-38     	; 0x4dd2 <LCD_voidInit+0x4fe>
    4df8:	14 c0       	rjmp	.+40     	; 0x4e22 <LCD_voidInit+0x54e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4dfa:	6d 89       	ldd	r22, Y+21	; 0x15
    4dfc:	7e 89       	ldd	r23, Y+22	; 0x16
    4dfe:	8f 89       	ldd	r24, Y+23	; 0x17
    4e00:	98 8d       	ldd	r25, Y+24	; 0x18
    4e02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4e06:	dc 01       	movw	r26, r24
    4e08:	cb 01       	movw	r24, r22
    4e0a:	9c 8b       	std	Y+20, r25	; 0x14
    4e0c:	8b 8b       	std	Y+19, r24	; 0x13
    4e0e:	8b 89       	ldd	r24, Y+19	; 0x13
    4e10:	9c 89       	ldd	r25, Y+20	; 0x14
    4e12:	98 8b       	std	Y+16, r25	; 0x10
    4e14:	8f 87       	std	Y+15, r24	; 0x0f
    4e16:	8f 85       	ldd	r24, Y+15	; 0x0f
    4e18:	98 89       	ldd	r25, Y+16	; 0x10
    4e1a:	01 97       	sbiw	r24, 0x01	; 1
    4e1c:	f1 f7       	brne	.-4      	; 0x4e1a <LCD_voidInit+0x546>
    4e1e:	98 8b       	std	Y+16, r25	; 0x10
    4e20:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(10);

	/* Set cursor home */
	LCD_voidSendCommand(lcd_Home);
    4e22:	82 e0       	ldi	r24, 0x02	; 2
    4e24:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
    4e28:	80 e0       	ldi	r24, 0x00	; 0
    4e2a:	90 e0       	ldi	r25, 0x00	; 0
    4e2c:	a0 e2       	ldi	r26, 0x20	; 32
    4e2e:	b1 e4       	ldi	r27, 0x41	; 65
    4e30:	8b 87       	std	Y+11, r24	; 0x0b
    4e32:	9c 87       	std	Y+12, r25	; 0x0c
    4e34:	ad 87       	std	Y+13, r26	; 0x0d
    4e36:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e38:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e3a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e40:	20 e0       	ldi	r18, 0x00	; 0
    4e42:	30 e0       	ldi	r19, 0x00	; 0
    4e44:	4a ef       	ldi	r20, 0xFA	; 250
    4e46:	54 e4       	ldi	r21, 0x44	; 68
    4e48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e4c:	dc 01       	movw	r26, r24
    4e4e:	cb 01       	movw	r24, r22
    4e50:	8f 83       	std	Y+7, r24	; 0x07
    4e52:	98 87       	std	Y+8, r25	; 0x08
    4e54:	a9 87       	std	Y+9, r26	; 0x09
    4e56:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4e58:	6f 81       	ldd	r22, Y+7	; 0x07
    4e5a:	78 85       	ldd	r23, Y+8	; 0x08
    4e5c:	89 85       	ldd	r24, Y+9	; 0x09
    4e5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4e60:	20 e0       	ldi	r18, 0x00	; 0
    4e62:	30 e0       	ldi	r19, 0x00	; 0
    4e64:	40 e8       	ldi	r20, 0x80	; 128
    4e66:	5f e3       	ldi	r21, 0x3F	; 63
    4e68:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4e6c:	88 23       	and	r24, r24
    4e6e:	2c f4       	brge	.+10     	; 0x4e7a <LCD_voidInit+0x5a6>
		__ticks = 1;
    4e70:	81 e0       	ldi	r24, 0x01	; 1
    4e72:	90 e0       	ldi	r25, 0x00	; 0
    4e74:	9e 83       	std	Y+6, r25	; 0x06
    4e76:	8d 83       	std	Y+5, r24	; 0x05
    4e78:	3f c0       	rjmp	.+126    	; 0x4ef8 <LCD_voidInit+0x624>
	else if (__tmp > 65535)
    4e7a:	6f 81       	ldd	r22, Y+7	; 0x07
    4e7c:	78 85       	ldd	r23, Y+8	; 0x08
    4e7e:	89 85       	ldd	r24, Y+9	; 0x09
    4e80:	9a 85       	ldd	r25, Y+10	; 0x0a
    4e82:	20 e0       	ldi	r18, 0x00	; 0
    4e84:	3f ef       	ldi	r19, 0xFF	; 255
    4e86:	4f e7       	ldi	r20, 0x7F	; 127
    4e88:	57 e4       	ldi	r21, 0x47	; 71
    4e8a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4e8e:	18 16       	cp	r1, r24
    4e90:	4c f5       	brge	.+82     	; 0x4ee4 <LCD_voidInit+0x610>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e92:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e94:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e96:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e98:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e9a:	20 e0       	ldi	r18, 0x00	; 0
    4e9c:	30 e0       	ldi	r19, 0x00	; 0
    4e9e:	40 e2       	ldi	r20, 0x20	; 32
    4ea0:	51 e4       	ldi	r21, 0x41	; 65
    4ea2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ea6:	dc 01       	movw	r26, r24
    4ea8:	cb 01       	movw	r24, r22
    4eaa:	bc 01       	movw	r22, r24
    4eac:	cd 01       	movw	r24, r26
    4eae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4eb2:	dc 01       	movw	r26, r24
    4eb4:	cb 01       	movw	r24, r22
    4eb6:	9e 83       	std	Y+6, r25	; 0x06
    4eb8:	8d 83       	std	Y+5, r24	; 0x05
    4eba:	0f c0       	rjmp	.+30     	; 0x4eda <LCD_voidInit+0x606>
    4ebc:	88 ec       	ldi	r24, 0xC8	; 200
    4ebe:	90 e0       	ldi	r25, 0x00	; 0
    4ec0:	9c 83       	std	Y+4, r25	; 0x04
    4ec2:	8b 83       	std	Y+3, r24	; 0x03
    4ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec8:	01 97       	sbiw	r24, 0x01	; 1
    4eca:	f1 f7       	brne	.-4      	; 0x4ec8 <LCD_voidInit+0x5f4>
    4ecc:	9c 83       	std	Y+4, r25	; 0x04
    4ece:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ed0:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed2:	9e 81       	ldd	r25, Y+6	; 0x06
    4ed4:	01 97       	sbiw	r24, 0x01	; 1
    4ed6:	9e 83       	std	Y+6, r25	; 0x06
    4ed8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4eda:	8d 81       	ldd	r24, Y+5	; 0x05
    4edc:	9e 81       	ldd	r25, Y+6	; 0x06
    4ede:	00 97       	sbiw	r24, 0x00	; 0
    4ee0:	69 f7       	brne	.-38     	; 0x4ebc <LCD_voidInit+0x5e8>
    4ee2:	14 c0       	rjmp	.+40     	; 0x4f0c <LCD_voidInit+0x638>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ee4:	6f 81       	ldd	r22, Y+7	; 0x07
    4ee6:	78 85       	ldd	r23, Y+8	; 0x08
    4ee8:	89 85       	ldd	r24, Y+9	; 0x09
    4eea:	9a 85       	ldd	r25, Y+10	; 0x0a
    4eec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ef0:	dc 01       	movw	r26, r24
    4ef2:	cb 01       	movw	r24, r22
    4ef4:	9e 83       	std	Y+6, r25	; 0x06
    4ef6:	8d 83       	std	Y+5, r24	; 0x05
    4ef8:	8d 81       	ldd	r24, Y+5	; 0x05
    4efa:	9e 81       	ldd	r25, Y+6	; 0x06
    4efc:	9a 83       	std	Y+2, r25	; 0x02
    4efe:	89 83       	std	Y+1, r24	; 0x01
    4f00:	89 81       	ldd	r24, Y+1	; 0x01
    4f02:	9a 81       	ldd	r25, Y+2	; 0x02
    4f04:	01 97       	sbiw	r24, 0x01	; 1
    4f06:	f1 f7       	brne	.-4      	; 0x4f04 <LCD_voidInit+0x630>
    4f08:	9a 83       	std	Y+2, r25	; 0x02
    4f0a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(10);
}
    4f0c:	cc 5a       	subi	r28, 0xAC	; 172
    4f0e:	df 4f       	sbci	r29, 0xFF	; 255
    4f10:	0f b6       	in	r0, 0x3f	; 63
    4f12:	f8 94       	cli
    4f14:	de bf       	out	0x3e, r29	; 62
    4f16:	0f be       	out	0x3f, r0	; 63
    4f18:	cd bf       	out	0x3d, r28	; 61
    4f1a:	cf 91       	pop	r28
    4f1c:	df 91       	pop	r29
    4f1e:	1f 91       	pop	r17
    4f20:	0f 91       	pop	r16
    4f22:	08 95       	ret

00004f24 <LCD_voidSendCommand>:

void LCD_voidSendCommand (u8 Cpy_command )
{
    4f24:	df 93       	push	r29
    4f26:	cf 93       	push	r28
    4f28:	cd b7       	in	r28, 0x3d	; 61
    4f2a:	de b7       	in	r29, 0x3e	; 62
    4f2c:	e1 97       	sbiw	r28, 0x31	; 49
    4f2e:	0f b6       	in	r0, 0x3f	; 63
    4f30:	f8 94       	cli
    4f32:	de bf       	out	0x3e, r29	; 62
    4f34:	0f be       	out	0x3f, r0	; 63
    4f36:	cd bf       	out	0x3d, r28	; 61
    4f38:	89 ab       	std	Y+49, r24	; 0x31
	/* Reset RS and RW */
	GPIO_voidSetPinValue(LCD_RS_PORT , LCD_RS_PIN , LOW);
    4f3a:	80 e0       	ldi	r24, 0x00	; 0
    4f3c:	60 e0       	ldi	r22, 0x00	; 0
    4f3e:	40 e0       	ldi	r20, 0x00	; 0
    4f40:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>
	GPIO_voidSetPinValue(LCD_RW_PORT , LCD_RW_PIN , LOW);
    4f44:	80 e0       	ldi	r24, 0x00	; 0
    4f46:	61 e0       	ldi	r22, 0x01	; 1
    4f48:	40 e0       	ldi	r20, 0x00	; 0
    4f4a:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>

	/* Write the command to data port */
	GPIO_voidSetPortValue(LCD_DATA_PORT , Cpy_command);
    4f4e:	83 e0       	ldi	r24, 0x03	; 3
    4f50:	69 a9       	ldd	r22, Y+49	; 0x31
    4f52:	0e 94 37 23 	call	0x466e	; 0x466e <GPIO_voidSetPortValue>

	/* Send Enable signal */
	GPIO_voidSetPinValue(LCD_E_PORT , LCD_E_PIN , HIGH);
    4f56:	80 e0       	ldi	r24, 0x00	; 0
    4f58:	62 e0       	ldi	r22, 0x02	; 2
    4f5a:	41 e0       	ldi	r20, 0x01	; 1
    4f5c:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>
    4f60:	80 e0       	ldi	r24, 0x00	; 0
    4f62:	90 e0       	ldi	r25, 0x00	; 0
    4f64:	aa ef       	ldi	r26, 0xFA	; 250
    4f66:	b3 e4       	ldi	r27, 0x43	; 67
    4f68:	8d a7       	std	Y+45, r24	; 0x2d
    4f6a:	9e a7       	std	Y+46, r25	; 0x2e
    4f6c:	af a7       	std	Y+47, r26	; 0x2f
    4f6e:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4f70:	6d a5       	ldd	r22, Y+45	; 0x2d
    4f72:	7e a5       	ldd	r23, Y+46	; 0x2e
    4f74:	8f a5       	ldd	r24, Y+47	; 0x2f
    4f76:	98 a9       	ldd	r25, Y+48	; 0x30
    4f78:	2b ea       	ldi	r18, 0xAB	; 171
    4f7a:	3a ea       	ldi	r19, 0xAA	; 170
    4f7c:	4a e2       	ldi	r20, 0x2A	; 42
    4f7e:	50 e4       	ldi	r21, 0x40	; 64
    4f80:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f84:	dc 01       	movw	r26, r24
    4f86:	cb 01       	movw	r24, r22
    4f88:	89 a7       	std	Y+41, r24	; 0x29
    4f8a:	9a a7       	std	Y+42, r25	; 0x2a
    4f8c:	ab a7       	std	Y+43, r26	; 0x2b
    4f8e:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    4f90:	69 a5       	ldd	r22, Y+41	; 0x29
    4f92:	7a a5       	ldd	r23, Y+42	; 0x2a
    4f94:	8b a5       	ldd	r24, Y+43	; 0x2b
    4f96:	9c a5       	ldd	r25, Y+44	; 0x2c
    4f98:	20 e0       	ldi	r18, 0x00	; 0
    4f9a:	30 e0       	ldi	r19, 0x00	; 0
    4f9c:	40 e8       	ldi	r20, 0x80	; 128
    4f9e:	5f e3       	ldi	r21, 0x3F	; 63
    4fa0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4fa4:	88 23       	and	r24, r24
    4fa6:	1c f4       	brge	.+6      	; 0x4fae <LCD_voidSendCommand+0x8a>
		__ticks = 1;
    4fa8:	81 e0       	ldi	r24, 0x01	; 1
    4faa:	88 a7       	std	Y+40, r24	; 0x28
    4fac:	91 c0       	rjmp	.+290    	; 0x50d0 <LCD_voidSendCommand+0x1ac>
	else if (__tmp > 255)
    4fae:	69 a5       	ldd	r22, Y+41	; 0x29
    4fb0:	7a a5       	ldd	r23, Y+42	; 0x2a
    4fb2:	8b a5       	ldd	r24, Y+43	; 0x2b
    4fb4:	9c a5       	ldd	r25, Y+44	; 0x2c
    4fb6:	20 e0       	ldi	r18, 0x00	; 0
    4fb8:	30 e0       	ldi	r19, 0x00	; 0
    4fba:	4f e7       	ldi	r20, 0x7F	; 127
    4fbc:	53 e4       	ldi	r21, 0x43	; 67
    4fbe:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4fc2:	18 16       	cp	r1, r24
    4fc4:	0c f0       	brlt	.+2      	; 0x4fc8 <LCD_voidSendCommand+0xa4>
    4fc6:	7b c0       	rjmp	.+246    	; 0x50be <LCD_voidSendCommand+0x19a>
	{
		_delay_ms(__us / 1000.0);
    4fc8:	6d a5       	ldd	r22, Y+45	; 0x2d
    4fca:	7e a5       	ldd	r23, Y+46	; 0x2e
    4fcc:	8f a5       	ldd	r24, Y+47	; 0x2f
    4fce:	98 a9       	ldd	r25, Y+48	; 0x30
    4fd0:	20 e0       	ldi	r18, 0x00	; 0
    4fd2:	30 e0       	ldi	r19, 0x00	; 0
    4fd4:	4a e7       	ldi	r20, 0x7A	; 122
    4fd6:	54 e4       	ldi	r21, 0x44	; 68
    4fd8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4fdc:	dc 01       	movw	r26, r24
    4fde:	cb 01       	movw	r24, r22
    4fe0:	8c a3       	std	Y+36, r24	; 0x24
    4fe2:	9d a3       	std	Y+37, r25	; 0x25
    4fe4:	ae a3       	std	Y+38, r26	; 0x26
    4fe6:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4fe8:	6c a1       	ldd	r22, Y+36	; 0x24
    4fea:	7d a1       	ldd	r23, Y+37	; 0x25
    4fec:	8e a1       	ldd	r24, Y+38	; 0x26
    4fee:	9f a1       	ldd	r25, Y+39	; 0x27
    4ff0:	20 e0       	ldi	r18, 0x00	; 0
    4ff2:	30 e0       	ldi	r19, 0x00	; 0
    4ff4:	4a ef       	ldi	r20, 0xFA	; 250
    4ff6:	54 e4       	ldi	r21, 0x44	; 68
    4ff8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ffc:	dc 01       	movw	r26, r24
    4ffe:	cb 01       	movw	r24, r22
    5000:	88 a3       	std	Y+32, r24	; 0x20
    5002:	99 a3       	std	Y+33, r25	; 0x21
    5004:	aa a3       	std	Y+34, r26	; 0x22
    5006:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    5008:	68 a1       	ldd	r22, Y+32	; 0x20
    500a:	79 a1       	ldd	r23, Y+33	; 0x21
    500c:	8a a1       	ldd	r24, Y+34	; 0x22
    500e:	9b a1       	ldd	r25, Y+35	; 0x23
    5010:	20 e0       	ldi	r18, 0x00	; 0
    5012:	30 e0       	ldi	r19, 0x00	; 0
    5014:	40 e8       	ldi	r20, 0x80	; 128
    5016:	5f e3       	ldi	r21, 0x3F	; 63
    5018:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    501c:	88 23       	and	r24, r24
    501e:	2c f4       	brge	.+10     	; 0x502a <LCD_voidSendCommand+0x106>
		__ticks = 1;
    5020:	81 e0       	ldi	r24, 0x01	; 1
    5022:	90 e0       	ldi	r25, 0x00	; 0
    5024:	9f 8f       	std	Y+31, r25	; 0x1f
    5026:	8e 8f       	std	Y+30, r24	; 0x1e
    5028:	3f c0       	rjmp	.+126    	; 0x50a8 <LCD_voidSendCommand+0x184>
	else if (__tmp > 65535)
    502a:	68 a1       	ldd	r22, Y+32	; 0x20
    502c:	79 a1       	ldd	r23, Y+33	; 0x21
    502e:	8a a1       	ldd	r24, Y+34	; 0x22
    5030:	9b a1       	ldd	r25, Y+35	; 0x23
    5032:	20 e0       	ldi	r18, 0x00	; 0
    5034:	3f ef       	ldi	r19, 0xFF	; 255
    5036:	4f e7       	ldi	r20, 0x7F	; 127
    5038:	57 e4       	ldi	r21, 0x47	; 71
    503a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    503e:	18 16       	cp	r1, r24
    5040:	4c f5       	brge	.+82     	; 0x5094 <LCD_voidSendCommand+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5042:	6c a1       	ldd	r22, Y+36	; 0x24
    5044:	7d a1       	ldd	r23, Y+37	; 0x25
    5046:	8e a1       	ldd	r24, Y+38	; 0x26
    5048:	9f a1       	ldd	r25, Y+39	; 0x27
    504a:	20 e0       	ldi	r18, 0x00	; 0
    504c:	30 e0       	ldi	r19, 0x00	; 0
    504e:	40 e2       	ldi	r20, 0x20	; 32
    5050:	51 e4       	ldi	r21, 0x41	; 65
    5052:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5056:	dc 01       	movw	r26, r24
    5058:	cb 01       	movw	r24, r22
    505a:	bc 01       	movw	r22, r24
    505c:	cd 01       	movw	r24, r26
    505e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5062:	dc 01       	movw	r26, r24
    5064:	cb 01       	movw	r24, r22
    5066:	9f 8f       	std	Y+31, r25	; 0x1f
    5068:	8e 8f       	std	Y+30, r24	; 0x1e
    506a:	0f c0       	rjmp	.+30     	; 0x508a <LCD_voidSendCommand+0x166>
    506c:	88 ec       	ldi	r24, 0xC8	; 200
    506e:	90 e0       	ldi	r25, 0x00	; 0
    5070:	9d 8f       	std	Y+29, r25	; 0x1d
    5072:	8c 8f       	std	Y+28, r24	; 0x1c
    5074:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5076:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5078:	01 97       	sbiw	r24, 0x01	; 1
    507a:	f1 f7       	brne	.-4      	; 0x5078 <LCD_voidSendCommand+0x154>
    507c:	9d 8f       	std	Y+29, r25	; 0x1d
    507e:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5080:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5082:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5084:	01 97       	sbiw	r24, 0x01	; 1
    5086:	9f 8f       	std	Y+31, r25	; 0x1f
    5088:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    508a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    508c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    508e:	00 97       	sbiw	r24, 0x00	; 0
    5090:	69 f7       	brne	.-38     	; 0x506c <LCD_voidSendCommand+0x148>
    5092:	24 c0       	rjmp	.+72     	; 0x50dc <LCD_voidSendCommand+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5094:	68 a1       	ldd	r22, Y+32	; 0x20
    5096:	79 a1       	ldd	r23, Y+33	; 0x21
    5098:	8a a1       	ldd	r24, Y+34	; 0x22
    509a:	9b a1       	ldd	r25, Y+35	; 0x23
    509c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    50a0:	dc 01       	movw	r26, r24
    50a2:	cb 01       	movw	r24, r22
    50a4:	9f 8f       	std	Y+31, r25	; 0x1f
    50a6:	8e 8f       	std	Y+30, r24	; 0x1e
    50a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    50aa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    50ac:	9b 8f       	std	Y+27, r25	; 0x1b
    50ae:	8a 8f       	std	Y+26, r24	; 0x1a
    50b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    50b2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    50b4:	01 97       	sbiw	r24, 0x01	; 1
    50b6:	f1 f7       	brne	.-4      	; 0x50b4 <LCD_voidSendCommand+0x190>
    50b8:	9b 8f       	std	Y+27, r25	; 0x1b
    50ba:	8a 8f       	std	Y+26, r24	; 0x1a
    50bc:	0f c0       	rjmp	.+30     	; 0x50dc <LCD_voidSendCommand+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    50be:	69 a5       	ldd	r22, Y+41	; 0x29
    50c0:	7a a5       	ldd	r23, Y+42	; 0x2a
    50c2:	8b a5       	ldd	r24, Y+43	; 0x2b
    50c4:	9c a5       	ldd	r25, Y+44	; 0x2c
    50c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    50ca:	dc 01       	movw	r26, r24
    50cc:	cb 01       	movw	r24, r22
    50ce:	88 a7       	std	Y+40, r24	; 0x28
    50d0:	88 a5       	ldd	r24, Y+40	; 0x28
    50d2:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    50d4:	89 8d       	ldd	r24, Y+25	; 0x19
    50d6:	8a 95       	dec	r24
    50d8:	f1 f7       	brne	.-4      	; 0x50d6 <LCD_voidSendCommand+0x1b2>
    50da:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(500);
	GPIO_voidSetPinValue(LCD_E_PORT , LCD_E_PIN , LOW);
    50dc:	80 e0       	ldi	r24, 0x00	; 0
    50de:	62 e0       	ldi	r22, 0x02	; 2
    50e0:	40 e0       	ldi	r20, 0x00	; 0
    50e2:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>
    50e6:	80 e0       	ldi	r24, 0x00	; 0
    50e8:	90 e0       	ldi	r25, 0x00	; 0
    50ea:	aa ef       	ldi	r26, 0xFA	; 250
    50ec:	b3 e4       	ldi	r27, 0x43	; 67
    50ee:	8d 8b       	std	Y+21, r24	; 0x15
    50f0:	9e 8b       	std	Y+22, r25	; 0x16
    50f2:	af 8b       	std	Y+23, r26	; 0x17
    50f4:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    50f6:	6d 89       	ldd	r22, Y+21	; 0x15
    50f8:	7e 89       	ldd	r23, Y+22	; 0x16
    50fa:	8f 89       	ldd	r24, Y+23	; 0x17
    50fc:	98 8d       	ldd	r25, Y+24	; 0x18
    50fe:	2b ea       	ldi	r18, 0xAB	; 171
    5100:	3a ea       	ldi	r19, 0xAA	; 170
    5102:	4a e2       	ldi	r20, 0x2A	; 42
    5104:	50 e4       	ldi	r21, 0x40	; 64
    5106:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    510a:	dc 01       	movw	r26, r24
    510c:	cb 01       	movw	r24, r22
    510e:	89 8b       	std	Y+17, r24	; 0x11
    5110:	9a 8b       	std	Y+18, r25	; 0x12
    5112:	ab 8b       	std	Y+19, r26	; 0x13
    5114:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    5116:	69 89       	ldd	r22, Y+17	; 0x11
    5118:	7a 89       	ldd	r23, Y+18	; 0x12
    511a:	8b 89       	ldd	r24, Y+19	; 0x13
    511c:	9c 89       	ldd	r25, Y+20	; 0x14
    511e:	20 e0       	ldi	r18, 0x00	; 0
    5120:	30 e0       	ldi	r19, 0x00	; 0
    5122:	40 e8       	ldi	r20, 0x80	; 128
    5124:	5f e3       	ldi	r21, 0x3F	; 63
    5126:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    512a:	88 23       	and	r24, r24
    512c:	1c f4       	brge	.+6      	; 0x5134 <LCD_voidSendCommand+0x210>
		__ticks = 1;
    512e:	81 e0       	ldi	r24, 0x01	; 1
    5130:	88 8b       	std	Y+16, r24	; 0x10
    5132:	91 c0       	rjmp	.+290    	; 0x5256 <LCD_voidSendCommand+0x332>
	else if (__tmp > 255)
    5134:	69 89       	ldd	r22, Y+17	; 0x11
    5136:	7a 89       	ldd	r23, Y+18	; 0x12
    5138:	8b 89       	ldd	r24, Y+19	; 0x13
    513a:	9c 89       	ldd	r25, Y+20	; 0x14
    513c:	20 e0       	ldi	r18, 0x00	; 0
    513e:	30 e0       	ldi	r19, 0x00	; 0
    5140:	4f e7       	ldi	r20, 0x7F	; 127
    5142:	53 e4       	ldi	r21, 0x43	; 67
    5144:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5148:	18 16       	cp	r1, r24
    514a:	0c f0       	brlt	.+2      	; 0x514e <LCD_voidSendCommand+0x22a>
    514c:	7b c0       	rjmp	.+246    	; 0x5244 <LCD_voidSendCommand+0x320>
	{
		_delay_ms(__us / 1000.0);
    514e:	6d 89       	ldd	r22, Y+21	; 0x15
    5150:	7e 89       	ldd	r23, Y+22	; 0x16
    5152:	8f 89       	ldd	r24, Y+23	; 0x17
    5154:	98 8d       	ldd	r25, Y+24	; 0x18
    5156:	20 e0       	ldi	r18, 0x00	; 0
    5158:	30 e0       	ldi	r19, 0x00	; 0
    515a:	4a e7       	ldi	r20, 0x7A	; 122
    515c:	54 e4       	ldi	r21, 0x44	; 68
    515e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    5162:	dc 01       	movw	r26, r24
    5164:	cb 01       	movw	r24, r22
    5166:	8c 87       	std	Y+12, r24	; 0x0c
    5168:	9d 87       	std	Y+13, r25	; 0x0d
    516a:	ae 87       	std	Y+14, r26	; 0x0e
    516c:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    516e:	6c 85       	ldd	r22, Y+12	; 0x0c
    5170:	7d 85       	ldd	r23, Y+13	; 0x0d
    5172:	8e 85       	ldd	r24, Y+14	; 0x0e
    5174:	9f 85       	ldd	r25, Y+15	; 0x0f
    5176:	20 e0       	ldi	r18, 0x00	; 0
    5178:	30 e0       	ldi	r19, 0x00	; 0
    517a:	4a ef       	ldi	r20, 0xFA	; 250
    517c:	54 e4       	ldi	r21, 0x44	; 68
    517e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5182:	dc 01       	movw	r26, r24
    5184:	cb 01       	movw	r24, r22
    5186:	88 87       	std	Y+8, r24	; 0x08
    5188:	99 87       	std	Y+9, r25	; 0x09
    518a:	aa 87       	std	Y+10, r26	; 0x0a
    518c:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    518e:	68 85       	ldd	r22, Y+8	; 0x08
    5190:	79 85       	ldd	r23, Y+9	; 0x09
    5192:	8a 85       	ldd	r24, Y+10	; 0x0a
    5194:	9b 85       	ldd	r25, Y+11	; 0x0b
    5196:	20 e0       	ldi	r18, 0x00	; 0
    5198:	30 e0       	ldi	r19, 0x00	; 0
    519a:	40 e8       	ldi	r20, 0x80	; 128
    519c:	5f e3       	ldi	r21, 0x3F	; 63
    519e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    51a2:	88 23       	and	r24, r24
    51a4:	2c f4       	brge	.+10     	; 0x51b0 <LCD_voidSendCommand+0x28c>
		__ticks = 1;
    51a6:	81 e0       	ldi	r24, 0x01	; 1
    51a8:	90 e0       	ldi	r25, 0x00	; 0
    51aa:	9f 83       	std	Y+7, r25	; 0x07
    51ac:	8e 83       	std	Y+6, r24	; 0x06
    51ae:	3f c0       	rjmp	.+126    	; 0x522e <LCD_voidSendCommand+0x30a>
	else if (__tmp > 65535)
    51b0:	68 85       	ldd	r22, Y+8	; 0x08
    51b2:	79 85       	ldd	r23, Y+9	; 0x09
    51b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    51b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    51b8:	20 e0       	ldi	r18, 0x00	; 0
    51ba:	3f ef       	ldi	r19, 0xFF	; 255
    51bc:	4f e7       	ldi	r20, 0x7F	; 127
    51be:	57 e4       	ldi	r21, 0x47	; 71
    51c0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    51c4:	18 16       	cp	r1, r24
    51c6:	4c f5       	brge	.+82     	; 0x521a <LCD_voidSendCommand+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    51c8:	6c 85       	ldd	r22, Y+12	; 0x0c
    51ca:	7d 85       	ldd	r23, Y+13	; 0x0d
    51cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    51ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    51d0:	20 e0       	ldi	r18, 0x00	; 0
    51d2:	30 e0       	ldi	r19, 0x00	; 0
    51d4:	40 e2       	ldi	r20, 0x20	; 32
    51d6:	51 e4       	ldi	r21, 0x41	; 65
    51d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    51dc:	dc 01       	movw	r26, r24
    51de:	cb 01       	movw	r24, r22
    51e0:	bc 01       	movw	r22, r24
    51e2:	cd 01       	movw	r24, r26
    51e4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    51e8:	dc 01       	movw	r26, r24
    51ea:	cb 01       	movw	r24, r22
    51ec:	9f 83       	std	Y+7, r25	; 0x07
    51ee:	8e 83       	std	Y+6, r24	; 0x06
    51f0:	0f c0       	rjmp	.+30     	; 0x5210 <LCD_voidSendCommand+0x2ec>
    51f2:	88 ec       	ldi	r24, 0xC8	; 200
    51f4:	90 e0       	ldi	r25, 0x00	; 0
    51f6:	9d 83       	std	Y+5, r25	; 0x05
    51f8:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    51fa:	8c 81       	ldd	r24, Y+4	; 0x04
    51fc:	9d 81       	ldd	r25, Y+5	; 0x05
    51fe:	01 97       	sbiw	r24, 0x01	; 1
    5200:	f1 f7       	brne	.-4      	; 0x51fe <LCD_voidSendCommand+0x2da>
    5202:	9d 83       	std	Y+5, r25	; 0x05
    5204:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5206:	8e 81       	ldd	r24, Y+6	; 0x06
    5208:	9f 81       	ldd	r25, Y+7	; 0x07
    520a:	01 97       	sbiw	r24, 0x01	; 1
    520c:	9f 83       	std	Y+7, r25	; 0x07
    520e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5210:	8e 81       	ldd	r24, Y+6	; 0x06
    5212:	9f 81       	ldd	r25, Y+7	; 0x07
    5214:	00 97       	sbiw	r24, 0x00	; 0
    5216:	69 f7       	brne	.-38     	; 0x51f2 <LCD_voidSendCommand+0x2ce>
    5218:	24 c0       	rjmp	.+72     	; 0x5262 <LCD_voidSendCommand+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    521a:	68 85       	ldd	r22, Y+8	; 0x08
    521c:	79 85       	ldd	r23, Y+9	; 0x09
    521e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5220:	9b 85       	ldd	r25, Y+11	; 0x0b
    5222:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5226:	dc 01       	movw	r26, r24
    5228:	cb 01       	movw	r24, r22
    522a:	9f 83       	std	Y+7, r25	; 0x07
    522c:	8e 83       	std	Y+6, r24	; 0x06
    522e:	8e 81       	ldd	r24, Y+6	; 0x06
    5230:	9f 81       	ldd	r25, Y+7	; 0x07
    5232:	9b 83       	std	Y+3, r25	; 0x03
    5234:	8a 83       	std	Y+2, r24	; 0x02
    5236:	8a 81       	ldd	r24, Y+2	; 0x02
    5238:	9b 81       	ldd	r25, Y+3	; 0x03
    523a:	01 97       	sbiw	r24, 0x01	; 1
    523c:	f1 f7       	brne	.-4      	; 0x523a <LCD_voidSendCommand+0x316>
    523e:	9b 83       	std	Y+3, r25	; 0x03
    5240:	8a 83       	std	Y+2, r24	; 0x02
    5242:	0f c0       	rjmp	.+30     	; 0x5262 <LCD_voidSendCommand+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5244:	69 89       	ldd	r22, Y+17	; 0x11
    5246:	7a 89       	ldd	r23, Y+18	; 0x12
    5248:	8b 89       	ldd	r24, Y+19	; 0x13
    524a:	9c 89       	ldd	r25, Y+20	; 0x14
    524c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5250:	dc 01       	movw	r26, r24
    5252:	cb 01       	movw	r24, r22
    5254:	88 8b       	std	Y+16, r24	; 0x10
    5256:	88 89       	ldd	r24, Y+16	; 0x10
    5258:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    525a:	89 81       	ldd	r24, Y+1	; 0x01
    525c:	8a 95       	dec	r24
    525e:	f1 f7       	brne	.-4      	; 0x525c <LCD_voidSendCommand+0x338>
    5260:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(500);
}
    5262:	e1 96       	adiw	r28, 0x31	; 49
    5264:	0f b6       	in	r0, 0x3f	; 63
    5266:	f8 94       	cli
    5268:	de bf       	out	0x3e, r29	; 62
    526a:	0f be       	out	0x3f, r0	; 63
    526c:	cd bf       	out	0x3d, r28	; 61
    526e:	cf 91       	pop	r28
    5270:	df 91       	pop	r29
    5272:	08 95       	ret

00005274 <LCD_voidSendChar>:

void LCD_voidSendChar (u8 Cpy_data)
{
    5274:	df 93       	push	r29
    5276:	cf 93       	push	r28
    5278:	cd b7       	in	r28, 0x3d	; 61
    527a:	de b7       	in	r29, 0x3e	; 62
    527c:	e1 97       	sbiw	r28, 0x31	; 49
    527e:	0f b6       	in	r0, 0x3f	; 63
    5280:	f8 94       	cli
    5282:	de bf       	out	0x3e, r29	; 62
    5284:	0f be       	out	0x3f, r0	; 63
    5286:	cd bf       	out	0x3d, r28	; 61
    5288:	89 ab       	std	Y+49, r24	; 0x31
	/* Reset RW */
	GPIO_voidSetPinValue(LCD_RW_PORT , LCD_RW_PIN , LOW);
    528a:	80 e0       	ldi	r24, 0x00	; 0
    528c:	61 e0       	ldi	r22, 0x01	; 1
    528e:	40 e0       	ldi	r20, 0x00	; 0
    5290:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>

	/* Set RS */
	GPIO_voidSetPinValue(LCD_RS_PORT , LCD_RS_PIN , HIGH);
    5294:	80 e0       	ldi	r24, 0x00	; 0
    5296:	60 e0       	ldi	r22, 0x00	; 0
    5298:	41 e0       	ldi	r20, 0x01	; 1
    529a:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>

	/* Write the command to data port */
	GPIO_voidSetPortValue(LCD_DATA_PORT , Cpy_data);
    529e:	83 e0       	ldi	r24, 0x03	; 3
    52a0:	69 a9       	ldd	r22, Y+49	; 0x31
    52a2:	0e 94 37 23 	call	0x466e	; 0x466e <GPIO_voidSetPortValue>

	/* Send Enable signal */
	GPIO_voidSetPinValue(LCD_E_PORT , LCD_E_PIN , HIGH);
    52a6:	80 e0       	ldi	r24, 0x00	; 0
    52a8:	62 e0       	ldi	r22, 0x02	; 2
    52aa:	41 e0       	ldi	r20, 0x01	; 1
    52ac:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>
    52b0:	80 e0       	ldi	r24, 0x00	; 0
    52b2:	90 e0       	ldi	r25, 0x00	; 0
    52b4:	aa ef       	ldi	r26, 0xFA	; 250
    52b6:	b3 e4       	ldi	r27, 0x43	; 67
    52b8:	8d a7       	std	Y+45, r24	; 0x2d
    52ba:	9e a7       	std	Y+46, r25	; 0x2e
    52bc:	af a7       	std	Y+47, r26	; 0x2f
    52be:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    52c0:	6d a5       	ldd	r22, Y+45	; 0x2d
    52c2:	7e a5       	ldd	r23, Y+46	; 0x2e
    52c4:	8f a5       	ldd	r24, Y+47	; 0x2f
    52c6:	98 a9       	ldd	r25, Y+48	; 0x30
    52c8:	2b ea       	ldi	r18, 0xAB	; 171
    52ca:	3a ea       	ldi	r19, 0xAA	; 170
    52cc:	4a e2       	ldi	r20, 0x2A	; 42
    52ce:	50 e4       	ldi	r21, 0x40	; 64
    52d0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    52d4:	dc 01       	movw	r26, r24
    52d6:	cb 01       	movw	r24, r22
    52d8:	89 a7       	std	Y+41, r24	; 0x29
    52da:	9a a7       	std	Y+42, r25	; 0x2a
    52dc:	ab a7       	std	Y+43, r26	; 0x2b
    52de:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    52e0:	69 a5       	ldd	r22, Y+41	; 0x29
    52e2:	7a a5       	ldd	r23, Y+42	; 0x2a
    52e4:	8b a5       	ldd	r24, Y+43	; 0x2b
    52e6:	9c a5       	ldd	r25, Y+44	; 0x2c
    52e8:	20 e0       	ldi	r18, 0x00	; 0
    52ea:	30 e0       	ldi	r19, 0x00	; 0
    52ec:	40 e8       	ldi	r20, 0x80	; 128
    52ee:	5f e3       	ldi	r21, 0x3F	; 63
    52f0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    52f4:	88 23       	and	r24, r24
    52f6:	1c f4       	brge	.+6      	; 0x52fe <LCD_voidSendChar+0x8a>
		__ticks = 1;
    52f8:	81 e0       	ldi	r24, 0x01	; 1
    52fa:	88 a7       	std	Y+40, r24	; 0x28
    52fc:	91 c0       	rjmp	.+290    	; 0x5420 <LCD_voidSendChar+0x1ac>
	else if (__tmp > 255)
    52fe:	69 a5       	ldd	r22, Y+41	; 0x29
    5300:	7a a5       	ldd	r23, Y+42	; 0x2a
    5302:	8b a5       	ldd	r24, Y+43	; 0x2b
    5304:	9c a5       	ldd	r25, Y+44	; 0x2c
    5306:	20 e0       	ldi	r18, 0x00	; 0
    5308:	30 e0       	ldi	r19, 0x00	; 0
    530a:	4f e7       	ldi	r20, 0x7F	; 127
    530c:	53 e4       	ldi	r21, 0x43	; 67
    530e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5312:	18 16       	cp	r1, r24
    5314:	0c f0       	brlt	.+2      	; 0x5318 <LCD_voidSendChar+0xa4>
    5316:	7b c0       	rjmp	.+246    	; 0x540e <LCD_voidSendChar+0x19a>
	{
		_delay_ms(__us / 1000.0);
    5318:	6d a5       	ldd	r22, Y+45	; 0x2d
    531a:	7e a5       	ldd	r23, Y+46	; 0x2e
    531c:	8f a5       	ldd	r24, Y+47	; 0x2f
    531e:	98 a9       	ldd	r25, Y+48	; 0x30
    5320:	20 e0       	ldi	r18, 0x00	; 0
    5322:	30 e0       	ldi	r19, 0x00	; 0
    5324:	4a e7       	ldi	r20, 0x7A	; 122
    5326:	54 e4       	ldi	r21, 0x44	; 68
    5328:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    532c:	dc 01       	movw	r26, r24
    532e:	cb 01       	movw	r24, r22
    5330:	8c a3       	std	Y+36, r24	; 0x24
    5332:	9d a3       	std	Y+37, r25	; 0x25
    5334:	ae a3       	std	Y+38, r26	; 0x26
    5336:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5338:	6c a1       	ldd	r22, Y+36	; 0x24
    533a:	7d a1       	ldd	r23, Y+37	; 0x25
    533c:	8e a1       	ldd	r24, Y+38	; 0x26
    533e:	9f a1       	ldd	r25, Y+39	; 0x27
    5340:	20 e0       	ldi	r18, 0x00	; 0
    5342:	30 e0       	ldi	r19, 0x00	; 0
    5344:	4a ef       	ldi	r20, 0xFA	; 250
    5346:	54 e4       	ldi	r21, 0x44	; 68
    5348:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    534c:	dc 01       	movw	r26, r24
    534e:	cb 01       	movw	r24, r22
    5350:	88 a3       	std	Y+32, r24	; 0x20
    5352:	99 a3       	std	Y+33, r25	; 0x21
    5354:	aa a3       	std	Y+34, r26	; 0x22
    5356:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    5358:	68 a1       	ldd	r22, Y+32	; 0x20
    535a:	79 a1       	ldd	r23, Y+33	; 0x21
    535c:	8a a1       	ldd	r24, Y+34	; 0x22
    535e:	9b a1       	ldd	r25, Y+35	; 0x23
    5360:	20 e0       	ldi	r18, 0x00	; 0
    5362:	30 e0       	ldi	r19, 0x00	; 0
    5364:	40 e8       	ldi	r20, 0x80	; 128
    5366:	5f e3       	ldi	r21, 0x3F	; 63
    5368:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    536c:	88 23       	and	r24, r24
    536e:	2c f4       	brge	.+10     	; 0x537a <LCD_voidSendChar+0x106>
		__ticks = 1;
    5370:	81 e0       	ldi	r24, 0x01	; 1
    5372:	90 e0       	ldi	r25, 0x00	; 0
    5374:	9f 8f       	std	Y+31, r25	; 0x1f
    5376:	8e 8f       	std	Y+30, r24	; 0x1e
    5378:	3f c0       	rjmp	.+126    	; 0x53f8 <LCD_voidSendChar+0x184>
	else if (__tmp > 65535)
    537a:	68 a1       	ldd	r22, Y+32	; 0x20
    537c:	79 a1       	ldd	r23, Y+33	; 0x21
    537e:	8a a1       	ldd	r24, Y+34	; 0x22
    5380:	9b a1       	ldd	r25, Y+35	; 0x23
    5382:	20 e0       	ldi	r18, 0x00	; 0
    5384:	3f ef       	ldi	r19, 0xFF	; 255
    5386:	4f e7       	ldi	r20, 0x7F	; 127
    5388:	57 e4       	ldi	r21, 0x47	; 71
    538a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    538e:	18 16       	cp	r1, r24
    5390:	4c f5       	brge	.+82     	; 0x53e4 <LCD_voidSendChar+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5392:	6c a1       	ldd	r22, Y+36	; 0x24
    5394:	7d a1       	ldd	r23, Y+37	; 0x25
    5396:	8e a1       	ldd	r24, Y+38	; 0x26
    5398:	9f a1       	ldd	r25, Y+39	; 0x27
    539a:	20 e0       	ldi	r18, 0x00	; 0
    539c:	30 e0       	ldi	r19, 0x00	; 0
    539e:	40 e2       	ldi	r20, 0x20	; 32
    53a0:	51 e4       	ldi	r21, 0x41	; 65
    53a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    53a6:	dc 01       	movw	r26, r24
    53a8:	cb 01       	movw	r24, r22
    53aa:	bc 01       	movw	r22, r24
    53ac:	cd 01       	movw	r24, r26
    53ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    53b2:	dc 01       	movw	r26, r24
    53b4:	cb 01       	movw	r24, r22
    53b6:	9f 8f       	std	Y+31, r25	; 0x1f
    53b8:	8e 8f       	std	Y+30, r24	; 0x1e
    53ba:	0f c0       	rjmp	.+30     	; 0x53da <LCD_voidSendChar+0x166>
    53bc:	88 ec       	ldi	r24, 0xC8	; 200
    53be:	90 e0       	ldi	r25, 0x00	; 0
    53c0:	9d 8f       	std	Y+29, r25	; 0x1d
    53c2:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    53c4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    53c6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    53c8:	01 97       	sbiw	r24, 0x01	; 1
    53ca:	f1 f7       	brne	.-4      	; 0x53c8 <LCD_voidSendChar+0x154>
    53cc:	9d 8f       	std	Y+29, r25	; 0x1d
    53ce:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53d0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    53d2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    53d4:	01 97       	sbiw	r24, 0x01	; 1
    53d6:	9f 8f       	std	Y+31, r25	; 0x1f
    53d8:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    53dc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    53de:	00 97       	sbiw	r24, 0x00	; 0
    53e0:	69 f7       	brne	.-38     	; 0x53bc <LCD_voidSendChar+0x148>
    53e2:	24 c0       	rjmp	.+72     	; 0x542c <LCD_voidSendChar+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53e4:	68 a1       	ldd	r22, Y+32	; 0x20
    53e6:	79 a1       	ldd	r23, Y+33	; 0x21
    53e8:	8a a1       	ldd	r24, Y+34	; 0x22
    53ea:	9b a1       	ldd	r25, Y+35	; 0x23
    53ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    53f0:	dc 01       	movw	r26, r24
    53f2:	cb 01       	movw	r24, r22
    53f4:	9f 8f       	std	Y+31, r25	; 0x1f
    53f6:	8e 8f       	std	Y+30, r24	; 0x1e
    53f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    53fa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    53fc:	9b 8f       	std	Y+27, r25	; 0x1b
    53fe:	8a 8f       	std	Y+26, r24	; 0x1a
    5400:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5402:	9b 8d       	ldd	r25, Y+27	; 0x1b
    5404:	01 97       	sbiw	r24, 0x01	; 1
    5406:	f1 f7       	brne	.-4      	; 0x5404 <LCD_voidSendChar+0x190>
    5408:	9b 8f       	std	Y+27, r25	; 0x1b
    540a:	8a 8f       	std	Y+26, r24	; 0x1a
    540c:	0f c0       	rjmp	.+30     	; 0x542c <LCD_voidSendChar+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    540e:	69 a5       	ldd	r22, Y+41	; 0x29
    5410:	7a a5       	ldd	r23, Y+42	; 0x2a
    5412:	8b a5       	ldd	r24, Y+43	; 0x2b
    5414:	9c a5       	ldd	r25, Y+44	; 0x2c
    5416:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    541a:	dc 01       	movw	r26, r24
    541c:	cb 01       	movw	r24, r22
    541e:	88 a7       	std	Y+40, r24	; 0x28
    5420:	88 a5       	ldd	r24, Y+40	; 0x28
    5422:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5424:	89 8d       	ldd	r24, Y+25	; 0x19
    5426:	8a 95       	dec	r24
    5428:	f1 f7       	brne	.-4      	; 0x5426 <LCD_voidSendChar+0x1b2>
    542a:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(500);
	GPIO_voidSetPinValue(LCD_E_PORT , LCD_E_PIN , LOW);
    542c:	80 e0       	ldi	r24, 0x00	; 0
    542e:	62 e0       	ldi	r22, 0x02	; 2
    5430:	40 e0       	ldi	r20, 0x00	; 0
    5432:	0e 94 37 21 	call	0x426e	; 0x426e <GPIO_voidSetPinValue>
    5436:	80 e0       	ldi	r24, 0x00	; 0
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	aa ef       	ldi	r26, 0xFA	; 250
    543c:	b3 e4       	ldi	r27, 0x43	; 67
    543e:	8d 8b       	std	Y+21, r24	; 0x15
    5440:	9e 8b       	std	Y+22, r25	; 0x16
    5442:	af 8b       	std	Y+23, r26	; 0x17
    5444:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    5446:	6d 89       	ldd	r22, Y+21	; 0x15
    5448:	7e 89       	ldd	r23, Y+22	; 0x16
    544a:	8f 89       	ldd	r24, Y+23	; 0x17
    544c:	98 8d       	ldd	r25, Y+24	; 0x18
    544e:	2b ea       	ldi	r18, 0xAB	; 171
    5450:	3a ea       	ldi	r19, 0xAA	; 170
    5452:	4a e2       	ldi	r20, 0x2A	; 42
    5454:	50 e4       	ldi	r21, 0x40	; 64
    5456:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    545a:	dc 01       	movw	r26, r24
    545c:	cb 01       	movw	r24, r22
    545e:	89 8b       	std	Y+17, r24	; 0x11
    5460:	9a 8b       	std	Y+18, r25	; 0x12
    5462:	ab 8b       	std	Y+19, r26	; 0x13
    5464:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    5466:	69 89       	ldd	r22, Y+17	; 0x11
    5468:	7a 89       	ldd	r23, Y+18	; 0x12
    546a:	8b 89       	ldd	r24, Y+19	; 0x13
    546c:	9c 89       	ldd	r25, Y+20	; 0x14
    546e:	20 e0       	ldi	r18, 0x00	; 0
    5470:	30 e0       	ldi	r19, 0x00	; 0
    5472:	40 e8       	ldi	r20, 0x80	; 128
    5474:	5f e3       	ldi	r21, 0x3F	; 63
    5476:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    547a:	88 23       	and	r24, r24
    547c:	1c f4       	brge	.+6      	; 0x5484 <LCD_voidSendChar+0x210>
		__ticks = 1;
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	88 8b       	std	Y+16, r24	; 0x10
    5482:	91 c0       	rjmp	.+290    	; 0x55a6 <LCD_voidSendChar+0x332>
	else if (__tmp > 255)
    5484:	69 89       	ldd	r22, Y+17	; 0x11
    5486:	7a 89       	ldd	r23, Y+18	; 0x12
    5488:	8b 89       	ldd	r24, Y+19	; 0x13
    548a:	9c 89       	ldd	r25, Y+20	; 0x14
    548c:	20 e0       	ldi	r18, 0x00	; 0
    548e:	30 e0       	ldi	r19, 0x00	; 0
    5490:	4f e7       	ldi	r20, 0x7F	; 127
    5492:	53 e4       	ldi	r21, 0x43	; 67
    5494:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5498:	18 16       	cp	r1, r24
    549a:	0c f0       	brlt	.+2      	; 0x549e <LCD_voidSendChar+0x22a>
    549c:	7b c0       	rjmp	.+246    	; 0x5594 <LCD_voidSendChar+0x320>
	{
		_delay_ms(__us / 1000.0);
    549e:	6d 89       	ldd	r22, Y+21	; 0x15
    54a0:	7e 89       	ldd	r23, Y+22	; 0x16
    54a2:	8f 89       	ldd	r24, Y+23	; 0x17
    54a4:	98 8d       	ldd	r25, Y+24	; 0x18
    54a6:	20 e0       	ldi	r18, 0x00	; 0
    54a8:	30 e0       	ldi	r19, 0x00	; 0
    54aa:	4a e7       	ldi	r20, 0x7A	; 122
    54ac:	54 e4       	ldi	r21, 0x44	; 68
    54ae:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    54b2:	dc 01       	movw	r26, r24
    54b4:	cb 01       	movw	r24, r22
    54b6:	8c 87       	std	Y+12, r24	; 0x0c
    54b8:	9d 87       	std	Y+13, r25	; 0x0d
    54ba:	ae 87       	std	Y+14, r26	; 0x0e
    54bc:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    54be:	6c 85       	ldd	r22, Y+12	; 0x0c
    54c0:	7d 85       	ldd	r23, Y+13	; 0x0d
    54c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    54c4:	9f 85       	ldd	r25, Y+15	; 0x0f
    54c6:	20 e0       	ldi	r18, 0x00	; 0
    54c8:	30 e0       	ldi	r19, 0x00	; 0
    54ca:	4a ef       	ldi	r20, 0xFA	; 250
    54cc:	54 e4       	ldi	r21, 0x44	; 68
    54ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54d2:	dc 01       	movw	r26, r24
    54d4:	cb 01       	movw	r24, r22
    54d6:	88 87       	std	Y+8, r24	; 0x08
    54d8:	99 87       	std	Y+9, r25	; 0x09
    54da:	aa 87       	std	Y+10, r26	; 0x0a
    54dc:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    54de:	68 85       	ldd	r22, Y+8	; 0x08
    54e0:	79 85       	ldd	r23, Y+9	; 0x09
    54e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    54e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    54e6:	20 e0       	ldi	r18, 0x00	; 0
    54e8:	30 e0       	ldi	r19, 0x00	; 0
    54ea:	40 e8       	ldi	r20, 0x80	; 128
    54ec:	5f e3       	ldi	r21, 0x3F	; 63
    54ee:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    54f2:	88 23       	and	r24, r24
    54f4:	2c f4       	brge	.+10     	; 0x5500 <LCD_voidSendChar+0x28c>
		__ticks = 1;
    54f6:	81 e0       	ldi	r24, 0x01	; 1
    54f8:	90 e0       	ldi	r25, 0x00	; 0
    54fa:	9f 83       	std	Y+7, r25	; 0x07
    54fc:	8e 83       	std	Y+6, r24	; 0x06
    54fe:	3f c0       	rjmp	.+126    	; 0x557e <LCD_voidSendChar+0x30a>
	else if (__tmp > 65535)
    5500:	68 85       	ldd	r22, Y+8	; 0x08
    5502:	79 85       	ldd	r23, Y+9	; 0x09
    5504:	8a 85       	ldd	r24, Y+10	; 0x0a
    5506:	9b 85       	ldd	r25, Y+11	; 0x0b
    5508:	20 e0       	ldi	r18, 0x00	; 0
    550a:	3f ef       	ldi	r19, 0xFF	; 255
    550c:	4f e7       	ldi	r20, 0x7F	; 127
    550e:	57 e4       	ldi	r21, 0x47	; 71
    5510:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5514:	18 16       	cp	r1, r24
    5516:	4c f5       	brge	.+82     	; 0x556a <LCD_voidSendChar+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5518:	6c 85       	ldd	r22, Y+12	; 0x0c
    551a:	7d 85       	ldd	r23, Y+13	; 0x0d
    551c:	8e 85       	ldd	r24, Y+14	; 0x0e
    551e:	9f 85       	ldd	r25, Y+15	; 0x0f
    5520:	20 e0       	ldi	r18, 0x00	; 0
    5522:	30 e0       	ldi	r19, 0x00	; 0
    5524:	40 e2       	ldi	r20, 0x20	; 32
    5526:	51 e4       	ldi	r21, 0x41	; 65
    5528:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    552c:	dc 01       	movw	r26, r24
    552e:	cb 01       	movw	r24, r22
    5530:	bc 01       	movw	r22, r24
    5532:	cd 01       	movw	r24, r26
    5534:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5538:	dc 01       	movw	r26, r24
    553a:	cb 01       	movw	r24, r22
    553c:	9f 83       	std	Y+7, r25	; 0x07
    553e:	8e 83       	std	Y+6, r24	; 0x06
    5540:	0f c0       	rjmp	.+30     	; 0x5560 <LCD_voidSendChar+0x2ec>
    5542:	88 ec       	ldi	r24, 0xC8	; 200
    5544:	90 e0       	ldi	r25, 0x00	; 0
    5546:	9d 83       	std	Y+5, r25	; 0x05
    5548:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    554a:	8c 81       	ldd	r24, Y+4	; 0x04
    554c:	9d 81       	ldd	r25, Y+5	; 0x05
    554e:	01 97       	sbiw	r24, 0x01	; 1
    5550:	f1 f7       	brne	.-4      	; 0x554e <LCD_voidSendChar+0x2da>
    5552:	9d 83       	std	Y+5, r25	; 0x05
    5554:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5556:	8e 81       	ldd	r24, Y+6	; 0x06
    5558:	9f 81       	ldd	r25, Y+7	; 0x07
    555a:	01 97       	sbiw	r24, 0x01	; 1
    555c:	9f 83       	std	Y+7, r25	; 0x07
    555e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5560:	8e 81       	ldd	r24, Y+6	; 0x06
    5562:	9f 81       	ldd	r25, Y+7	; 0x07
    5564:	00 97       	sbiw	r24, 0x00	; 0
    5566:	69 f7       	brne	.-38     	; 0x5542 <LCD_voidSendChar+0x2ce>
    5568:	24 c0       	rjmp	.+72     	; 0x55b2 <LCD_voidSendChar+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    556a:	68 85       	ldd	r22, Y+8	; 0x08
    556c:	79 85       	ldd	r23, Y+9	; 0x09
    556e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5570:	9b 85       	ldd	r25, Y+11	; 0x0b
    5572:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5576:	dc 01       	movw	r26, r24
    5578:	cb 01       	movw	r24, r22
    557a:	9f 83       	std	Y+7, r25	; 0x07
    557c:	8e 83       	std	Y+6, r24	; 0x06
    557e:	8e 81       	ldd	r24, Y+6	; 0x06
    5580:	9f 81       	ldd	r25, Y+7	; 0x07
    5582:	9b 83       	std	Y+3, r25	; 0x03
    5584:	8a 83       	std	Y+2, r24	; 0x02
    5586:	8a 81       	ldd	r24, Y+2	; 0x02
    5588:	9b 81       	ldd	r25, Y+3	; 0x03
    558a:	01 97       	sbiw	r24, 0x01	; 1
    558c:	f1 f7       	brne	.-4      	; 0x558a <LCD_voidSendChar+0x316>
    558e:	9b 83       	std	Y+3, r25	; 0x03
    5590:	8a 83       	std	Y+2, r24	; 0x02
    5592:	0f c0       	rjmp	.+30     	; 0x55b2 <LCD_voidSendChar+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5594:	69 89       	ldd	r22, Y+17	; 0x11
    5596:	7a 89       	ldd	r23, Y+18	; 0x12
    5598:	8b 89       	ldd	r24, Y+19	; 0x13
    559a:	9c 89       	ldd	r25, Y+20	; 0x14
    559c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55a0:	dc 01       	movw	r26, r24
    55a2:	cb 01       	movw	r24, r22
    55a4:	88 8b       	std	Y+16, r24	; 0x10
    55a6:	88 89       	ldd	r24, Y+16	; 0x10
    55a8:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55aa:	89 81       	ldd	r24, Y+1	; 0x01
    55ac:	8a 95       	dec	r24
    55ae:	f1 f7       	brne	.-4      	; 0x55ac <LCD_voidSendChar+0x338>
    55b0:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(500);
}
    55b2:	e1 96       	adiw	r28, 0x31	; 49
    55b4:	0f b6       	in	r0, 0x3f	; 63
    55b6:	f8 94       	cli
    55b8:	de bf       	out	0x3e, r29	; 62
    55ba:	0f be       	out	0x3f, r0	; 63
    55bc:	cd bf       	out	0x3d, r28	; 61
    55be:	cf 91       	pop	r28
    55c0:	df 91       	pop	r29
    55c2:	08 95       	ret

000055c4 <LCD_voidWriteString>:


void LCD_voidWriteString(const u8 *Cpy_str)
{
    55c4:	df 93       	push	r29
    55c6:	cf 93       	push	r28
    55c8:	00 d0       	rcall	.+0      	; 0x55ca <LCD_voidWriteString+0x6>
    55ca:	cd b7       	in	r28, 0x3d	; 61
    55cc:	de b7       	in	r29, 0x3e	; 62
    55ce:	9a 83       	std	Y+2, r25	; 0x02
    55d0:	89 83       	std	Y+1, r24	; 0x01
    55d2:	0a c0       	rjmp	.+20     	; 0x55e8 <LCD_voidWriteString+0x24>
	while ( (*Cpy_str) != NULL)
	{
		LCD_voidSendChar(*Cpy_str);
    55d4:	e9 81       	ldd	r30, Y+1	; 0x01
    55d6:	fa 81       	ldd	r31, Y+2	; 0x02
    55d8:	80 81       	ld	r24, Z
    55da:	0e 94 3a 29 	call	0x5274	; 0x5274 <LCD_voidSendChar>
		Cpy_str++;
    55de:	89 81       	ldd	r24, Y+1	; 0x01
    55e0:	9a 81       	ldd	r25, Y+2	; 0x02
    55e2:	01 96       	adiw	r24, 0x01	; 1
    55e4:	9a 83       	std	Y+2, r25	; 0x02
    55e6:	89 83       	std	Y+1, r24	; 0x01
}


void LCD_voidWriteString(const u8 *Cpy_str)
{
	while ( (*Cpy_str) != NULL)
    55e8:	e9 81       	ldd	r30, Y+1	; 0x01
    55ea:	fa 81       	ldd	r31, Y+2	; 0x02
    55ec:	80 81       	ld	r24, Z
    55ee:	88 23       	and	r24, r24
    55f0:	89 f7       	brne	.-30     	; 0x55d4 <LCD_voidWriteString+0x10>
	{
		LCD_voidSendChar(*Cpy_str);
		Cpy_str++;
	}
}
    55f2:	0f 90       	pop	r0
    55f4:	0f 90       	pop	r0
    55f6:	cf 91       	pop	r28
    55f8:	df 91       	pop	r29
    55fa:	08 95       	ret

000055fc <LCD_voidGoTo>:

void LCD_voidGoTo(u8 Cpy_row , u8 Cpy_column)
{
    55fc:	df 93       	push	r29
    55fe:	cf 93       	push	r28
    5600:	00 d0       	rcall	.+0      	; 0x5602 <LCD_voidGoTo+0x6>
    5602:	00 d0       	rcall	.+0      	; 0x5604 <LCD_voidGoTo+0x8>
    5604:	cd b7       	in	r28, 0x3d	; 61
    5606:	de b7       	in	r29, 0x3e	; 62
    5608:	89 83       	std	Y+1, r24	; 0x01
    560a:	6a 83       	std	Y+2, r22	; 0x02
	if ((Cpy_row>0) && (Cpy_column<=16))
    560c:	89 81       	ldd	r24, Y+1	; 0x01
    560e:	88 23       	and	r24, r24
    5610:	e1 f0       	breq	.+56     	; 0x564a <LCD_voidGoTo+0x4e>
    5612:	8a 81       	ldd	r24, Y+2	; 0x02
    5614:	81 31       	cpi	r24, 0x11	; 17
    5616:	c8 f4       	brcc	.+50     	; 0x564a <LCD_voidGoTo+0x4e>
	{
	    switch(Cpy_row)
    5618:	89 81       	ldd	r24, Y+1	; 0x01
    561a:	28 2f       	mov	r18, r24
    561c:	30 e0       	ldi	r19, 0x00	; 0
    561e:	3c 83       	std	Y+4, r19	; 0x04
    5620:	2b 83       	std	Y+3, r18	; 0x03
    5622:	8b 81       	ldd	r24, Y+3	; 0x03
    5624:	9c 81       	ldd	r25, Y+4	; 0x04
    5626:	81 30       	cpi	r24, 0x01	; 1
    5628:	91 05       	cpc	r25, r1
    562a:	31 f0       	breq	.+12     	; 0x5638 <LCD_voidGoTo+0x3c>
    562c:	2b 81       	ldd	r18, Y+3	; 0x03
    562e:	3c 81       	ldd	r19, Y+4	; 0x04
    5630:	22 30       	cpi	r18, 0x02	; 2
    5632:	31 05       	cpc	r19, r1
    5634:	31 f0       	breq	.+12     	; 0x5642 <LCD_voidGoTo+0x46>
    5636:	09 c0       	rjmp	.+18     	; 0x564a <LCD_voidGoTo+0x4e>
	    {
		    case 1:
		    	LCD_voidSendCommand(Cpy_column+127);
    5638:	8a 81       	ldd	r24, Y+2	; 0x02
    563a:	81 58       	subi	r24, 0x81	; 129
    563c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
    5640:	04 c0       	rjmp	.+8      	; 0x564a <LCD_voidGoTo+0x4e>
		    break;

		    case 2:
		    	LCD_voidSendCommand(Cpy_column+191);
    5642:	8a 81       	ldd	r24, Y+2	; 0x02
    5644:	81 54       	subi	r24, 0x41	; 65
    5646:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>

		    default:
		    break;
	    }
	}
}
    564a:	0f 90       	pop	r0
    564c:	0f 90       	pop	r0
    564e:	0f 90       	pop	r0
    5650:	0f 90       	pop	r0
    5652:	cf 91       	pop	r28
    5654:	df 91       	pop	r29
    5656:	08 95       	ret

00005658 <LCD_voidAddNewPattern>:

void LCD_voidAddNewPattern (u8 *Cpy_patternArray , u8 Cpy_blockNumber)
{
    5658:	df 93       	push	r29
    565a:	cf 93       	push	r28
    565c:	00 d0       	rcall	.+0      	; 0x565e <LCD_voidAddNewPattern+0x6>
    565e:	00 d0       	rcall	.+0      	; 0x5660 <LCD_voidAddNewPattern+0x8>
    5660:	0f 92       	push	r0
    5662:	cd b7       	in	r28, 0x3d	; 61
    5664:	de b7       	in	r29, 0x3e	; 62
    5666:	9c 83       	std	Y+4, r25	; 0x04
    5668:	8b 83       	std	Y+3, r24	; 0x03
    566a:	6d 83       	std	Y+5, r22	; 0x05
	u8 local_CGAdress = Cpy_blockNumber*LCD_CGRAM_BLOCKS_SIZE + LCD_CGRAM_START ;
    566c:	8d 81       	ldd	r24, Y+5	; 0x05
    566e:	88 2f       	mov	r24, r24
    5670:	90 e0       	ldi	r25, 0x00	; 0
    5672:	08 96       	adiw	r24, 0x08	; 8
    5674:	88 0f       	add	r24, r24
    5676:	99 1f       	adc	r25, r25
    5678:	88 0f       	add	r24, r24
    567a:	99 1f       	adc	r25, r25
    567c:	88 0f       	add	r24, r24
    567e:	99 1f       	adc	r25, r25
    5680:	8a 83       	std	Y+2, r24	; 0x02
	if (Cpy_blockNumber < LCD_CGRAM_BLOCKS_NUMBER)
    5682:	8d 81       	ldd	r24, Y+5	; 0x05
    5684:	88 30       	cpi	r24, 0x08	; 8
    5686:	b0 f4       	brcc	.+44     	; 0x56b4 <LCD_voidAddNewPattern+0x5c>
	{
		LCD_voidSendCommand(local_CGAdress);
    5688:	8a 81       	ldd	r24, Y+2	; 0x02
    568a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <LCD_voidSendCommand>
		for (u8 i = 0 ; i < LCD_CGRAM_BLOCKS_SIZE ; i++)
    568e:	19 82       	std	Y+1, r1	; 0x01
    5690:	0e c0       	rjmp	.+28     	; 0x56ae <LCD_voidAddNewPattern+0x56>
		{
			LCD_voidSendChar(Cpy_patternArray[i]);
    5692:	89 81       	ldd	r24, Y+1	; 0x01
    5694:	28 2f       	mov	r18, r24
    5696:	30 e0       	ldi	r19, 0x00	; 0
    5698:	8b 81       	ldd	r24, Y+3	; 0x03
    569a:	9c 81       	ldd	r25, Y+4	; 0x04
    569c:	fc 01       	movw	r30, r24
    569e:	e2 0f       	add	r30, r18
    56a0:	f3 1f       	adc	r31, r19
    56a2:	80 81       	ld	r24, Z
    56a4:	0e 94 3a 29 	call	0x5274	; 0x5274 <LCD_voidSendChar>
{
	u8 local_CGAdress = Cpy_blockNumber*LCD_CGRAM_BLOCKS_SIZE + LCD_CGRAM_START ;
	if (Cpy_blockNumber < LCD_CGRAM_BLOCKS_NUMBER)
	{
		LCD_voidSendCommand(local_CGAdress);
		for (u8 i = 0 ; i < LCD_CGRAM_BLOCKS_SIZE ; i++)
    56a8:	89 81       	ldd	r24, Y+1	; 0x01
    56aa:	8f 5f       	subi	r24, 0xFF	; 255
    56ac:	89 83       	std	Y+1, r24	; 0x01
    56ae:	89 81       	ldd	r24, Y+1	; 0x01
    56b0:	88 30       	cpi	r24, 0x08	; 8
    56b2:	78 f3       	brcs	.-34     	; 0x5692 <LCD_voidAddNewPattern+0x3a>
	}
	else
	{
		/* Error */
	}
}
    56b4:	0f 90       	pop	r0
    56b6:	0f 90       	pop	r0
    56b8:	0f 90       	pop	r0
    56ba:	0f 90       	pop	r0
    56bc:	0f 90       	pop	r0
    56be:	cf 91       	pop	r28
    56c0:	df 91       	pop	r29
    56c2:	08 95       	ret

000056c4 <LCD_voidWritePattern>:

void LCD_voidWritePattern (u8 Cpy_blockNumber , u8 Cpy_row , u8 Cpy_column)
{
    56c4:	df 93       	push	r29
    56c6:	cf 93       	push	r28
    56c8:	00 d0       	rcall	.+0      	; 0x56ca <LCD_voidWritePattern+0x6>
    56ca:	0f 92       	push	r0
    56cc:	cd b7       	in	r28, 0x3d	; 61
    56ce:	de b7       	in	r29, 0x3e	; 62
    56d0:	89 83       	std	Y+1, r24	; 0x01
    56d2:	6a 83       	std	Y+2, r22	; 0x02
    56d4:	4b 83       	std	Y+3, r20	; 0x03
	if (Cpy_blockNumber < LCD_CGRAM_BLOCKS_NUMBER)
    56d6:	89 81       	ldd	r24, Y+1	; 0x01
    56d8:	88 30       	cpi	r24, 0x08	; 8
    56da:	38 f4       	brcc	.+14     	; 0x56ea <LCD_voidWritePattern+0x26>
	{
		LCD_voidGoTo(Cpy_row , Cpy_column);
    56dc:	8a 81       	ldd	r24, Y+2	; 0x02
    56de:	6b 81       	ldd	r22, Y+3	; 0x03
    56e0:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <LCD_voidGoTo>
		LCD_voidSendChar(Cpy_blockNumber);
    56e4:	89 81       	ldd	r24, Y+1	; 0x01
    56e6:	0e 94 3a 29 	call	0x5274	; 0x5274 <LCD_voidSendChar>
	}
	else
	{
		/* Error */
	}
}
    56ea:	0f 90       	pop	r0
    56ec:	0f 90       	pop	r0
    56ee:	0f 90       	pop	r0
    56f0:	cf 91       	pop	r28
    56f2:	df 91       	pop	r29
    56f4:	08 95       	ret

000056f6 <main>:

/* Global variables */
xQueueHandle  lcd_Queue;

void main ()
{
    56f6:	ef 92       	push	r14
    56f8:	ff 92       	push	r15
    56fa:	0f 93       	push	r16
    56fc:	df 93       	push	r29
    56fe:	cf 93       	push	r28
    5700:	cd b7       	in	r28, 0x3d	; 61
    5702:	de b7       	in	r29, 0x3e	; 62
	/* Initialize the Pins */
	GPIO_voidSetPinDirection(PORT_A , PIN0 , OUTPUT);
    5704:	80 e0       	ldi	r24, 0x00	; 0
    5706:	60 e0       	ldi	r22, 0x00	; 0
    5708:	41 e0       	ldi	r20, 0x01	; 1
    570a:	0e 94 37 22 	call	0x446e	; 0x446e <GPIO_voidSetPinDirection>
	GPIO_voidSetPinDirection(PORT_A ,PIN1 , OUTPUT );
    570e:	80 e0       	ldi	r24, 0x00	; 0
    5710:	61 e0       	ldi	r22, 0x01	; 1
    5712:	41 e0       	ldi	r20, 0x01	; 1
    5714:	0e 94 37 22 	call	0x446e	; 0x446e <GPIO_voidSetPinDirection>
	GPIO_voidSetPinDirection(PORT_A ,PIN2 , OUTPUT );
    5718:	80 e0       	ldi	r24, 0x00	; 0
    571a:	62 e0       	ldi	r22, 0x02	; 2
    571c:	41 e0       	ldi	r20, 0x01	; 1
    571e:	0e 94 37 22 	call	0x446e	; 0x446e <GPIO_voidSetPinDirection>
	GPIO_voidSetPortDirection(PORT_D , OUTPUT);
    5722:	83 e0       	ldi	r24, 0x03	; 3
    5724:	61 e0       	ldi	r22, 0x01	; 1
    5726:	0e 94 78 23 	call	0x46f0	; 0x46f0 <GPIO_voidSetPortDirection>

	/* Init Modules */
	LCD_voidInit();
    572a:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <LCD_voidInit>

	/* Create Queue */
	lcd_Queue = xQueueCreate(5 , sizeof(u8));
    572e:	85 e0       	ldi	r24, 0x05	; 5
    5730:	61 e0       	ldi	r22, 0x01	; 1
    5732:	40 e0       	ldi	r20, 0x00	; 0
    5734:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <xQueueGenericCreate>
    5738:	90 93 cb 04 	sts	0x04CB, r25
    573c:	80 93 ca 04 	sts	0x04CA, r24

	/* Create tasks */
	xTaskCreate(Task1 ,NULL , 200 , NULL , 2 , NULL );
    5740:	8d eb       	ldi	r24, 0xBD	; 189
    5742:	9b e2       	ldi	r25, 0x2B	; 43
    5744:	60 e0       	ldi	r22, 0x00	; 0
    5746:	70 e0       	ldi	r23, 0x00	; 0
    5748:	48 ec       	ldi	r20, 0xC8	; 200
    574a:	50 e0       	ldi	r21, 0x00	; 0
    574c:	20 e0       	ldi	r18, 0x00	; 0
    574e:	30 e0       	ldi	r19, 0x00	; 0
    5750:	02 e0       	ldi	r16, 0x02	; 2
    5752:	ee 24       	eor	r14, r14
    5754:	ff 24       	eor	r15, r15
    5756:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskCreate>
	xTaskCreate(Task2 ,NULL , 200 , NULL , 2 , NULL );
    575a:	89 ee       	ldi	r24, 0xE9	; 233
    575c:	9b e2       	ldi	r25, 0x2B	; 43
    575e:	60 e0       	ldi	r22, 0x00	; 0
    5760:	70 e0       	ldi	r23, 0x00	; 0
    5762:	48 ec       	ldi	r20, 0xC8	; 200
    5764:	50 e0       	ldi	r21, 0x00	; 0
    5766:	20 e0       	ldi	r18, 0x00	; 0
    5768:	30 e0       	ldi	r19, 0x00	; 0
    576a:	02 e0       	ldi	r16, 0x02	; 2
    576c:	ee 24       	eor	r14, r14
    576e:	ff 24       	eor	r15, r15
    5770:	0e 94 15 12 	call	0x242a	; 0x242a <xTaskCreate>

	/* Start scheduler */
	vTaskStartScheduler();
    5774:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <vTaskStartScheduler>
    5778:	ff cf       	rjmp	.-2      	; 0x5778 <main+0x82>

0000577a <Task1>:
	}

}

void Task1 (void *p)
{
    577a:	df 93       	push	r29
    577c:	cf 93       	push	r28
    577e:	00 d0       	rcall	.+0      	; 0x5780 <Task1+0x6>
    5780:	0f 92       	push	r0
    5782:	cd b7       	in	r28, 0x3d	; 61
    5784:	de b7       	in	r29, 0x3e	; 62
    5786:	9b 83       	std	Y+3, r25	; 0x03
    5788:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 'a' ;
    578a:	81 e6       	ldi	r24, 0x61	; 97
    578c:	89 83       	std	Y+1, r24	; 0x01
	while (1)
	{
		xQueueSendToBack(lcd_Queue , &state , 0);
    578e:	80 91 ca 04 	lds	r24, 0x04CA
    5792:	90 91 cb 04 	lds	r25, 0x04CB
    5796:	9e 01       	movw	r18, r28
    5798:	2f 5f       	subi	r18, 0xFF	; 255
    579a:	3f 4f       	sbci	r19, 0xFF	; 255
    579c:	b9 01       	movw	r22, r18
    579e:	40 e0       	ldi	r20, 0x00	; 0
    57a0:	50 e0       	ldi	r21, 0x00	; 0
    57a2:	20 e0       	ldi	r18, 0x00	; 0
    57a4:	0e 94 01 0c 	call	0x1802	; 0x1802 <xQueueGenericSend>
		state++;
    57a8:	89 81       	ldd	r24, Y+1	; 0x01
    57aa:	8f 5f       	subi	r24, 0xFF	; 255
    57ac:	89 83       	std	Y+1, r24	; 0x01
		xQueueSendToBack(lcd_Queue , &state , 0);
    57ae:	80 91 ca 04 	lds	r24, 0x04CA
    57b2:	90 91 cb 04 	lds	r25, 0x04CB
    57b6:	9e 01       	movw	r18, r28
    57b8:	2f 5f       	subi	r18, 0xFF	; 255
    57ba:	3f 4f       	sbci	r19, 0xFF	; 255
    57bc:	b9 01       	movw	r22, r18
    57be:	40 e0       	ldi	r20, 0x00	; 0
    57c0:	50 e0       	ldi	r21, 0x00	; 0
    57c2:	20 e0       	ldi	r18, 0x00	; 0
    57c4:	0e 94 01 0c 	call	0x1802	; 0x1802 <xQueueGenericSend>
		vTaskDelay(1000);
    57c8:	88 ee       	ldi	r24, 0xE8	; 232
    57ca:	93 e0       	ldi	r25, 0x03	; 3
    57cc:	0e 94 a5 14 	call	0x294a	; 0x294a <vTaskDelay>
    57d0:	de cf       	rjmp	.-68     	; 0x578e <Task1+0x14>

000057d2 <Task2>:

	}
}

void Task2 (void *p)
{
    57d2:	df 93       	push	r29
    57d4:	cf 93       	push	r28
    57d6:	00 d0       	rcall	.+0      	; 0x57d8 <Task2+0x6>
    57d8:	00 d0       	rcall	.+0      	; 0x57da <Task2+0x8>
    57da:	cd b7       	in	r28, 0x3d	; 61
    57dc:	de b7       	in	r29, 0x3e	; 62
    57de:	9c 83       	std	Y+4, r25	; 0x04
    57e0:	8b 83       	std	Y+3, r24	; 0x03
	u8 state , val;
	while (1)
	{
		state = xQueueReceive(lcd_Queue , &val ,0);
    57e2:	80 91 ca 04 	lds	r24, 0x04CA
    57e6:	90 91 cb 04 	lds	r25, 0x04CB
    57ea:	9e 01       	movw	r18, r28
    57ec:	2e 5f       	subi	r18, 0xFE	; 254
    57ee:	3f 4f       	sbci	r19, 0xFF	; 255
    57f0:	b9 01       	movw	r22, r18
    57f2:	40 e0       	ldi	r20, 0x00	; 0
    57f4:	50 e0       	ldi	r21, 0x00	; 0
    57f6:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <xQueueReceive>
    57fa:	89 83       	std	Y+1, r24	; 0x01
		if (state == pdPASS)
    57fc:	89 81       	ldd	r24, Y+1	; 0x01
    57fe:	81 30       	cpi	r24, 0x01	; 1
    5800:	81 f7       	brne	.-32     	; 0x57e2 <Task2+0x10>
		{
			LCD_voidSendChar(val);
    5802:	8a 81       	ldd	r24, Y+2	; 0x02
    5804:	0e 94 3a 29 	call	0x5274	; 0x5274 <LCD_voidSendChar>
    5808:	ec cf       	rjmp	.-40     	; 0x57e2 <Task2+0x10>

0000580a <__prologue_saves__>:
    580a:	2f 92       	push	r2
    580c:	3f 92       	push	r3
    580e:	4f 92       	push	r4
    5810:	5f 92       	push	r5
    5812:	6f 92       	push	r6
    5814:	7f 92       	push	r7
    5816:	8f 92       	push	r8
    5818:	9f 92       	push	r9
    581a:	af 92       	push	r10
    581c:	bf 92       	push	r11
    581e:	cf 92       	push	r12
    5820:	df 92       	push	r13
    5822:	ef 92       	push	r14
    5824:	ff 92       	push	r15
    5826:	0f 93       	push	r16
    5828:	1f 93       	push	r17
    582a:	cf 93       	push	r28
    582c:	df 93       	push	r29
    582e:	cd b7       	in	r28, 0x3d	; 61
    5830:	de b7       	in	r29, 0x3e	; 62
    5832:	ca 1b       	sub	r28, r26
    5834:	db 0b       	sbc	r29, r27
    5836:	0f b6       	in	r0, 0x3f	; 63
    5838:	f8 94       	cli
    583a:	de bf       	out	0x3e, r29	; 62
    583c:	0f be       	out	0x3f, r0	; 63
    583e:	cd bf       	out	0x3d, r28	; 61
    5840:	09 94       	ijmp

00005842 <__epilogue_restores__>:
    5842:	2a 88       	ldd	r2, Y+18	; 0x12
    5844:	39 88       	ldd	r3, Y+17	; 0x11
    5846:	48 88       	ldd	r4, Y+16	; 0x10
    5848:	5f 84       	ldd	r5, Y+15	; 0x0f
    584a:	6e 84       	ldd	r6, Y+14	; 0x0e
    584c:	7d 84       	ldd	r7, Y+13	; 0x0d
    584e:	8c 84       	ldd	r8, Y+12	; 0x0c
    5850:	9b 84       	ldd	r9, Y+11	; 0x0b
    5852:	aa 84       	ldd	r10, Y+10	; 0x0a
    5854:	b9 84       	ldd	r11, Y+9	; 0x09
    5856:	c8 84       	ldd	r12, Y+8	; 0x08
    5858:	df 80       	ldd	r13, Y+7	; 0x07
    585a:	ee 80       	ldd	r14, Y+6	; 0x06
    585c:	fd 80       	ldd	r15, Y+5	; 0x05
    585e:	0c 81       	ldd	r16, Y+4	; 0x04
    5860:	1b 81       	ldd	r17, Y+3	; 0x03
    5862:	aa 81       	ldd	r26, Y+2	; 0x02
    5864:	b9 81       	ldd	r27, Y+1	; 0x01
    5866:	ce 0f       	add	r28, r30
    5868:	d1 1d       	adc	r29, r1
    586a:	0f b6       	in	r0, 0x3f	; 63
    586c:	f8 94       	cli
    586e:	de bf       	out	0x3e, r29	; 62
    5870:	0f be       	out	0x3f, r0	; 63
    5872:	cd bf       	out	0x3d, r28	; 61
    5874:	ed 01       	movw	r28, r26
    5876:	08 95       	ret

00005878 <memcpy>:
    5878:	fb 01       	movw	r30, r22
    587a:	dc 01       	movw	r26, r24
    587c:	02 c0       	rjmp	.+4      	; 0x5882 <memcpy+0xa>
    587e:	01 90       	ld	r0, Z+
    5880:	0d 92       	st	X+, r0
    5882:	41 50       	subi	r20, 0x01	; 1
    5884:	50 40       	sbci	r21, 0x00	; 0
    5886:	d8 f7       	brcc	.-10     	; 0x587e <memcpy+0x6>
    5888:	08 95       	ret

0000588a <_exit>:
    588a:	f8 94       	cli

0000588c <__stop_program>:
    588c:	ff cf       	rjmp	.-2      	; 0x588c <__stop_program>
