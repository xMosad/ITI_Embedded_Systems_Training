
33-FreeRTOS_Task.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003dfa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00003dfa  00003e8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045c  00800066  00800066  00003e94  2**0
                  ALLOC
  3 .stab         000062c4  00000000  00000000  00003e94  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003e53  00000000  00000000  0000a158  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 cc 04 	jmp	0x998	; 0x998 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ef       	ldi	r30, 0xFA	; 250
      68:	fd e3       	ldi	r31, 0x3D	; 61
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 36       	cpi	r26, 0x66	; 102
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a6 e6       	ldi	r26, 0x66	; 102
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 3c       	cpi	r26, 0xC2	; 194
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <main>
      8a:	0c 94 fb 1e 	jmp	0x3df6	; 0x3df6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
      a6:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
      aa:	80 91 68 00 	lds	r24, 0x0068
      ae:	90 91 69 00 	lds	r25, 0x0069
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
      b6:	8b e6       	ldi	r24, 0x6B	; 107
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 69 00 	sts	0x0069, r25
      be:	80 93 68 00 	sts	0x0068, r24
      c2:	80 91 66 00 	lds	r24, 0x0066
      c6:	90 91 67 00 	lds	r25, 0x0067
      ca:	2b 81       	ldd	r18, Y+3	; 0x03
      cc:	3c 81       	ldd	r19, Y+4	; 0x04
      ce:	82 0f       	add	r24, r18
      d0:	93 1f       	adc	r25, r19
      d2:	23 e0       	ldi	r18, 0x03	; 3
      d4:	87 3e       	cpi	r24, 0xE7	; 231
      d6:	92 07       	cpc	r25, r18
      d8:	38 f5       	brcc	.+78     	; 0x128 <pvPortMalloc+0x96>
      da:	20 91 66 00 	lds	r18, 0x0066
      de:	30 91 67 00 	lds	r19, 0x0067
      e2:	8b 81       	ldd	r24, Y+3	; 0x03
      e4:	9c 81       	ldd	r25, Y+4	; 0x04
      e6:	28 0f       	add	r18, r24
      e8:	39 1f       	adc	r19, r25
      ea:	80 91 66 00 	lds	r24, 0x0066
      ee:	90 91 67 00 	lds	r25, 0x0067
      f2:	82 17       	cp	r24, r18
      f4:	93 07       	cpc	r25, r19
      f6:	c0 f4       	brcc	.+48     	; 0x128 <pvPortMalloc+0x96>
      f8:	20 91 68 00 	lds	r18, 0x0068
      fc:	30 91 69 00 	lds	r19, 0x0069
     100:	80 91 66 00 	lds	r24, 0x0066
     104:	90 91 67 00 	lds	r25, 0x0067
     108:	82 0f       	add	r24, r18
     10a:	93 1f       	adc	r25, r19
     10c:	9a 83       	std	Y+2, r25	; 0x02
     10e:	89 83       	std	Y+1, r24	; 0x01
     110:	20 91 66 00 	lds	r18, 0x0066
     114:	30 91 67 00 	lds	r19, 0x0067
     118:	8b 81       	ldd	r24, Y+3	; 0x03
     11a:	9c 81       	ldd	r25, Y+4	; 0x04
     11c:	82 0f       	add	r24, r18
     11e:	93 1f       	adc	r25, r19
     120:	90 93 67 00 	sts	0x0067, r25
     124:	80 93 66 00 	sts	0x0066, r24
     128:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	0f 90       	pop	r0
     132:	0f 90       	pop	r0
     134:	0f 90       	pop	r0
     136:	0f 90       	pop	r0
     138:	cf 91       	pop	r28
     13a:	df 91       	pop	r29
     13c:	08 95       	ret

0000013e <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     13e:	df 93       	push	r29
     140:	cf 93       	push	r28
     142:	00 d0       	rcall	.+0      	; 0x144 <vPortFree+0x6>
     144:	cd b7       	in	r28, 0x3d	; 61
     146:	de b7       	in	r29, 0x3e	; 62
     148:	9a 83       	std	Y+2, r25	; 0x02
     14a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     14c:	0f 90       	pop	r0
     14e:	0f 90       	pop	r0
     150:	cf 91       	pop	r28
     152:	df 91       	pop	r29
     154:	08 95       	ret

00000156 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     156:	df 93       	push	r29
     158:	cf 93       	push	r28
     15a:	cd b7       	in	r28, 0x3d	; 61
     15c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     15e:	10 92 67 00 	sts	0x0067, r1
     162:	10 92 66 00 	sts	0x0066, r1
}
     166:	cf 91       	pop	r28
     168:	df 91       	pop	r29
     16a:	08 95       	ret

0000016c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     16c:	df 93       	push	r29
     16e:	cf 93       	push	r28
     170:	cd b7       	in	r28, 0x3d	; 61
     172:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     174:	20 91 66 00 	lds	r18, 0x0066
     178:	30 91 67 00 	lds	r19, 0x0067
     17c:	87 ee       	ldi	r24, 0xE7	; 231
     17e:	93 e0       	ldi	r25, 0x03	; 3
     180:	82 1b       	sub	r24, r18
     182:	93 0b       	sbc	r25, r19
}
     184:	cf 91       	pop	r28
     186:	df 91       	pop	r29
     188:	08 95       	ret

0000018a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     18a:	df 93       	push	r29
     18c:	cf 93       	push	r28
     18e:	00 d0       	rcall	.+0      	; 0x190 <vListInitialise+0x6>
     190:	cd b7       	in	r28, 0x3d	; 61
     192:	de b7       	in	r29, 0x3e	; 62
     194:	9a 83       	std	Y+2, r25	; 0x02
     196:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     198:	89 81       	ldd	r24, Y+1	; 0x01
     19a:	9a 81       	ldd	r25, Y+2	; 0x02
     19c:	03 96       	adiw	r24, 0x03	; 3
     19e:	e9 81       	ldd	r30, Y+1	; 0x01
     1a0:	fa 81       	ldd	r31, Y+2	; 0x02
     1a2:	92 83       	std	Z+2, r25	; 0x02
     1a4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     1a6:	e9 81       	ldd	r30, Y+1	; 0x01
     1a8:	fa 81       	ldd	r31, Y+2	; 0x02
     1aa:	8f ef       	ldi	r24, 0xFF	; 255
     1ac:	9f ef       	ldi	r25, 0xFF	; 255
     1ae:	94 83       	std	Z+4, r25	; 0x04
     1b0:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b2:	89 81       	ldd	r24, Y+1	; 0x01
     1b4:	9a 81       	ldd	r25, Y+2	; 0x02
     1b6:	03 96       	adiw	r24, 0x03	; 3
     1b8:	e9 81       	ldd	r30, Y+1	; 0x01
     1ba:	fa 81       	ldd	r31, Y+2	; 0x02
     1bc:	96 83       	std	Z+6, r25	; 0x06
     1be:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	9a 81       	ldd	r25, Y+2	; 0x02
     1c4:	03 96       	adiw	r24, 0x03	; 3
     1c6:	e9 81       	ldd	r30, Y+1	; 0x01
     1c8:	fa 81       	ldd	r31, Y+2	; 0x02
     1ca:	90 87       	std	Z+8, r25	; 0x08
     1cc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1ce:	e9 81       	ldd	r30, Y+1	; 0x01
     1d0:	fa 81       	ldd	r31, Y+2	; 0x02
     1d2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     1d4:	0f 90       	pop	r0
     1d6:	0f 90       	pop	r0
     1d8:	cf 91       	pop	r28
     1da:	df 91       	pop	r29
     1dc:	08 95       	ret

000001de <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     1de:	df 93       	push	r29
     1e0:	cf 93       	push	r28
     1e2:	00 d0       	rcall	.+0      	; 0x1e4 <vListInitialiseItem+0x6>
     1e4:	cd b7       	in	r28, 0x3d	; 61
     1e6:	de b7       	in	r29, 0x3e	; 62
     1e8:	9a 83       	std	Y+2, r25	; 0x02
     1ea:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     1ec:	e9 81       	ldd	r30, Y+1	; 0x01
     1ee:	fa 81       	ldd	r31, Y+2	; 0x02
     1f0:	11 86       	std	Z+9, r1	; 0x09
     1f2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     1f4:	0f 90       	pop	r0
     1f6:	0f 90       	pop	r0
     1f8:	cf 91       	pop	r28
     1fa:	df 91       	pop	r29
     1fc:	08 95       	ret

000001fe <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1fe:	df 93       	push	r29
     200:	cf 93       	push	r28
     202:	00 d0       	rcall	.+0      	; 0x204 <vListInsertEnd+0x6>
     204:	00 d0       	rcall	.+0      	; 0x206 <vListInsertEnd+0x8>
     206:	00 d0       	rcall	.+0      	; 0x208 <vListInsertEnd+0xa>
     208:	cd b7       	in	r28, 0x3d	; 61
     20a:	de b7       	in	r29, 0x3e	; 62
     20c:	9c 83       	std	Y+4, r25	; 0x04
     20e:	8b 83       	std	Y+3, r24	; 0x03
     210:	7e 83       	std	Y+6, r23	; 0x06
     212:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     214:	eb 81       	ldd	r30, Y+3	; 0x03
     216:	fc 81       	ldd	r31, Y+4	; 0x04
     218:	81 81       	ldd	r24, Z+1	; 0x01
     21a:	92 81       	ldd	r25, Z+2	; 0x02
     21c:	9a 83       	std	Y+2, r25	; 0x02
     21e:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     220:	ed 81       	ldd	r30, Y+5	; 0x05
     222:	fe 81       	ldd	r31, Y+6	; 0x06
     224:	89 81       	ldd	r24, Y+1	; 0x01
     226:	9a 81       	ldd	r25, Y+2	; 0x02
     228:	93 83       	std	Z+3, r25	; 0x03
     22a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     22c:	e9 81       	ldd	r30, Y+1	; 0x01
     22e:	fa 81       	ldd	r31, Y+2	; 0x02
     230:	84 81       	ldd	r24, Z+4	; 0x04
     232:	95 81       	ldd	r25, Z+5	; 0x05
     234:	ed 81       	ldd	r30, Y+5	; 0x05
     236:	fe 81       	ldd	r31, Y+6	; 0x06
     238:	95 83       	std	Z+5, r25	; 0x05
     23a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     23c:	e9 81       	ldd	r30, Y+1	; 0x01
     23e:	fa 81       	ldd	r31, Y+2	; 0x02
     240:	04 80       	ldd	r0, Z+4	; 0x04
     242:	f5 81       	ldd	r31, Z+5	; 0x05
     244:	e0 2d       	mov	r30, r0
     246:	8d 81       	ldd	r24, Y+5	; 0x05
     248:	9e 81       	ldd	r25, Y+6	; 0x06
     24a:	93 83       	std	Z+3, r25	; 0x03
     24c:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     24e:	e9 81       	ldd	r30, Y+1	; 0x01
     250:	fa 81       	ldd	r31, Y+2	; 0x02
     252:	8d 81       	ldd	r24, Y+5	; 0x05
     254:	9e 81       	ldd	r25, Y+6	; 0x06
     256:	95 83       	std	Z+5, r25	; 0x05
     258:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     25a:	ed 81       	ldd	r30, Y+5	; 0x05
     25c:	fe 81       	ldd	r31, Y+6	; 0x06
     25e:	8b 81       	ldd	r24, Y+3	; 0x03
     260:	9c 81       	ldd	r25, Y+4	; 0x04
     262:	91 87       	std	Z+9, r25	; 0x09
     264:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     266:	eb 81       	ldd	r30, Y+3	; 0x03
     268:	fc 81       	ldd	r31, Y+4	; 0x04
     26a:	80 81       	ld	r24, Z
     26c:	8f 5f       	subi	r24, 0xFF	; 255
     26e:	eb 81       	ldd	r30, Y+3	; 0x03
     270:	fc 81       	ldd	r31, Y+4	; 0x04
     272:	80 83       	st	Z, r24
}
     274:	26 96       	adiw	r28, 0x06	; 6
     276:	0f b6       	in	r0, 0x3f	; 63
     278:	f8 94       	cli
     27a:	de bf       	out	0x3e, r29	; 62
     27c:	0f be       	out	0x3f, r0	; 63
     27e:	cd bf       	out	0x3d, r28	; 61
     280:	cf 91       	pop	r28
     282:	df 91       	pop	r29
     284:	08 95       	ret

00000286 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     286:	df 93       	push	r29
     288:	cf 93       	push	r28
     28a:	cd b7       	in	r28, 0x3d	; 61
     28c:	de b7       	in	r29, 0x3e	; 62
     28e:	28 97       	sbiw	r28, 0x08	; 8
     290:	0f b6       	in	r0, 0x3f	; 63
     292:	f8 94       	cli
     294:	de bf       	out	0x3e, r29	; 62
     296:	0f be       	out	0x3f, r0	; 63
     298:	cd bf       	out	0x3d, r28	; 61
     29a:	9e 83       	std	Y+6, r25	; 0x06
     29c:	8d 83       	std	Y+5, r24	; 0x05
     29e:	78 87       	std	Y+8, r23	; 0x08
     2a0:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2a2:	ef 81       	ldd	r30, Y+7	; 0x07
     2a4:	f8 85       	ldd	r31, Y+8	; 0x08
     2a6:	80 81       	ld	r24, Z
     2a8:	91 81       	ldd	r25, Z+1	; 0x01
     2aa:	9a 83       	std	Y+2, r25	; 0x02
     2ac:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	9a 81       	ldd	r25, Y+2	; 0x02
     2b2:	2f ef       	ldi	r18, 0xFF	; 255
     2b4:	8f 3f       	cpi	r24, 0xFF	; 255
     2b6:	92 07       	cpc	r25, r18
     2b8:	39 f4       	brne	.+14     	; 0x2c8 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2ba:	ed 81       	ldd	r30, Y+5	; 0x05
     2bc:	fe 81       	ldd	r31, Y+6	; 0x06
     2be:	87 81       	ldd	r24, Z+7	; 0x07
     2c0:	90 85       	ldd	r25, Z+8	; 0x08
     2c2:	9c 83       	std	Y+4, r25	; 0x04
     2c4:	8b 83       	std	Y+3, r24	; 0x03
     2c6:	18 c0       	rjmp	.+48     	; 0x2f8 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     2c8:	8d 81       	ldd	r24, Y+5	; 0x05
     2ca:	9e 81       	ldd	r25, Y+6	; 0x06
     2cc:	03 96       	adiw	r24, 0x03	; 3
     2ce:	9c 83       	std	Y+4, r25	; 0x04
     2d0:	8b 83       	std	Y+3, r24	; 0x03
     2d2:	06 c0       	rjmp	.+12     	; 0x2e0 <vListInsert+0x5a>
     2d4:	eb 81       	ldd	r30, Y+3	; 0x03
     2d6:	fc 81       	ldd	r31, Y+4	; 0x04
     2d8:	82 81       	ldd	r24, Z+2	; 0x02
     2da:	93 81       	ldd	r25, Z+3	; 0x03
     2dc:	9c 83       	std	Y+4, r25	; 0x04
     2de:	8b 83       	std	Y+3, r24	; 0x03
     2e0:	eb 81       	ldd	r30, Y+3	; 0x03
     2e2:	fc 81       	ldd	r31, Y+4	; 0x04
     2e4:	02 80       	ldd	r0, Z+2	; 0x02
     2e6:	f3 81       	ldd	r31, Z+3	; 0x03
     2e8:	e0 2d       	mov	r30, r0
     2ea:	20 81       	ld	r18, Z
     2ec:	31 81       	ldd	r19, Z+1	; 0x01
     2ee:	89 81       	ldd	r24, Y+1	; 0x01
     2f0:	9a 81       	ldd	r25, Y+2	; 0x02
     2f2:	82 17       	cp	r24, r18
     2f4:	93 07       	cpc	r25, r19
     2f6:	70 f7       	brcc	.-36     	; 0x2d4 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2f8:	eb 81       	ldd	r30, Y+3	; 0x03
     2fa:	fc 81       	ldd	r31, Y+4	; 0x04
     2fc:	82 81       	ldd	r24, Z+2	; 0x02
     2fe:	93 81       	ldd	r25, Z+3	; 0x03
     300:	ef 81       	ldd	r30, Y+7	; 0x07
     302:	f8 85       	ldd	r31, Y+8	; 0x08
     304:	93 83       	std	Z+3, r25	; 0x03
     306:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     308:	ef 81       	ldd	r30, Y+7	; 0x07
     30a:	f8 85       	ldd	r31, Y+8	; 0x08
     30c:	02 80       	ldd	r0, Z+2	; 0x02
     30e:	f3 81       	ldd	r31, Z+3	; 0x03
     310:	e0 2d       	mov	r30, r0
     312:	8f 81       	ldd	r24, Y+7	; 0x07
     314:	98 85       	ldd	r25, Y+8	; 0x08
     316:	95 83       	std	Z+5, r25	; 0x05
     318:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     31a:	ef 81       	ldd	r30, Y+7	; 0x07
     31c:	f8 85       	ldd	r31, Y+8	; 0x08
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	9c 81       	ldd	r25, Y+4	; 0x04
     322:	95 83       	std	Z+5, r25	; 0x05
     324:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     326:	eb 81       	ldd	r30, Y+3	; 0x03
     328:	fc 81       	ldd	r31, Y+4	; 0x04
     32a:	8f 81       	ldd	r24, Y+7	; 0x07
     32c:	98 85       	ldd	r25, Y+8	; 0x08
     32e:	93 83       	std	Z+3, r25	; 0x03
     330:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     332:	ef 81       	ldd	r30, Y+7	; 0x07
     334:	f8 85       	ldd	r31, Y+8	; 0x08
     336:	8d 81       	ldd	r24, Y+5	; 0x05
     338:	9e 81       	ldd	r25, Y+6	; 0x06
     33a:	91 87       	std	Z+9, r25	; 0x09
     33c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     33e:	ed 81       	ldd	r30, Y+5	; 0x05
     340:	fe 81       	ldd	r31, Y+6	; 0x06
     342:	80 81       	ld	r24, Z
     344:	8f 5f       	subi	r24, 0xFF	; 255
     346:	ed 81       	ldd	r30, Y+5	; 0x05
     348:	fe 81       	ldd	r31, Y+6	; 0x06
     34a:	80 83       	st	Z, r24
}
     34c:	28 96       	adiw	r28, 0x08	; 8
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	cf 91       	pop	r28
     35a:	df 91       	pop	r29
     35c:	08 95       	ret

0000035e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     35e:	df 93       	push	r29
     360:	cf 93       	push	r28
     362:	00 d0       	rcall	.+0      	; 0x364 <uxListRemove+0x6>
     364:	00 d0       	rcall	.+0      	; 0x366 <uxListRemove+0x8>
     366:	cd b7       	in	r28, 0x3d	; 61
     368:	de b7       	in	r29, 0x3e	; 62
     36a:	9c 83       	std	Y+4, r25	; 0x04
     36c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     36e:	eb 81       	ldd	r30, Y+3	; 0x03
     370:	fc 81       	ldd	r31, Y+4	; 0x04
     372:	80 85       	ldd	r24, Z+8	; 0x08
     374:	91 85       	ldd	r25, Z+9	; 0x09
     376:	9a 83       	std	Y+2, r25	; 0x02
     378:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     37a:	eb 81       	ldd	r30, Y+3	; 0x03
     37c:	fc 81       	ldd	r31, Y+4	; 0x04
     37e:	a2 81       	ldd	r26, Z+2	; 0x02
     380:	b3 81       	ldd	r27, Z+3	; 0x03
     382:	eb 81       	ldd	r30, Y+3	; 0x03
     384:	fc 81       	ldd	r31, Y+4	; 0x04
     386:	84 81       	ldd	r24, Z+4	; 0x04
     388:	95 81       	ldd	r25, Z+5	; 0x05
     38a:	15 96       	adiw	r26, 0x05	; 5
     38c:	9c 93       	st	X, r25
     38e:	8e 93       	st	-X, r24
     390:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     392:	eb 81       	ldd	r30, Y+3	; 0x03
     394:	fc 81       	ldd	r31, Y+4	; 0x04
     396:	a4 81       	ldd	r26, Z+4	; 0x04
     398:	b5 81       	ldd	r27, Z+5	; 0x05
     39a:	eb 81       	ldd	r30, Y+3	; 0x03
     39c:	fc 81       	ldd	r31, Y+4	; 0x04
     39e:	82 81       	ldd	r24, Z+2	; 0x02
     3a0:	93 81       	ldd	r25, Z+3	; 0x03
     3a2:	13 96       	adiw	r26, 0x03	; 3
     3a4:	9c 93       	st	X, r25
     3a6:	8e 93       	st	-X, r24
     3a8:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3aa:	e9 81       	ldd	r30, Y+1	; 0x01
     3ac:	fa 81       	ldd	r31, Y+2	; 0x02
     3ae:	21 81       	ldd	r18, Z+1	; 0x01
     3b0:	32 81       	ldd	r19, Z+2	; 0x02
     3b2:	8b 81       	ldd	r24, Y+3	; 0x03
     3b4:	9c 81       	ldd	r25, Y+4	; 0x04
     3b6:	28 17       	cp	r18, r24
     3b8:	39 07       	cpc	r19, r25
     3ba:	41 f4       	brne	.+16     	; 0x3cc <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3bc:	eb 81       	ldd	r30, Y+3	; 0x03
     3be:	fc 81       	ldd	r31, Y+4	; 0x04
     3c0:	84 81       	ldd	r24, Z+4	; 0x04
     3c2:	95 81       	ldd	r25, Z+5	; 0x05
     3c4:	e9 81       	ldd	r30, Y+1	; 0x01
     3c6:	fa 81       	ldd	r31, Y+2	; 0x02
     3c8:	92 83       	std	Z+2, r25	; 0x02
     3ca:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	11 86       	std	Z+9, r1	; 0x09
     3d2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3d4:	e9 81       	ldd	r30, Y+1	; 0x01
     3d6:	fa 81       	ldd	r31, Y+2	; 0x02
     3d8:	80 81       	ld	r24, Z
     3da:	81 50       	subi	r24, 0x01	; 1
     3dc:	e9 81       	ldd	r30, Y+1	; 0x01
     3de:	fa 81       	ldd	r31, Y+2	; 0x02
     3e0:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     3e2:	e9 81       	ldd	r30, Y+1	; 0x01
     3e4:	fa 81       	ldd	r31, Y+2	; 0x02
     3e6:	80 81       	ld	r24, Z
}
     3e8:	0f 90       	pop	r0
     3ea:	0f 90       	pop	r0
     3ec:	0f 90       	pop	r0
     3ee:	0f 90       	pop	r0
     3f0:	cf 91       	pop	r28
     3f2:	df 91       	pop	r29
     3f4:	08 95       	ret

000003f6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     3f6:	df 93       	push	r29
     3f8:	cf 93       	push	r28
     3fa:	cd b7       	in	r28, 0x3d	; 61
     3fc:	de b7       	in	r29, 0x3e	; 62
     3fe:	28 97       	sbiw	r28, 0x08	; 8
     400:	0f b6       	in	r0, 0x3f	; 63
     402:	f8 94       	cli
     404:	de bf       	out	0x3e, r29	; 62
     406:	0f be       	out	0x3f, r0	; 63
     408:	cd bf       	out	0x3d, r28	; 61
     40a:	9c 83       	std	Y+4, r25	; 0x04
     40c:	8b 83       	std	Y+3, r24	; 0x03
     40e:	7e 83       	std	Y+6, r23	; 0x06
     410:	6d 83       	std	Y+5, r22	; 0x05
     412:	58 87       	std	Y+8, r21	; 0x08
     414:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	81 e1       	ldi	r24, 0x11	; 17
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	82 e2       	ldi	r24, 0x22	; 34
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	83 e3       	ldi	r24, 0x33	; 51
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     44c:	8d 81       	ldd	r24, Y+5	; 0x05
     44e:	9e 81       	ldd	r25, Y+6	; 0x06
     450:	9a 83       	std	Y+2, r25	; 0x02
     452:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	eb 81       	ldd	r30, Y+3	; 0x03
     458:	fc 81       	ldd	r31, Y+4	; 0x04
     45a:	80 83       	st	Z, r24
	pxTopOfStack--;
     45c:	8b 81       	ldd	r24, Y+3	; 0x03
     45e:	9c 81       	ldd	r25, Y+4	; 0x04
     460:	01 97       	sbiw	r24, 0x01	; 1
     462:	9c 83       	std	Y+4, r25	; 0x04
     464:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	9a 81       	ldd	r25, Y+2	; 0x02
     46a:	89 2f       	mov	r24, r25
     46c:	99 27       	eor	r25, r25
     46e:	9a 83       	std	Y+2, r25	; 0x02
     470:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	eb 81       	ldd	r30, Y+3	; 0x03
     476:	fc 81       	ldd	r31, Y+4	; 0x04
     478:	80 83       	st	Z, r24
	pxTopOfStack--;
     47a:	8b 81       	ldd	r24, Y+3	; 0x03
     47c:	9c 81       	ldd	r25, Y+4	; 0x04
     47e:	01 97       	sbiw	r24, 0x01	; 1
     480:	9c 83       	std	Y+4, r25	; 0x04
     482:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     484:	eb 81       	ldd	r30, Y+3	; 0x03
     486:	fc 81       	ldd	r31, Y+4	; 0x04
     488:	10 82       	st	Z, r1
	pxTopOfStack--;
     48a:	8b 81       	ldd	r24, Y+3	; 0x03
     48c:	9c 81       	ldd	r25, Y+4	; 0x04
     48e:	01 97       	sbiw	r24, 0x01	; 1
     490:	9c 83       	std	Y+4, r25	; 0x04
     492:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     494:	eb 81       	ldd	r30, Y+3	; 0x03
     496:	fc 81       	ldd	r31, Y+4	; 0x04
     498:	80 e8       	ldi	r24, 0x80	; 128
     49a:	80 83       	st	Z, r24
	pxTopOfStack--;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	01 97       	sbiw	r24, 0x01	; 1
     4a2:	9c 83       	std	Y+4, r25	; 0x04
     4a4:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     4a6:	eb 81       	ldd	r30, Y+3	; 0x03
     4a8:	fc 81       	ldd	r31, Y+4	; 0x04
     4aa:	10 82       	st	Z, r1
	pxTopOfStack--;
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	9c 81       	ldd	r25, Y+4	; 0x04
     4b0:	01 97       	sbiw	r24, 0x01	; 1
     4b2:	9c 83       	std	Y+4, r25	; 0x04
     4b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     4b6:	eb 81       	ldd	r30, Y+3	; 0x03
     4b8:	fc 81       	ldd	r31, Y+4	; 0x04
     4ba:	82 e0       	ldi	r24, 0x02	; 2
     4bc:	80 83       	st	Z, r24
	pxTopOfStack--;
     4be:	8b 81       	ldd	r24, Y+3	; 0x03
     4c0:	9c 81       	ldd	r25, Y+4	; 0x04
     4c2:	01 97       	sbiw	r24, 0x01	; 1
     4c4:	9c 83       	std	Y+4, r25	; 0x04
     4c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     4c8:	eb 81       	ldd	r30, Y+3	; 0x03
     4ca:	fc 81       	ldd	r31, Y+4	; 0x04
     4cc:	83 e0       	ldi	r24, 0x03	; 3
     4ce:	80 83       	st	Z, r24
	pxTopOfStack--;
     4d0:	8b 81       	ldd	r24, Y+3	; 0x03
     4d2:	9c 81       	ldd	r25, Y+4	; 0x04
     4d4:	01 97       	sbiw	r24, 0x01	; 1
     4d6:	9c 83       	std	Y+4, r25	; 0x04
     4d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     4da:	eb 81       	ldd	r30, Y+3	; 0x03
     4dc:	fc 81       	ldd	r31, Y+4	; 0x04
     4de:	84 e0       	ldi	r24, 0x04	; 4
     4e0:	80 83       	st	Z, r24
	pxTopOfStack--;
     4e2:	8b 81       	ldd	r24, Y+3	; 0x03
     4e4:	9c 81       	ldd	r25, Y+4	; 0x04
     4e6:	01 97       	sbiw	r24, 0x01	; 1
     4e8:	9c 83       	std	Y+4, r25	; 0x04
     4ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     4ec:	eb 81       	ldd	r30, Y+3	; 0x03
     4ee:	fc 81       	ldd	r31, Y+4	; 0x04
     4f0:	85 e0       	ldi	r24, 0x05	; 5
     4f2:	80 83       	st	Z, r24
	pxTopOfStack--;
     4f4:	8b 81       	ldd	r24, Y+3	; 0x03
     4f6:	9c 81       	ldd	r25, Y+4	; 0x04
     4f8:	01 97       	sbiw	r24, 0x01	; 1
     4fa:	9c 83       	std	Y+4, r25	; 0x04
     4fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     4fe:	eb 81       	ldd	r30, Y+3	; 0x03
     500:	fc 81       	ldd	r31, Y+4	; 0x04
     502:	86 e0       	ldi	r24, 0x06	; 6
     504:	80 83       	st	Z, r24
	pxTopOfStack--;
     506:	8b 81       	ldd	r24, Y+3	; 0x03
     508:	9c 81       	ldd	r25, Y+4	; 0x04
     50a:	01 97       	sbiw	r24, 0x01	; 1
     50c:	9c 83       	std	Y+4, r25	; 0x04
     50e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     510:	eb 81       	ldd	r30, Y+3	; 0x03
     512:	fc 81       	ldd	r31, Y+4	; 0x04
     514:	87 e0       	ldi	r24, 0x07	; 7
     516:	80 83       	st	Z, r24
	pxTopOfStack--;
     518:	8b 81       	ldd	r24, Y+3	; 0x03
     51a:	9c 81       	ldd	r25, Y+4	; 0x04
     51c:	01 97       	sbiw	r24, 0x01	; 1
     51e:	9c 83       	std	Y+4, r25	; 0x04
     520:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     522:	eb 81       	ldd	r30, Y+3	; 0x03
     524:	fc 81       	ldd	r31, Y+4	; 0x04
     526:	88 e0       	ldi	r24, 0x08	; 8
     528:	80 83       	st	Z, r24
	pxTopOfStack--;
     52a:	8b 81       	ldd	r24, Y+3	; 0x03
     52c:	9c 81       	ldd	r25, Y+4	; 0x04
     52e:	01 97       	sbiw	r24, 0x01	; 1
     530:	9c 83       	std	Y+4, r25	; 0x04
     532:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     534:	eb 81       	ldd	r30, Y+3	; 0x03
     536:	fc 81       	ldd	r31, Y+4	; 0x04
     538:	89 e0       	ldi	r24, 0x09	; 9
     53a:	80 83       	st	Z, r24
	pxTopOfStack--;
     53c:	8b 81       	ldd	r24, Y+3	; 0x03
     53e:	9c 81       	ldd	r25, Y+4	; 0x04
     540:	01 97       	sbiw	r24, 0x01	; 1
     542:	9c 83       	std	Y+4, r25	; 0x04
     544:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     546:	eb 81       	ldd	r30, Y+3	; 0x03
     548:	fc 81       	ldd	r31, Y+4	; 0x04
     54a:	80 e1       	ldi	r24, 0x10	; 16
     54c:	80 83       	st	Z, r24
	pxTopOfStack--;
     54e:	8b 81       	ldd	r24, Y+3	; 0x03
     550:	9c 81       	ldd	r25, Y+4	; 0x04
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	9c 83       	std	Y+4, r25	; 0x04
     556:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     558:	eb 81       	ldd	r30, Y+3	; 0x03
     55a:	fc 81       	ldd	r31, Y+4	; 0x04
     55c:	81 e1       	ldi	r24, 0x11	; 17
     55e:	80 83       	st	Z, r24
	pxTopOfStack--;
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	9c 81       	ldd	r25, Y+4	; 0x04
     564:	01 97       	sbiw	r24, 0x01	; 1
     566:	9c 83       	std	Y+4, r25	; 0x04
     568:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     56a:	eb 81       	ldd	r30, Y+3	; 0x03
     56c:	fc 81       	ldd	r31, Y+4	; 0x04
     56e:	82 e1       	ldi	r24, 0x12	; 18
     570:	80 83       	st	Z, r24
	pxTopOfStack--;
     572:	8b 81       	ldd	r24, Y+3	; 0x03
     574:	9c 81       	ldd	r25, Y+4	; 0x04
     576:	01 97       	sbiw	r24, 0x01	; 1
     578:	9c 83       	std	Y+4, r25	; 0x04
     57a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     57c:	eb 81       	ldd	r30, Y+3	; 0x03
     57e:	fc 81       	ldd	r31, Y+4	; 0x04
     580:	83 e1       	ldi	r24, 0x13	; 19
     582:	80 83       	st	Z, r24
	pxTopOfStack--;
     584:	8b 81       	ldd	r24, Y+3	; 0x03
     586:	9c 81       	ldd	r25, Y+4	; 0x04
     588:	01 97       	sbiw	r24, 0x01	; 1
     58a:	9c 83       	std	Y+4, r25	; 0x04
     58c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     58e:	eb 81       	ldd	r30, Y+3	; 0x03
     590:	fc 81       	ldd	r31, Y+4	; 0x04
     592:	84 e1       	ldi	r24, 0x14	; 20
     594:	80 83       	st	Z, r24
	pxTopOfStack--;
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	01 97       	sbiw	r24, 0x01	; 1
     59c:	9c 83       	std	Y+4, r25	; 0x04
     59e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     5a0:	eb 81       	ldd	r30, Y+3	; 0x03
     5a2:	fc 81       	ldd	r31, Y+4	; 0x04
     5a4:	85 e1       	ldi	r24, 0x15	; 21
     5a6:	80 83       	st	Z, r24
	pxTopOfStack--;
     5a8:	8b 81       	ldd	r24, Y+3	; 0x03
     5aa:	9c 81       	ldd	r25, Y+4	; 0x04
     5ac:	01 97       	sbiw	r24, 0x01	; 1
     5ae:	9c 83       	std	Y+4, r25	; 0x04
     5b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     5b2:	eb 81       	ldd	r30, Y+3	; 0x03
     5b4:	fc 81       	ldd	r31, Y+4	; 0x04
     5b6:	86 e1       	ldi	r24, 0x16	; 22
     5b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     5ba:	8b 81       	ldd	r24, Y+3	; 0x03
     5bc:	9c 81       	ldd	r25, Y+4	; 0x04
     5be:	01 97       	sbiw	r24, 0x01	; 1
     5c0:	9c 83       	std	Y+4, r25	; 0x04
     5c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     5c4:	eb 81       	ldd	r30, Y+3	; 0x03
     5c6:	fc 81       	ldd	r31, Y+4	; 0x04
     5c8:	87 e1       	ldi	r24, 0x17	; 23
     5ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	01 97       	sbiw	r24, 0x01	; 1
     5d2:	9c 83       	std	Y+4, r25	; 0x04
     5d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     5d6:	eb 81       	ldd	r30, Y+3	; 0x03
     5d8:	fc 81       	ldd	r31, Y+4	; 0x04
     5da:	88 e1       	ldi	r24, 0x18	; 24
     5dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     5de:	8b 81       	ldd	r24, Y+3	; 0x03
     5e0:	9c 81       	ldd	r25, Y+4	; 0x04
     5e2:	01 97       	sbiw	r24, 0x01	; 1
     5e4:	9c 83       	std	Y+4, r25	; 0x04
     5e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     5e8:	eb 81       	ldd	r30, Y+3	; 0x03
     5ea:	fc 81       	ldd	r31, Y+4	; 0x04
     5ec:	89 e1       	ldi	r24, 0x19	; 25
     5ee:	80 83       	st	Z, r24
	pxTopOfStack--;
     5f0:	8b 81       	ldd	r24, Y+3	; 0x03
     5f2:	9c 81       	ldd	r25, Y+4	; 0x04
     5f4:	01 97       	sbiw	r24, 0x01	; 1
     5f6:	9c 83       	std	Y+4, r25	; 0x04
     5f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     5fa:	eb 81       	ldd	r30, Y+3	; 0x03
     5fc:	fc 81       	ldd	r31, Y+4	; 0x04
     5fe:	80 e2       	ldi	r24, 0x20	; 32
     600:	80 83       	st	Z, r24
	pxTopOfStack--;
     602:	8b 81       	ldd	r24, Y+3	; 0x03
     604:	9c 81       	ldd	r25, Y+4	; 0x04
     606:	01 97       	sbiw	r24, 0x01	; 1
     608:	9c 83       	std	Y+4, r25	; 0x04
     60a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     60c:	eb 81       	ldd	r30, Y+3	; 0x03
     60e:	fc 81       	ldd	r31, Y+4	; 0x04
     610:	81 e2       	ldi	r24, 0x21	; 33
     612:	80 83       	st	Z, r24
	pxTopOfStack--;
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	9c 81       	ldd	r25, Y+4	; 0x04
     618:	01 97       	sbiw	r24, 0x01	; 1
     61a:	9c 83       	std	Y+4, r25	; 0x04
     61c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     61e:	eb 81       	ldd	r30, Y+3	; 0x03
     620:	fc 81       	ldd	r31, Y+4	; 0x04
     622:	82 e2       	ldi	r24, 0x22	; 34
     624:	80 83       	st	Z, r24
	pxTopOfStack--;
     626:	8b 81       	ldd	r24, Y+3	; 0x03
     628:	9c 81       	ldd	r25, Y+4	; 0x04
     62a:	01 97       	sbiw	r24, 0x01	; 1
     62c:	9c 83       	std	Y+4, r25	; 0x04
     62e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     630:	eb 81       	ldd	r30, Y+3	; 0x03
     632:	fc 81       	ldd	r31, Y+4	; 0x04
     634:	83 e2       	ldi	r24, 0x23	; 35
     636:	80 83       	st	Z, r24
	pxTopOfStack--;
     638:	8b 81       	ldd	r24, Y+3	; 0x03
     63a:	9c 81       	ldd	r25, Y+4	; 0x04
     63c:	01 97       	sbiw	r24, 0x01	; 1
     63e:	9c 83       	std	Y+4, r25	; 0x04
     640:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     642:	8f 81       	ldd	r24, Y+7	; 0x07
     644:	98 85       	ldd	r25, Y+8	; 0x08
     646:	9a 83       	std	Y+2, r25	; 0x02
     648:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     64a:	89 81       	ldd	r24, Y+1	; 0x01
     64c:	eb 81       	ldd	r30, Y+3	; 0x03
     64e:	fc 81       	ldd	r31, Y+4	; 0x04
     650:	80 83       	st	Z, r24
	pxTopOfStack--;
     652:	8b 81       	ldd	r24, Y+3	; 0x03
     654:	9c 81       	ldd	r25, Y+4	; 0x04
     656:	01 97       	sbiw	r24, 0x01	; 1
     658:	9c 83       	std	Y+4, r25	; 0x04
     65a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     65c:	89 81       	ldd	r24, Y+1	; 0x01
     65e:	9a 81       	ldd	r25, Y+2	; 0x02
     660:	89 2f       	mov	r24, r25
     662:	99 27       	eor	r25, r25
     664:	9a 83       	std	Y+2, r25	; 0x02
     666:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     668:	89 81       	ldd	r24, Y+1	; 0x01
     66a:	eb 81       	ldd	r30, Y+3	; 0x03
     66c:	fc 81       	ldd	r31, Y+4	; 0x04
     66e:	80 83       	st	Z, r24
	pxTopOfStack--;
     670:	8b 81       	ldd	r24, Y+3	; 0x03
     672:	9c 81       	ldd	r25, Y+4	; 0x04
     674:	01 97       	sbiw	r24, 0x01	; 1
     676:	9c 83       	std	Y+4, r25	; 0x04
     678:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     67a:	eb 81       	ldd	r30, Y+3	; 0x03
     67c:	fc 81       	ldd	r31, Y+4	; 0x04
     67e:	86 e2       	ldi	r24, 0x26	; 38
     680:	80 83       	st	Z, r24
	pxTopOfStack--;
     682:	8b 81       	ldd	r24, Y+3	; 0x03
     684:	9c 81       	ldd	r25, Y+4	; 0x04
     686:	01 97       	sbiw	r24, 0x01	; 1
     688:	9c 83       	std	Y+4, r25	; 0x04
     68a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     68c:	eb 81       	ldd	r30, Y+3	; 0x03
     68e:	fc 81       	ldd	r31, Y+4	; 0x04
     690:	87 e2       	ldi	r24, 0x27	; 39
     692:	80 83       	st	Z, r24
	pxTopOfStack--;
     694:	8b 81       	ldd	r24, Y+3	; 0x03
     696:	9c 81       	ldd	r25, Y+4	; 0x04
     698:	01 97       	sbiw	r24, 0x01	; 1
     69a:	9c 83       	std	Y+4, r25	; 0x04
     69c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     69e:	eb 81       	ldd	r30, Y+3	; 0x03
     6a0:	fc 81       	ldd	r31, Y+4	; 0x04
     6a2:	88 e2       	ldi	r24, 0x28	; 40
     6a4:	80 83       	st	Z, r24
	pxTopOfStack--;
     6a6:	8b 81       	ldd	r24, Y+3	; 0x03
     6a8:	9c 81       	ldd	r25, Y+4	; 0x04
     6aa:	01 97       	sbiw	r24, 0x01	; 1
     6ac:	9c 83       	std	Y+4, r25	; 0x04
     6ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     6b0:	eb 81       	ldd	r30, Y+3	; 0x03
     6b2:	fc 81       	ldd	r31, Y+4	; 0x04
     6b4:	89 e2       	ldi	r24, 0x29	; 41
     6b6:	80 83       	st	Z, r24
	pxTopOfStack--;
     6b8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ba:	9c 81       	ldd	r25, Y+4	; 0x04
     6bc:	01 97       	sbiw	r24, 0x01	; 1
     6be:	9c 83       	std	Y+4, r25	; 0x04
     6c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     6c2:	eb 81       	ldd	r30, Y+3	; 0x03
     6c4:	fc 81       	ldd	r31, Y+4	; 0x04
     6c6:	80 e3       	ldi	r24, 0x30	; 48
     6c8:	80 83       	st	Z, r24
	pxTopOfStack--;
     6ca:	8b 81       	ldd	r24, Y+3	; 0x03
     6cc:	9c 81       	ldd	r25, Y+4	; 0x04
     6ce:	01 97       	sbiw	r24, 0x01	; 1
     6d0:	9c 83       	std	Y+4, r25	; 0x04
     6d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     6d4:	eb 81       	ldd	r30, Y+3	; 0x03
     6d6:	fc 81       	ldd	r31, Y+4	; 0x04
     6d8:	81 e3       	ldi	r24, 0x31	; 49
     6da:	80 83       	st	Z, r24
	pxTopOfStack--;
     6dc:	8b 81       	ldd	r24, Y+3	; 0x03
     6de:	9c 81       	ldd	r25, Y+4	; 0x04
     6e0:	01 97       	sbiw	r24, 0x01	; 1
     6e2:	9c 83       	std	Y+4, r25	; 0x04
     6e4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     6e6:	8b 81       	ldd	r24, Y+3	; 0x03
     6e8:	9c 81       	ldd	r25, Y+4	; 0x04
}
     6ea:	28 96       	adiw	r28, 0x08	; 8
     6ec:	0f b6       	in	r0, 0x3f	; 63
     6ee:	f8 94       	cli
     6f0:	de bf       	out	0x3e, r29	; 62
     6f2:	0f be       	out	0x3f, r0	; 63
     6f4:	cd bf       	out	0x3d, r28	; 61
     6f6:	cf 91       	pop	r28
     6f8:	df 91       	pop	r29
     6fa:	08 95       	ret

000006fc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     6fc:	df 93       	push	r29
     6fe:	cf 93       	push	r28
     700:	cd b7       	in	r28, 0x3d	; 61
     702:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     704:	0e 94 70 04 	call	0x8e0	; 0x8e0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     708:	a0 91 52 04 	lds	r26, 0x0452
     70c:	b0 91 53 04 	lds	r27, 0x0453
     710:	cd 91       	ld	r28, X+
     712:	cd bf       	out	0x3d, r28	; 61
     714:	dd 91       	ld	r29, X+
     716:	de bf       	out	0x3e, r29	; 62
     718:	ff 91       	pop	r31
     71a:	ef 91       	pop	r30
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	bf 91       	pop	r27
     722:	af 91       	pop	r26
     724:	9f 91       	pop	r25
     726:	8f 91       	pop	r24
     728:	7f 91       	pop	r23
     72a:	6f 91       	pop	r22
     72c:	5f 91       	pop	r21
     72e:	4f 91       	pop	r20
     730:	3f 91       	pop	r19
     732:	2f 91       	pop	r18
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	df 90       	pop	r13
     73e:	cf 90       	pop	r12
     740:	bf 90       	pop	r11
     742:	af 90       	pop	r10
     744:	9f 90       	pop	r9
     746:	8f 90       	pop	r8
     748:	7f 90       	pop	r7
     74a:	6f 90       	pop	r6
     74c:	5f 90       	pop	r5
     74e:	4f 90       	pop	r4
     750:	3f 90       	pop	r3
     752:	2f 90       	pop	r2
     754:	1f 90       	pop	r1
     756:	0f 90       	pop	r0
     758:	0f be       	out	0x3f, r0	; 63
     75a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     75c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     75e:	81 e0       	ldi	r24, 0x01	; 1
}
     760:	cf 91       	pop	r28
     762:	df 91       	pop	r29
     764:	08 95       	ret

00000766 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     766:	df 93       	push	r29
     768:	cf 93       	push	r28
     76a:	cd b7       	in	r28, 0x3d	; 61
     76c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     76e:	cf 91       	pop	r28
     770:	df 91       	pop	r29
     772:	08 95       	ret

00000774 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     774:	0f 92       	push	r0
     776:	0f b6       	in	r0, 0x3f	; 63
     778:	f8 94       	cli
     77a:	0f 92       	push	r0
     77c:	1f 92       	push	r1
     77e:	11 24       	eor	r1, r1
     780:	2f 92       	push	r2
     782:	3f 92       	push	r3
     784:	4f 92       	push	r4
     786:	5f 92       	push	r5
     788:	6f 92       	push	r6
     78a:	7f 92       	push	r7
     78c:	8f 92       	push	r8
     78e:	9f 92       	push	r9
     790:	af 92       	push	r10
     792:	bf 92       	push	r11
     794:	cf 92       	push	r12
     796:	df 92       	push	r13
     798:	ef 92       	push	r14
     79a:	ff 92       	push	r15
     79c:	0f 93       	push	r16
     79e:	1f 93       	push	r17
     7a0:	2f 93       	push	r18
     7a2:	3f 93       	push	r19
     7a4:	4f 93       	push	r20
     7a6:	5f 93       	push	r21
     7a8:	6f 93       	push	r22
     7aa:	7f 93       	push	r23
     7ac:	8f 93       	push	r24
     7ae:	9f 93       	push	r25
     7b0:	af 93       	push	r26
     7b2:	bf 93       	push	r27
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	ef 93       	push	r30
     7ba:	ff 93       	push	r31
     7bc:	a0 91 52 04 	lds	r26, 0x0452
     7c0:	b0 91 53 04 	lds	r27, 0x0453
     7c4:	0d b6       	in	r0, 0x3d	; 61
     7c6:	0d 92       	st	X+, r0
     7c8:	0e b6       	in	r0, 0x3e	; 62
     7ca:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7cc:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7d0:	a0 91 52 04 	lds	r26, 0x0452
     7d4:	b0 91 53 04 	lds	r27, 0x0453
     7d8:	cd 91       	ld	r28, X+
     7da:	cd bf       	out	0x3d, r28	; 61
     7dc:	dd 91       	ld	r29, X+
     7de:	de bf       	out	0x3e, r29	; 62
     7e0:	ff 91       	pop	r31
     7e2:	ef 91       	pop	r30
     7e4:	df 91       	pop	r29
     7e6:	cf 91       	pop	r28
     7e8:	bf 91       	pop	r27
     7ea:	af 91       	pop	r26
     7ec:	9f 91       	pop	r25
     7ee:	8f 91       	pop	r24
     7f0:	7f 91       	pop	r23
     7f2:	6f 91       	pop	r22
     7f4:	5f 91       	pop	r21
     7f6:	4f 91       	pop	r20
     7f8:	3f 91       	pop	r19
     7fa:	2f 91       	pop	r18
     7fc:	1f 91       	pop	r17
     7fe:	0f 91       	pop	r16
     800:	ff 90       	pop	r15
     802:	ef 90       	pop	r14
     804:	df 90       	pop	r13
     806:	cf 90       	pop	r12
     808:	bf 90       	pop	r11
     80a:	af 90       	pop	r10
     80c:	9f 90       	pop	r9
     80e:	8f 90       	pop	r8
     810:	7f 90       	pop	r7
     812:	6f 90       	pop	r6
     814:	5f 90       	pop	r5
     816:	4f 90       	pop	r4
     818:	3f 90       	pop	r3
     81a:	2f 90       	pop	r2
     81c:	1f 90       	pop	r1
     81e:	0f 90       	pop	r0
     820:	0f be       	out	0x3f, r0	; 63
     822:	0f 90       	pop	r0

	asm volatile ( "ret" );
     824:	08 95       	ret

00000826 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     826:	0f 92       	push	r0
     828:	0f b6       	in	r0, 0x3f	; 63
     82a:	f8 94       	cli
     82c:	0f 92       	push	r0
     82e:	1f 92       	push	r1
     830:	11 24       	eor	r1, r1
     832:	2f 92       	push	r2
     834:	3f 92       	push	r3
     836:	4f 92       	push	r4
     838:	5f 92       	push	r5
     83a:	6f 92       	push	r6
     83c:	7f 92       	push	r7
     83e:	8f 92       	push	r8
     840:	9f 92       	push	r9
     842:	af 92       	push	r10
     844:	bf 92       	push	r11
     846:	cf 92       	push	r12
     848:	df 92       	push	r13
     84a:	ef 92       	push	r14
     84c:	ff 92       	push	r15
     84e:	0f 93       	push	r16
     850:	1f 93       	push	r17
     852:	2f 93       	push	r18
     854:	3f 93       	push	r19
     856:	4f 93       	push	r20
     858:	5f 93       	push	r21
     85a:	6f 93       	push	r22
     85c:	7f 93       	push	r23
     85e:	8f 93       	push	r24
     860:	9f 93       	push	r25
     862:	af 93       	push	r26
     864:	bf 93       	push	r27
     866:	cf 93       	push	r28
     868:	df 93       	push	r29
     86a:	ef 93       	push	r30
     86c:	ff 93       	push	r31
     86e:	a0 91 52 04 	lds	r26, 0x0452
     872:	b0 91 53 04 	lds	r27, 0x0453
     876:	0d b6       	in	r0, 0x3d	; 61
     878:	0d 92       	st	X+, r0
     87a:	0e b6       	in	r0, 0x3e	; 62
     87c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     87e:	0e 94 92 12 	call	0x2524	; 0x2524 <xTaskIncrementTick>
     882:	88 23       	and	r24, r24
     884:	11 f0       	breq	.+4      	; 0x88a <__stack+0x2b>
	{
		vTaskSwitchContext();
     886:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     88a:	a0 91 52 04 	lds	r26, 0x0452
     88e:	b0 91 53 04 	lds	r27, 0x0453
     892:	cd 91       	ld	r28, X+
     894:	cd bf       	out	0x3d, r28	; 61
     896:	dd 91       	ld	r29, X+
     898:	de bf       	out	0x3e, r29	; 62
     89a:	ff 91       	pop	r31
     89c:	ef 91       	pop	r30
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	bf 91       	pop	r27
     8a4:	af 91       	pop	r26
     8a6:	9f 91       	pop	r25
     8a8:	8f 91       	pop	r24
     8aa:	7f 91       	pop	r23
     8ac:	6f 91       	pop	r22
     8ae:	5f 91       	pop	r21
     8b0:	4f 91       	pop	r20
     8b2:	3f 91       	pop	r19
     8b4:	2f 91       	pop	r18
     8b6:	1f 91       	pop	r17
     8b8:	0f 91       	pop	r16
     8ba:	ff 90       	pop	r15
     8bc:	ef 90       	pop	r14
     8be:	df 90       	pop	r13
     8c0:	cf 90       	pop	r12
     8c2:	bf 90       	pop	r11
     8c4:	af 90       	pop	r10
     8c6:	9f 90       	pop	r9
     8c8:	8f 90       	pop	r8
     8ca:	7f 90       	pop	r7
     8cc:	6f 90       	pop	r6
     8ce:	5f 90       	pop	r5
     8d0:	4f 90       	pop	r4
     8d2:	3f 90       	pop	r3
     8d4:	2f 90       	pop	r2
     8d6:	1f 90       	pop	r1
     8d8:	0f 90       	pop	r0
     8da:	0f be       	out	0x3f, r0	; 63
     8dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8de:	08 95       	ret

000008e0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     8e0:	df 93       	push	r29
     8e2:	cf 93       	push	r28
     8e4:	00 d0       	rcall	.+0      	; 0x8e6 <prvSetupTimerInterrupt+0x6>
     8e6:	00 d0       	rcall	.+0      	; 0x8e8 <prvSetupTimerInterrupt+0x8>
     8e8:	00 d0       	rcall	.+0      	; 0x8ea <prvSetupTimerInterrupt+0xa>
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     8ee:	80 e4       	ldi	r24, 0x40	; 64
     8f0:	9f e1       	ldi	r25, 0x1F	; 31
     8f2:	a0 e0       	ldi	r26, 0x00	; 0
     8f4:	b0 e0       	ldi	r27, 0x00	; 0
     8f6:	8b 83       	std	Y+3, r24	; 0x03
     8f8:	9c 83       	std	Y+4, r25	; 0x04
     8fa:	ad 83       	std	Y+5, r26	; 0x05
     8fc:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     8fe:	8b 81       	ldd	r24, Y+3	; 0x03
     900:	9c 81       	ldd	r25, Y+4	; 0x04
     902:	ad 81       	ldd	r26, Y+5	; 0x05
     904:	be 81       	ldd	r27, Y+6	; 0x06
     906:	68 94       	set
     908:	15 f8       	bld	r1, 5
     90a:	b6 95       	lsr	r27
     90c:	a7 95       	ror	r26
     90e:	97 95       	ror	r25
     910:	87 95       	ror	r24
     912:	16 94       	lsr	r1
     914:	d1 f7       	brne	.-12     	; 0x90a <prvSetupTimerInterrupt+0x2a>
     916:	8b 83       	std	Y+3, r24	; 0x03
     918:	9c 83       	std	Y+4, r25	; 0x04
     91a:	ad 83       	std	Y+5, r26	; 0x05
     91c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     91e:	8b 81       	ldd	r24, Y+3	; 0x03
     920:	9c 81       	ldd	r25, Y+4	; 0x04
     922:	ad 81       	ldd	r26, Y+5	; 0x05
     924:	be 81       	ldd	r27, Y+6	; 0x06
     926:	01 97       	sbiw	r24, 0x01	; 1
     928:	a1 09       	sbc	r26, r1
     92a:	b1 09       	sbc	r27, r1
     92c:	8b 83       	std	Y+3, r24	; 0x03
     92e:	9c 83       	std	Y+4, r25	; 0x04
     930:	ad 83       	std	Y+5, r26	; 0x05
     932:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     934:	8b 81       	ldd	r24, Y+3	; 0x03
     936:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	9c 81       	ldd	r25, Y+4	; 0x04
     93c:	ad 81       	ldd	r26, Y+5	; 0x05
     93e:	be 81       	ldd	r27, Y+6	; 0x06
     940:	89 2f       	mov	r24, r25
     942:	9a 2f       	mov	r25, r26
     944:	ab 2f       	mov	r26, r27
     946:	bb 27       	eor	r27, r27
     948:	8b 83       	std	Y+3, r24	; 0x03
     94a:	9c 83       	std	Y+4, r25	; 0x04
     94c:	ad 83       	std	Y+5, r26	; 0x05
     94e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     950:	8b 81       	ldd	r24, Y+3	; 0x03
     952:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     954:	eb e4       	ldi	r30, 0x4B	; 75
     956:	f0 e0       	ldi	r31, 0x00	; 0
     958:	8a 81       	ldd	r24, Y+2	; 0x02
     95a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     95c:	ea e4       	ldi	r30, 0x4A	; 74
     95e:	f0 e0       	ldi	r31, 0x00	; 0
     960:	89 81       	ldd	r24, Y+1	; 0x01
     962:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     964:	8b e0       	ldi	r24, 0x0B	; 11
     966:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     968:	ee e4       	ldi	r30, 0x4E	; 78
     96a:	f0 e0       	ldi	r31, 0x00	; 0
     96c:	89 81       	ldd	r24, Y+1	; 0x01
     96e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     970:	e9 e5       	ldi	r30, 0x59	; 89
     972:	f0 e0       	ldi	r31, 0x00	; 0
     974:	80 81       	ld	r24, Z
     976:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     978:	89 81       	ldd	r24, Y+1	; 0x01
     97a:	80 61       	ori	r24, 0x10	; 16
     97c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     97e:	e9 e5       	ldi	r30, 0x59	; 89
     980:	f0 e0       	ldi	r31, 0x00	; 0
     982:	89 81       	ldd	r24, Y+1	; 0x01
     984:	80 83       	st	Z, r24
}
     986:	26 96       	adiw	r28, 0x06	; 6
     988:	0f b6       	in	r0, 0x3f	; 63
     98a:	f8 94       	cli
     98c:	de bf       	out	0x3e, r29	; 62
     98e:	0f be       	out	0x3f, r0	; 63
     990:	cd bf       	out	0x3d, r28	; 61
     992:	cf 91       	pop	r28
     994:	df 91       	pop	r29
     996:	08 95       	ret

00000998 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     998:	0e 94 13 04 	call	0x826	; 0x826 <vPortYieldFromTick>
		asm volatile ( "reti" );
     99c:	18 95       	reti

0000099e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     99e:	df 93       	push	r29
     9a0:	cf 93       	push	r28
     9a2:	00 d0       	rcall	.+0      	; 0x9a4 <xQueueGenericReset+0x6>
     9a4:	00 d0       	rcall	.+0      	; 0x9a6 <xQueueGenericReset+0x8>
     9a6:	0f 92       	push	r0
     9a8:	cd b7       	in	r28, 0x3d	; 61
     9aa:	de b7       	in	r29, 0x3e	; 62
     9ac:	9c 83       	std	Y+4, r25	; 0x04
     9ae:	8b 83       	std	Y+3, r24	; 0x03
     9b0:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
     9b2:	8b 81       	ldd	r24, Y+3	; 0x03
     9b4:	9c 81       	ldd	r25, Y+4	; 0x04
     9b6:	9a 83       	std	Y+2, r25	; 0x02
     9b8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     9ba:	0f b6       	in	r0, 0x3f	; 63
     9bc:	f8 94       	cli
     9be:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     9c0:	e9 81       	ldd	r30, Y+1	; 0x01
     9c2:	fa 81       	ldd	r31, Y+2	; 0x02
     9c4:	40 81       	ld	r20, Z
     9c6:	51 81       	ldd	r21, Z+1	; 0x01
     9c8:	e9 81       	ldd	r30, Y+1	; 0x01
     9ca:	fa 81       	ldd	r31, Y+2	; 0x02
     9cc:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ce:	28 2f       	mov	r18, r24
     9d0:	30 e0       	ldi	r19, 0x00	; 0
     9d2:	e9 81       	ldd	r30, Y+1	; 0x01
     9d4:	fa 81       	ldd	r31, Y+2	; 0x02
     9d6:	84 8d       	ldd	r24, Z+28	; 0x1c
     9d8:	88 2f       	mov	r24, r24
     9da:	90 e0       	ldi	r25, 0x00	; 0
     9dc:	bc 01       	movw	r22, r24
     9de:	26 9f       	mul	r18, r22
     9e0:	c0 01       	movw	r24, r0
     9e2:	27 9f       	mul	r18, r23
     9e4:	90 0d       	add	r25, r0
     9e6:	36 9f       	mul	r19, r22
     9e8:	90 0d       	add	r25, r0
     9ea:	11 24       	eor	r1, r1
     9ec:	84 0f       	add	r24, r20
     9ee:	95 1f       	adc	r25, r21
     9f0:	e9 81       	ldd	r30, Y+1	; 0x01
     9f2:	fa 81       	ldd	r31, Y+2	; 0x02
     9f4:	95 83       	std	Z+5, r25	; 0x05
     9f6:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     9f8:	e9 81       	ldd	r30, Y+1	; 0x01
     9fa:	fa 81       	ldd	r31, Y+2	; 0x02
     9fc:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     9fe:	e9 81       	ldd	r30, Y+1	; 0x01
     a00:	fa 81       	ldd	r31, Y+2	; 0x02
     a02:	80 81       	ld	r24, Z
     a04:	91 81       	ldd	r25, Z+1	; 0x01
     a06:	e9 81       	ldd	r30, Y+1	; 0x01
     a08:	fa 81       	ldd	r31, Y+2	; 0x02
     a0a:	93 83       	std	Z+3, r25	; 0x03
     a0c:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     a0e:	e9 81       	ldd	r30, Y+1	; 0x01
     a10:	fa 81       	ldd	r31, Y+2	; 0x02
     a12:	40 81       	ld	r20, Z
     a14:	51 81       	ldd	r21, Z+1	; 0x01
     a16:	e9 81       	ldd	r30, Y+1	; 0x01
     a18:	fa 81       	ldd	r31, Y+2	; 0x02
     a1a:	83 8d       	ldd	r24, Z+27	; 0x1b
     a1c:	88 2f       	mov	r24, r24
     a1e:	90 e0       	ldi	r25, 0x00	; 0
     a20:	9c 01       	movw	r18, r24
     a22:	21 50       	subi	r18, 0x01	; 1
     a24:	30 40       	sbci	r19, 0x00	; 0
     a26:	e9 81       	ldd	r30, Y+1	; 0x01
     a28:	fa 81       	ldd	r31, Y+2	; 0x02
     a2a:	84 8d       	ldd	r24, Z+28	; 0x1c
     a2c:	88 2f       	mov	r24, r24
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	bc 01       	movw	r22, r24
     a32:	26 9f       	mul	r18, r22
     a34:	c0 01       	movw	r24, r0
     a36:	27 9f       	mul	r18, r23
     a38:	90 0d       	add	r25, r0
     a3a:	36 9f       	mul	r19, r22
     a3c:	90 0d       	add	r25, r0
     a3e:	11 24       	eor	r1, r1
     a40:	84 0f       	add	r24, r20
     a42:	95 1f       	adc	r25, r21
     a44:	e9 81       	ldd	r30, Y+1	; 0x01
     a46:	fa 81       	ldd	r31, Y+2	; 0x02
     a48:	97 83       	std	Z+7, r25	; 0x07
     a4a:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     a4c:	e9 81       	ldd	r30, Y+1	; 0x01
     a4e:	fa 81       	ldd	r31, Y+2	; 0x02
     a50:	8f ef       	ldi	r24, 0xFF	; 255
     a52:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     a54:	e9 81       	ldd	r30, Y+1	; 0x01
     a56:	fa 81       	ldd	r31, Y+2	; 0x02
     a58:	8f ef       	ldi	r24, 0xFF	; 255
     a5a:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     a5c:	8d 81       	ldd	r24, Y+5	; 0x05
     a5e:	88 23       	and	r24, r24
     a60:	79 f4       	brne	.+30     	; 0xa80 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a62:	e9 81       	ldd	r30, Y+1	; 0x01
     a64:	fa 81       	ldd	r31, Y+2	; 0x02
     a66:	80 85       	ldd	r24, Z+8	; 0x08
     a68:	88 23       	and	r24, r24
     a6a:	a1 f0       	breq	.+40     	; 0xa94 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a6c:	89 81       	ldd	r24, Y+1	; 0x01
     a6e:	9a 81       	ldd	r25, Y+2	; 0x02
     a70:	08 96       	adiw	r24, 0x08	; 8
     a72:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
     a76:	88 23       	and	r24, r24
     a78:	69 f0       	breq	.+26     	; 0xa94 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
     a7a:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
     a7e:	0a c0       	rjmp	.+20     	; 0xa94 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     a80:	89 81       	ldd	r24, Y+1	; 0x01
     a82:	9a 81       	ldd	r25, Y+2	; 0x02
     a84:	08 96       	adiw	r24, 0x08	; 8
     a86:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     a8a:	89 81       	ldd	r24, Y+1	; 0x01
     a8c:	9a 81       	ldd	r25, Y+2	; 0x02
     a8e:	41 96       	adiw	r24, 0x11	; 17
     a90:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     a94:	0f 90       	pop	r0
     a96:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
     a98:	81 e0       	ldi	r24, 0x01	; 1
}
     a9a:	0f 90       	pop	r0
     a9c:	0f 90       	pop	r0
     a9e:	0f 90       	pop	r0
     aa0:	0f 90       	pop	r0
     aa2:	0f 90       	pop	r0
     aa4:	cf 91       	pop	r28
     aa6:	df 91       	pop	r29
     aa8:	08 95       	ret

00000aaa <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     aaa:	0f 93       	push	r16
     aac:	1f 93       	push	r17
     aae:	df 93       	push	r29
     ab0:	cf 93       	push	r28
     ab2:	cd b7       	in	r28, 0x3d	; 61
     ab4:	de b7       	in	r29, 0x3e	; 62
     ab6:	29 97       	sbiw	r28, 0x09	; 9
     ab8:	0f b6       	in	r0, 0x3f	; 63
     aba:	f8 94       	cli
     abc:	de bf       	out	0x3e, r29	; 62
     abe:	0f be       	out	0x3f, r0	; 63
     ac0:	cd bf       	out	0x3d, r28	; 61
     ac2:	8f 83       	std	Y+7, r24	; 0x07
     ac4:	68 87       	std	Y+8, r22	; 0x08
     ac6:	49 87       	std	Y+9, r20	; 0x09
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ac8:	8f 81       	ldd	r24, Y+7	; 0x07
     aca:	28 2f       	mov	r18, r24
     acc:	30 e0       	ldi	r19, 0x00	; 0
     ace:	88 85       	ldd	r24, Y+8	; 0x08
     ad0:	88 2f       	mov	r24, r24
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	ac 01       	movw	r20, r24
     ad6:	24 9f       	mul	r18, r20
     ad8:	c0 01       	movw	r24, r0
     ada:	25 9f       	mul	r18, r21
     adc:	90 0d       	add	r25, r0
     ade:	34 9f       	mul	r19, r20
     ae0:	90 0d       	add	r25, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	9c 83       	std	Y+4, r25	; 0x04
     ae6:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
     ae8:	8b 81       	ldd	r24, Y+3	; 0x03
     aea:	9c 81       	ldd	r25, Y+4	; 0x04
     aec:	4f 96       	adiw	r24, 0x1f	; 31
     aee:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     af2:	9e 83       	std	Y+6, r25	; 0x06
     af4:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
     af6:	8d 81       	ldd	r24, Y+5	; 0x05
     af8:	9e 81       	ldd	r25, Y+6	; 0x06
     afa:	00 97       	sbiw	r24, 0x00	; 0
     afc:	a1 f0       	breq	.+40     	; 0xb26 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
     afe:	8d 81       	ldd	r24, Y+5	; 0x05
     b00:	9e 81       	ldd	r25, Y+6	; 0x06
     b02:	9a 83       	std	Y+2, r25	; 0x02
     b04:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     b06:	89 81       	ldd	r24, Y+1	; 0x01
     b08:	9a 81       	ldd	r25, Y+2	; 0x02
     b0a:	4f 96       	adiw	r24, 0x1f	; 31
     b0c:	9a 83       	std	Y+2, r25	; 0x02
     b0e:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     b10:	29 81       	ldd	r18, Y+1	; 0x01
     b12:	3a 81       	ldd	r19, Y+2	; 0x02
     b14:	ed 81       	ldd	r30, Y+5	; 0x05
     b16:	fe 81       	ldd	r31, Y+6	; 0x06
     b18:	8f 81       	ldd	r24, Y+7	; 0x07
     b1a:	68 85       	ldd	r22, Y+8	; 0x08
     b1c:	a9 01       	movw	r20, r18
     b1e:	29 85       	ldd	r18, Y+9	; 0x09
     b20:	8f 01       	movw	r16, r30
     b22:	0e 94 a0 05 	call	0xb40	; 0xb40 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
     b26:	8d 81       	ldd	r24, Y+5	; 0x05
     b28:	9e 81       	ldd	r25, Y+6	; 0x06
	}
     b2a:	29 96       	adiw	r28, 0x09	; 9
     b2c:	0f b6       	in	r0, 0x3f	; 63
     b2e:	f8 94       	cli
     b30:	de bf       	out	0x3e, r29	; 62
     b32:	0f be       	out	0x3f, r0	; 63
     b34:	cd bf       	out	0x3d, r28	; 61
     b36:	cf 91       	pop	r28
     b38:	df 91       	pop	r29
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	08 95       	ret

00000b40 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
     b40:	0f 93       	push	r16
     b42:	1f 93       	push	r17
     b44:	df 93       	push	r29
     b46:	cf 93       	push	r28
     b48:	cd b7       	in	r28, 0x3d	; 61
     b4a:	de b7       	in	r29, 0x3e	; 62
     b4c:	27 97       	sbiw	r28, 0x07	; 7
     b4e:	0f b6       	in	r0, 0x3f	; 63
     b50:	f8 94       	cli
     b52:	de bf       	out	0x3e, r29	; 62
     b54:	0f be       	out	0x3f, r0	; 63
     b56:	cd bf       	out	0x3d, r28	; 61
     b58:	89 83       	std	Y+1, r24	; 0x01
     b5a:	6a 83       	std	Y+2, r22	; 0x02
     b5c:	5c 83       	std	Y+4, r21	; 0x04
     b5e:	4b 83       	std	Y+3, r20	; 0x03
     b60:	2d 83       	std	Y+5, r18	; 0x05
     b62:	1f 83       	std	Y+7, r17	; 0x07
     b64:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     b66:	8a 81       	ldd	r24, Y+2	; 0x02
     b68:	88 23       	and	r24, r24
     b6a:	39 f4       	brne	.+14     	; 0xb7a <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     b6c:	8e 81       	ldd	r24, Y+6	; 0x06
     b6e:	9f 81       	ldd	r25, Y+7	; 0x07
     b70:	ee 81       	ldd	r30, Y+6	; 0x06
     b72:	ff 81       	ldd	r31, Y+7	; 0x07
     b74:	91 83       	std	Z+1, r25	; 0x01
     b76:	80 83       	st	Z, r24
     b78:	06 c0       	rjmp	.+12     	; 0xb86 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     b7a:	8b 81       	ldd	r24, Y+3	; 0x03
     b7c:	9c 81       	ldd	r25, Y+4	; 0x04
     b7e:	ee 81       	ldd	r30, Y+6	; 0x06
     b80:	ff 81       	ldd	r31, Y+7	; 0x07
     b82:	91 83       	std	Z+1, r25	; 0x01
     b84:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     b86:	ee 81       	ldd	r30, Y+6	; 0x06
     b88:	ff 81       	ldd	r31, Y+7	; 0x07
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     b8e:	ee 81       	ldd	r30, Y+6	; 0x06
     b90:	ff 81       	ldd	r31, Y+7	; 0x07
     b92:	8a 81       	ldd	r24, Y+2	; 0x02
     b94:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     b96:	8e 81       	ldd	r24, Y+6	; 0x06
     b98:	9f 81       	ldd	r25, Y+7	; 0x07
     b9a:	61 e0       	ldi	r22, 0x01	; 1
     b9c:	0e 94 cf 04 	call	0x99e	; 0x99e <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
     ba0:	27 96       	adiw	r28, 0x07	; 7
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	de bf       	out	0x3e, r29	; 62
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	cd bf       	out	0x3d, r28	; 61
     bac:	cf 91       	pop	r28
     bae:	df 91       	pop	r29
     bb0:	1f 91       	pop	r17
     bb2:	0f 91       	pop	r16
     bb4:	08 95       	ret

00000bb6 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     bb6:	df 93       	push	r29
     bb8:	cf 93       	push	r28
     bba:	cd b7       	in	r28, 0x3d	; 61
     bbc:	de b7       	in	r29, 0x3e	; 62
     bbe:	2f 97       	sbiw	r28, 0x0f	; 15
     bc0:	0f b6       	in	r0, 0x3f	; 63
     bc2:	f8 94       	cli
     bc4:	de bf       	out	0x3e, r29	; 62
     bc6:	0f be       	out	0x3f, r0	; 63
     bc8:	cd bf       	out	0x3d, r28	; 61
     bca:	99 87       	std	Y+9, r25	; 0x09
     bcc:	88 87       	std	Y+8, r24	; 0x08
     bce:	7b 87       	std	Y+11, r23	; 0x0b
     bd0:	6a 87       	std	Y+10, r22	; 0x0a
     bd2:	5d 87       	std	Y+13, r21	; 0x0d
     bd4:	4c 87       	std	Y+12, r20	; 0x0c
     bd6:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     bd8:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
     bda:	88 85       	ldd	r24, Y+8	; 0x08
     bdc:	99 85       	ldd	r25, Y+9	; 0x09
     bde:	9a 83       	std	Y+2, r25	; 0x02
     be0:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     be8:	e9 81       	ldd	r30, Y+1	; 0x01
     bea:	fa 81       	ldd	r31, Y+2	; 0x02
     bec:	92 8d       	ldd	r25, Z+26	; 0x1a
     bee:	e9 81       	ldd	r30, Y+1	; 0x01
     bf0:	fa 81       	ldd	r31, Y+2	; 0x02
     bf2:	83 8d       	ldd	r24, Z+27	; 0x1b
     bf4:	98 17       	cp	r25, r24
     bf6:	18 f0       	brcs	.+6      	; 0xbfe <xQueueGenericSend+0x48>
     bf8:	8e 85       	ldd	r24, Y+14	; 0x0e
     bfa:	82 30       	cpi	r24, 0x02	; 2
     bfc:	11 f5       	brne	.+68     	; 0xc42 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     bfe:	89 81       	ldd	r24, Y+1	; 0x01
     c00:	9a 81       	ldd	r25, Y+2	; 0x02
     c02:	2a 85       	ldd	r18, Y+10	; 0x0a
     c04:	3b 85       	ldd	r19, Y+11	; 0x0b
     c06:	b9 01       	movw	r22, r18
     c08:	4e 85       	ldd	r20, Y+14	; 0x0e
     c0a:	0e 94 31 0a 	call	0x1462	; 0x1462 <prvCopyDataToQueue>
     c0e:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c10:	e9 81       	ldd	r30, Y+1	; 0x01
     c12:	fa 81       	ldd	r31, Y+2	; 0x02
     c14:	81 89       	ldd	r24, Z+17	; 0x11
     c16:	88 23       	and	r24, r24
     c18:	51 f0       	breq	.+20     	; 0xc2e <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	41 96       	adiw	r24, 0x11	; 17
     c20:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
     c24:	88 23       	and	r24, r24
     c26:	41 f0       	breq	.+16     	; 0xc38 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     c28:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
     c2c:	05 c0       	rjmp	.+10     	; 0xc38 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     c2e:	8b 81       	ldd	r24, Y+3	; 0x03
     c30:	88 23       	and	r24, r24
     c32:	11 f0       	breq	.+4      	; 0xc38 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     c34:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     c38:	0f 90       	pop	r0
     c3a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	8f 87       	std	Y+15, r24	; 0x0f
     c40:	5c c0       	rjmp	.+184    	; 0xcfa <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     c42:	8c 85       	ldd	r24, Y+12	; 0x0c
     c44:	9d 85       	ldd	r25, Y+13	; 0x0d
     c46:	00 97       	sbiw	r24, 0x00	; 0
     c48:	21 f4       	brne	.+8      	; 0xc52 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c4a:	0f 90       	pop	r0
     c4c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     c4e:	1f 86       	std	Y+15, r1	; 0x0f
     c50:	54 c0       	rjmp	.+168    	; 0xcfa <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
     c52:	8c 81       	ldd	r24, Y+4	; 0x04
     c54:	88 23       	and	r24, r24
     c56:	31 f4       	brne	.+12     	; 0xc64 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
     c58:	ce 01       	movw	r24, r28
     c5a:	05 96       	adiw	r24, 0x05	; 5
     c5c:	0e 94 20 15 	call	0x2a40	; 0x2a40 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     c64:	0f 90       	pop	r0
     c66:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c68:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     c6c:	0f b6       	in	r0, 0x3f	; 63
     c6e:	f8 94       	cli
     c70:	0f 92       	push	r0
     c72:	e9 81       	ldd	r30, Y+1	; 0x01
     c74:	fa 81       	ldd	r31, Y+2	; 0x02
     c76:	85 8d       	ldd	r24, Z+29	; 0x1d
     c78:	8f 3f       	cpi	r24, 0xFF	; 255
     c7a:	19 f4       	brne	.+6      	; 0xc82 <xQueueGenericSend+0xcc>
     c7c:	e9 81       	ldd	r30, Y+1	; 0x01
     c7e:	fa 81       	ldd	r31, Y+2	; 0x02
     c80:	15 8e       	std	Z+29, r1	; 0x1d
     c82:	e9 81       	ldd	r30, Y+1	; 0x01
     c84:	fa 81       	ldd	r31, Y+2	; 0x02
     c86:	86 8d       	ldd	r24, Z+30	; 0x1e
     c88:	8f 3f       	cpi	r24, 0xFF	; 255
     c8a:	19 f4       	brne	.+6      	; 0xc92 <xQueueGenericSend+0xdc>
     c8c:	e9 81       	ldd	r30, Y+1	; 0x01
     c8e:	fa 81       	ldd	r31, Y+2	; 0x02
     c90:	16 8e       	std	Z+30, r1	; 0x1e
     c92:	0f 90       	pop	r0
     c94:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c96:	ce 01       	movw	r24, r28
     c98:	05 96       	adiw	r24, 0x05	; 5
     c9a:	9e 01       	movw	r18, r28
     c9c:	24 5f       	subi	r18, 0xF4	; 244
     c9e:	3f 4f       	sbci	r19, 0xFF	; 255
     ca0:	b9 01       	movw	r22, r18
     ca2:	0e 94 39 15 	call	0x2a72	; 0x2a72 <xTaskCheckForTimeOut>
     ca6:	88 23       	and	r24, r24
     ca8:	09 f5       	brne	.+66     	; 0xcec <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     caa:	89 81       	ldd	r24, Y+1	; 0x01
     cac:	9a 81       	ldd	r25, Y+2	; 0x02
     cae:	0e 94 ad 0b 	call	0x175a	; 0x175a <prvIsQueueFull>
     cb2:	88 23       	and	r24, r24
     cb4:	a1 f0       	breq	.+40     	; 0xcde <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     cb6:	89 81       	ldd	r24, Y+1	; 0x01
     cb8:	9a 81       	ldd	r25, Y+2	; 0x02
     cba:	08 96       	adiw	r24, 0x08	; 8
     cbc:	2c 85       	ldd	r18, Y+12	; 0x0c
     cbe:	3d 85       	ldd	r19, Y+13	; 0x0d
     cc0:	b9 01       	movw	r22, r18
     cc2:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     cc6:	89 81       	ldd	r24, Y+1	; 0x01
     cc8:	9a 81       	ldd	r25, Y+2	; 0x02
     cca:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     cce:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
     cd2:	88 23       	and	r24, r24
     cd4:	09 f0       	breq	.+2      	; 0xcd8 <xQueueGenericSend+0x122>
     cd6:	85 cf       	rjmp	.-246    	; 0xbe2 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
     cd8:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
     cdc:	82 cf       	rjmp	.-252    	; 0xbe2 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     cde:	89 81       	ldd	r24, Y+1	; 0x01
     ce0:	9a 81       	ldd	r25, Y+2	; 0x02
     ce2:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     ce6:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
     cea:	7b cf       	rjmp	.-266    	; 0xbe2 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	9a 81       	ldd	r25, Y+2	; 0x02
     cf0:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     cf4:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     cf8:	1f 86       	std	Y+15, r1	; 0x0f
     cfa:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
     cfc:	2f 96       	adiw	r28, 0x0f	; 15
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	de bf       	out	0x3e, r29	; 62
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	cd bf       	out	0x3d, r28	; 61
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	cd b7       	in	r28, 0x3d	; 61
     d14:	de b7       	in	r29, 0x3e	; 62
     d16:	2d 97       	sbiw	r28, 0x0d	; 13
     d18:	0f b6       	in	r0, 0x3f	; 63
     d1a:	f8 94       	cli
     d1c:	de bf       	out	0x3e, r29	; 62
     d1e:	0f be       	out	0x3f, r0	; 63
     d20:	cd bf       	out	0x3d, r28	; 61
     d22:	98 87       	std	Y+8, r25	; 0x08
     d24:	8f 83       	std	Y+7, r24	; 0x07
     d26:	7a 87       	std	Y+10, r23	; 0x0a
     d28:	69 87       	std	Y+9, r22	; 0x09
     d2a:	5c 87       	std	Y+12, r21	; 0x0c
     d2c:	4b 87       	std	Y+11, r20	; 0x0b
     d2e:	2d 87       	std	Y+13, r18	; 0x0d
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
     d30:	8f 81       	ldd	r24, Y+7	; 0x07
     d32:	98 85       	ldd	r25, Y+8	; 0x08
     d34:	9c 83       	std	Y+4, r25	; 0x04
     d36:	8b 83       	std	Y+3, r24	; 0x03
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     d38:	1d 82       	std	Y+5, r1	; 0x05
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	92 8d       	ldd	r25, Z+26	; 0x1a
     d40:	eb 81       	ldd	r30, Y+3	; 0x03
     d42:	fc 81       	ldd	r31, Y+4	; 0x04
     d44:	83 8d       	ldd	r24, Z+27	; 0x1b
     d46:	98 17       	cp	r25, r24
     d48:	18 f0       	brcs	.+6      	; 0xd50 <xQueueGenericSendFromISR+0x42>
     d4a:	8d 85       	ldd	r24, Y+13	; 0x0d
     d4c:	82 30       	cpi	r24, 0x02	; 2
     d4e:	81 f5       	brne	.+96     	; 0xdb0 <xQueueGenericSendFromISR+0xa2>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     d50:	eb 81       	ldd	r30, Y+3	; 0x03
     d52:	fc 81       	ldd	r31, Y+4	; 0x04
     d54:	86 8d       	ldd	r24, Z+30	; 0x1e
     d56:	8a 83       	std	Y+2, r24	; 0x02
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
     d58:	eb 81       	ldd	r30, Y+3	; 0x03
     d5a:	fc 81       	ldd	r31, Y+4	; 0x04
     d5c:	82 8d       	ldd	r24, Z+26	; 0x1a
     d5e:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d60:	8b 81       	ldd	r24, Y+3	; 0x03
     d62:	9c 81       	ldd	r25, Y+4	; 0x04
     d64:	29 85       	ldd	r18, Y+9	; 0x09
     d66:	3a 85       	ldd	r19, Y+10	; 0x0a
     d68:	b9 01       	movw	r22, r18
     d6a:	4d 85       	ldd	r20, Y+13	; 0x0d
     d6c:	0e 94 31 0a 	call	0x1462	; 0x1462 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     d70:	8a 81       	ldd	r24, Y+2	; 0x02
     d72:	8f 3f       	cpi	r24, 0xFF	; 255
     d74:	a9 f4       	brne	.+42     	; 0xda0 <xQueueGenericSendFromISR+0x92>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d76:	eb 81       	ldd	r30, Y+3	; 0x03
     d78:	fc 81       	ldd	r31, Y+4	; 0x04
     d7a:	81 89       	ldd	r24, Z+17	; 0x11
     d7c:	88 23       	and	r24, r24
     d7e:	a9 f0       	breq	.+42     	; 0xdaa <xQueueGenericSendFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d80:	8b 81       	ldd	r24, Y+3	; 0x03
     d82:	9c 81       	ldd	r25, Y+4	; 0x04
     d84:	41 96       	adiw	r24, 0x11	; 17
     d86:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
     d8a:	88 23       	and	r24, r24
     d8c:	71 f0       	breq	.+28     	; 0xdaa <xQueueGenericSendFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     d8e:	8b 85       	ldd	r24, Y+11	; 0x0b
     d90:	9c 85       	ldd	r25, Y+12	; 0x0c
     d92:	00 97       	sbiw	r24, 0x00	; 0
     d94:	51 f0       	breq	.+20     	; 0xdaa <xQueueGenericSendFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     d96:	eb 85       	ldd	r30, Y+11	; 0x0b
     d98:	fc 85       	ldd	r31, Y+12	; 0x0c
     d9a:	81 e0       	ldi	r24, 0x01	; 1
     d9c:	80 83       	st	Z, r24
     d9e:	05 c0       	rjmp	.+10     	; 0xdaa <xQueueGenericSendFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     da0:	8a 81       	ldd	r24, Y+2	; 0x02
     da2:	8f 5f       	subi	r24, 0xFF	; 255
     da4:	eb 81       	ldd	r30, Y+3	; 0x03
     da6:	fc 81       	ldd	r31, Y+4	; 0x04
     da8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	8e 83       	std	Y+6, r24	; 0x06
     dae:	01 c0       	rjmp	.+2      	; 0xdb2 <xQueueGenericSendFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     db0:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     db2:	8e 81       	ldd	r24, Y+6	; 0x06
}
     db4:	2d 96       	adiw	r28, 0x0d	; 13
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	f8 94       	cli
     dba:	de bf       	out	0x3e, r29	; 62
     dbc:	0f be       	out	0x3f, r0	; 63
     dbe:	cd bf       	out	0x3d, r28	; 61
     dc0:	cf 91       	pop	r28
     dc2:	df 91       	pop	r29
     dc4:	08 95       	ret

00000dc6 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     dc6:	df 93       	push	r29
     dc8:	cf 93       	push	r28
     dca:	cd b7       	in	r28, 0x3d	; 61
     dcc:	de b7       	in	r29, 0x3e	; 62
     dce:	2a 97       	sbiw	r28, 0x0a	; 10
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	de bf       	out	0x3e, r29	; 62
     dd6:	0f be       	out	0x3f, r0	; 63
     dd8:	cd bf       	out	0x3d, r28	; 61
     dda:	98 87       	std	Y+8, r25	; 0x08
     ddc:	8f 83       	std	Y+7, r24	; 0x07
     dde:	7a 87       	std	Y+10, r23	; 0x0a
     de0:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
     de2:	8f 81       	ldd	r24, Y+7	; 0x07
     de4:	98 85       	ldd	r25, Y+8	; 0x08
     de6:	9c 83       	std	Y+4, r25	; 0x04
     de8:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     dea:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     dec:	eb 81       	ldd	r30, Y+3	; 0x03
     dee:	fc 81       	ldd	r31, Y+4	; 0x04
     df0:	82 8d       	ldd	r24, Z+26	; 0x1a
     df2:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
     df4:	eb 81       	ldd	r30, Y+3	; 0x03
     df6:	fc 81       	ldd	r31, Y+4	; 0x04
     df8:	93 8d       	ldd	r25, Z+27	; 0x1b
     dfa:	8a 81       	ldd	r24, Y+2	; 0x02
     dfc:	89 17       	cp	r24, r25
     dfe:	48 f5       	brcc	.+82     	; 0xe52 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     e00:	eb 81       	ldd	r30, Y+3	; 0x03
     e02:	fc 81       	ldd	r31, Y+4	; 0x04
     e04:	86 8d       	ldd	r24, Z+30	; 0x1e
     e06:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     e08:	8a 81       	ldd	r24, Y+2	; 0x02
     e0a:	8f 5f       	subi	r24, 0xFF	; 255
     e0c:	eb 81       	ldd	r30, Y+3	; 0x03
     e0e:	fc 81       	ldd	r31, Y+4	; 0x04
     e10:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     e12:	89 81       	ldd	r24, Y+1	; 0x01
     e14:	8f 3f       	cpi	r24, 0xFF	; 255
     e16:	a9 f4       	brne	.+42     	; 0xe42 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e18:	eb 81       	ldd	r30, Y+3	; 0x03
     e1a:	fc 81       	ldd	r31, Y+4	; 0x04
     e1c:	81 89       	ldd	r24, Z+17	; 0x11
     e1e:	88 23       	and	r24, r24
     e20:	a9 f0       	breq	.+42     	; 0xe4c <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e22:	8b 81       	ldd	r24, Y+3	; 0x03
     e24:	9c 81       	ldd	r25, Y+4	; 0x04
     e26:	41 96       	adiw	r24, 0x11	; 17
     e28:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
     e2c:	88 23       	and	r24, r24
     e2e:	71 f0       	breq	.+28     	; 0xe4c <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     e30:	89 85       	ldd	r24, Y+9	; 0x09
     e32:	9a 85       	ldd	r25, Y+10	; 0x0a
     e34:	00 97       	sbiw	r24, 0x00	; 0
     e36:	51 f0       	breq	.+20     	; 0xe4c <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     e38:	e9 85       	ldd	r30, Y+9	; 0x09
     e3a:	fa 85       	ldd	r31, Y+10	; 0x0a
     e3c:	81 e0       	ldi	r24, 0x01	; 1
     e3e:	80 83       	st	Z, r24
     e40:	05 c0       	rjmp	.+10     	; 0xe4c <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     e42:	89 81       	ldd	r24, Y+1	; 0x01
     e44:	8f 5f       	subi	r24, 0xFF	; 255
     e46:	eb 81       	ldd	r30, Y+3	; 0x03
     e48:	fc 81       	ldd	r31, Y+4	; 0x04
     e4a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	8e 83       	std	Y+6, r24	; 0x06
     e50:	01 c0       	rjmp	.+2      	; 0xe54 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     e52:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
     e54:	8e 81       	ldd	r24, Y+6	; 0x06
}
     e56:	2a 96       	adiw	r28, 0x0a	; 10
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	de bf       	out	0x3e, r29	; 62
     e5e:	0f be       	out	0x3f, r0	; 63
     e60:	cd bf       	out	0x3d, r28	; 61
     e62:	cf 91       	pop	r28
     e64:	df 91       	pop	r29
     e66:	08 95       	ret

00000e68 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
     e68:	df 93       	push	r29
     e6a:	cf 93       	push	r28
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	2e 97       	sbiw	r28, 0x0e	; 14
     e72:	0f b6       	in	r0, 0x3f	; 63
     e74:	f8 94       	cli
     e76:	de bf       	out	0x3e, r29	; 62
     e78:	0f be       	out	0x3f, r0	; 63
     e7a:	cd bf       	out	0x3d, r28	; 61
     e7c:	99 87       	std	Y+9, r25	; 0x09
     e7e:	88 87       	std	Y+8, r24	; 0x08
     e80:	7b 87       	std	Y+11, r23	; 0x0b
     e82:	6a 87       	std	Y+10, r22	; 0x0a
     e84:	5d 87       	std	Y+13, r21	; 0x0d
     e86:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
     e88:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
     e8a:	88 85       	ldd	r24, Y+8	; 0x08
     e8c:	99 85       	ldd	r25, Y+9	; 0x09
     e8e:	9b 83       	std	Y+3, r25	; 0x03
     e90:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     e92:	0f b6       	in	r0, 0x3f	; 63
     e94:	f8 94       	cli
     e96:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     e98:	ea 81       	ldd	r30, Y+2	; 0x02
     e9a:	fb 81       	ldd	r31, Y+3	; 0x03
     e9c:	82 8d       	ldd	r24, Z+26	; 0x1a
     e9e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ea0:	89 81       	ldd	r24, Y+1	; 0x01
     ea2:	88 23       	and	r24, r24
     ea4:	f9 f0       	breq	.+62     	; 0xee4 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ea6:	8a 81       	ldd	r24, Y+2	; 0x02
     ea8:	9b 81       	ldd	r25, Y+3	; 0x03
     eaa:	2a 85       	ldd	r18, Y+10	; 0x0a
     eac:	3b 85       	ldd	r19, Y+11	; 0x0b
     eae:	b9 01       	movw	r22, r18
     eb0:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     eb4:	89 81       	ldd	r24, Y+1	; 0x01
     eb6:	81 50       	subi	r24, 0x01	; 1
     eb8:	ea 81       	ldd	r30, Y+2	; 0x02
     eba:	fb 81       	ldd	r31, Y+3	; 0x03
     ebc:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ebe:	ea 81       	ldd	r30, Y+2	; 0x02
     ec0:	fb 81       	ldd	r31, Y+3	; 0x03
     ec2:	80 85       	ldd	r24, Z+8	; 0x08
     ec4:	88 23       	and	r24, r24
     ec6:	49 f0       	breq	.+18     	; 0xeda <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ec8:	8a 81       	ldd	r24, Y+2	; 0x02
     eca:	9b 81       	ldd	r25, Y+3	; 0x03
     ecc:	08 96       	adiw	r24, 0x08	; 8
     ece:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
     ed2:	88 23       	and	r24, r24
     ed4:	11 f0       	breq	.+4      	; 0xeda <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
     ed6:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
     eda:	0f 90       	pop	r0
     edc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ede:	81 e0       	ldi	r24, 0x01	; 1
     ee0:	8e 87       	std	Y+14, r24	; 0x0e
     ee2:	63 c0       	rjmp	.+198    	; 0xfaa <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     ee4:	8c 85       	ldd	r24, Y+12	; 0x0c
     ee6:	9d 85       	ldd	r25, Y+13	; 0x0d
     ee8:	00 97       	sbiw	r24, 0x00	; 0
     eea:	21 f4       	brne	.+8      	; 0xef4 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     eec:	0f 90       	pop	r0
     eee:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     ef0:	1e 86       	std	Y+14, r1	; 0x0e
     ef2:	5b c0       	rjmp	.+182    	; 0xfaa <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
     ef4:	8c 81       	ldd	r24, Y+4	; 0x04
     ef6:	88 23       	and	r24, r24
     ef8:	31 f4       	brne	.+12     	; 0xf06 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
     efa:	ce 01       	movw	r24, r28
     efc:	05 96       	adiw	r24, 0x05	; 5
     efe:	0e 94 20 15 	call	0x2a40	; 0x2a40 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f06:	0f 90       	pop	r0
     f08:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f0a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	f8 94       	cli
     f12:	0f 92       	push	r0
     f14:	ea 81       	ldd	r30, Y+2	; 0x02
     f16:	fb 81       	ldd	r31, Y+3	; 0x03
     f18:	85 8d       	ldd	r24, Z+29	; 0x1d
     f1a:	8f 3f       	cpi	r24, 0xFF	; 255
     f1c:	19 f4       	brne	.+6      	; 0xf24 <xQueueReceive+0xbc>
     f1e:	ea 81       	ldd	r30, Y+2	; 0x02
     f20:	fb 81       	ldd	r31, Y+3	; 0x03
     f22:	15 8e       	std	Z+29, r1	; 0x1d
     f24:	ea 81       	ldd	r30, Y+2	; 0x02
     f26:	fb 81       	ldd	r31, Y+3	; 0x03
     f28:	86 8d       	ldd	r24, Z+30	; 0x1e
     f2a:	8f 3f       	cpi	r24, 0xFF	; 255
     f2c:	19 f4       	brne	.+6      	; 0xf34 <xQueueReceive+0xcc>
     f2e:	ea 81       	ldd	r30, Y+2	; 0x02
     f30:	fb 81       	ldd	r31, Y+3	; 0x03
     f32:	16 8e       	std	Z+30, r1	; 0x1e
     f34:	0f 90       	pop	r0
     f36:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f38:	ce 01       	movw	r24, r28
     f3a:	05 96       	adiw	r24, 0x05	; 5
     f3c:	9e 01       	movw	r18, r28
     f3e:	24 5f       	subi	r18, 0xF4	; 244
     f40:	3f 4f       	sbci	r19, 0xFF	; 255
     f42:	b9 01       	movw	r22, r18
     f44:	0e 94 39 15 	call	0x2a72	; 0x2a72 <xTaskCheckForTimeOut>
     f48:	88 23       	and	r24, r24
     f4a:	09 f5       	brne	.+66     	; 0xf8e <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f4c:	8a 81       	ldd	r24, Y+2	; 0x02
     f4e:	9b 81       	ldd	r25, Y+3	; 0x03
     f50:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <prvIsQueueEmpty>
     f54:	88 23       	and	r24, r24
     f56:	a1 f0       	breq	.+40     	; 0xf80 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f58:	8a 81       	ldd	r24, Y+2	; 0x02
     f5a:	9b 81       	ldd	r25, Y+3	; 0x03
     f5c:	41 96       	adiw	r24, 0x11	; 17
     f5e:	2c 85       	ldd	r18, Y+12	; 0x0c
     f60:	3d 85       	ldd	r19, Y+13	; 0x0d
     f62:	b9 01       	movw	r22, r18
     f64:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f68:	8a 81       	ldd	r24, Y+2	; 0x02
     f6a:	9b 81       	ldd	r25, Y+3	; 0x03
     f6c:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f70:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
     f74:	88 23       	and	r24, r24
     f76:	09 f0       	breq	.+2      	; 0xf7a <xQueueReceive+0x112>
     f78:	8c cf       	rjmp	.-232    	; 0xe92 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     f7a:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
     f7e:	89 cf       	rjmp	.-238    	; 0xe92 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
     f80:	8a 81       	ldd	r24, Y+2	; 0x02
     f82:	9b 81       	ldd	r25, Y+3	; 0x03
     f84:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f88:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
     f8c:	82 cf       	rjmp	.-252    	; 0xe92 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
     f8e:	8a 81       	ldd	r24, Y+2	; 0x02
     f90:	9b 81       	ldd	r25, Y+3	; 0x03
     f92:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f96:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	9b 81       	ldd	r25, Y+3	; 0x03
     f9e:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <prvIsQueueEmpty>
     fa2:	88 23       	and	r24, r24
     fa4:	09 f4       	brne	.+2      	; 0xfa8 <xQueueReceive+0x140>
     fa6:	75 cf       	rjmp	.-278    	; 0xe92 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     fa8:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
     faa:	8e 85       	ldd	r24, Y+14	; 0x0e
}
     fac:	2e 96       	adiw	r28, 0x0e	; 14
     fae:	0f b6       	in	r0, 0x3f	; 63
     fb0:	f8 94       	cli
     fb2:	de bf       	out	0x3e, r29	; 62
     fb4:	0f be       	out	0x3f, r0	; 63
     fb6:	cd bf       	out	0x3d, r28	; 61
     fb8:	cf 91       	pop	r28
     fba:	df 91       	pop	r29
     fbc:	08 95       	ret

00000fbe <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
     fbe:	df 93       	push	r29
     fc0:	cf 93       	push	r28
     fc2:	cd b7       	in	r28, 0x3d	; 61
     fc4:	de b7       	in	r29, 0x3e	; 62
     fc6:	2c 97       	sbiw	r28, 0x0c	; 12
     fc8:	0f b6       	in	r0, 0x3f	; 63
     fca:	f8 94       	cli
     fcc:	de bf       	out	0x3e, r29	; 62
     fce:	0f be       	out	0x3f, r0	; 63
     fd0:	cd bf       	out	0x3d, r28	; 61
     fd2:	99 87       	std	Y+9, r25	; 0x09
     fd4:	88 87       	std	Y+8, r24	; 0x08
     fd6:	7b 87       	std	Y+11, r23	; 0x0b
     fd8:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
     fda:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
     fdc:	88 85       	ldd	r24, Y+8	; 0x08
     fde:	99 85       	ldd	r25, Y+9	; 0x09
     fe0:	9b 83       	std	Y+3, r25	; 0x03
     fe2:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	f8 94       	cli
     fe8:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
     fea:	ea 81       	ldd	r30, Y+2	; 0x02
     fec:	fb 81       	ldd	r31, Y+3	; 0x03
     fee:	82 8d       	ldd	r24, Z+26	; 0x1a
     ff0:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	88 23       	and	r24, r24
     ff6:	c1 f0       	breq	.+48     	; 0x1028 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
     ff8:	89 81       	ldd	r24, Y+1	; 0x01
     ffa:	81 50       	subi	r24, 0x01	; 1
     ffc:	ea 81       	ldd	r30, Y+2	; 0x02
     ffe:	fb 81       	ldd	r31, Y+3	; 0x03
    1000:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1002:	ea 81       	ldd	r30, Y+2	; 0x02
    1004:	fb 81       	ldd	r31, Y+3	; 0x03
    1006:	80 85       	ldd	r24, Z+8	; 0x08
    1008:	88 23       	and	r24, r24
    100a:	49 f0       	breq	.+18     	; 0x101e <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    100c:	8a 81       	ldd	r24, Y+2	; 0x02
    100e:	9b 81       	ldd	r25, Y+3	; 0x03
    1010:	08 96       	adiw	r24, 0x08	; 8
    1012:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
    1016:	88 23       	and	r24, r24
    1018:	11 f0       	breq	.+4      	; 0x101e <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    101a:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	8c 87       	std	Y+12, r24	; 0x0c
    1026:	63 c0       	rjmp	.+198    	; 0x10ee <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1028:	8a 85       	ldd	r24, Y+10	; 0x0a
    102a:	9b 85       	ldd	r25, Y+11	; 0x0b
    102c:	00 97       	sbiw	r24, 0x00	; 0
    102e:	21 f4       	brne	.+8      	; 0x1038 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1034:	1c 86       	std	Y+12, r1	; 0x0c
    1036:	5b c0       	rjmp	.+182    	; 0x10ee <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    1038:	8c 81       	ldd	r24, Y+4	; 0x04
    103a:	88 23       	and	r24, r24
    103c:	31 f4       	brne	.+12     	; 0x104a <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    103e:	ce 01       	movw	r24, r28
    1040:	05 96       	adiw	r24, 0x05	; 5
    1042:	0e 94 20 15 	call	0x2a40	; 0x2a40 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1046:	81 e0       	ldi	r24, 0x01	; 1
    1048:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    104a:	0f 90       	pop	r0
    104c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    104e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1052:	0f b6       	in	r0, 0x3f	; 63
    1054:	f8 94       	cli
    1056:	0f 92       	push	r0
    1058:	ea 81       	ldd	r30, Y+2	; 0x02
    105a:	fb 81       	ldd	r31, Y+3	; 0x03
    105c:	85 8d       	ldd	r24, Z+29	; 0x1d
    105e:	8f 3f       	cpi	r24, 0xFF	; 255
    1060:	19 f4       	brne	.+6      	; 0x1068 <xQueueSemaphoreTake+0xaa>
    1062:	ea 81       	ldd	r30, Y+2	; 0x02
    1064:	fb 81       	ldd	r31, Y+3	; 0x03
    1066:	15 8e       	std	Z+29, r1	; 0x1d
    1068:	ea 81       	ldd	r30, Y+2	; 0x02
    106a:	fb 81       	ldd	r31, Y+3	; 0x03
    106c:	86 8d       	ldd	r24, Z+30	; 0x1e
    106e:	8f 3f       	cpi	r24, 0xFF	; 255
    1070:	19 f4       	brne	.+6      	; 0x1078 <xQueueSemaphoreTake+0xba>
    1072:	ea 81       	ldd	r30, Y+2	; 0x02
    1074:	fb 81       	ldd	r31, Y+3	; 0x03
    1076:	16 8e       	std	Z+30, r1	; 0x1e
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    107c:	ce 01       	movw	r24, r28
    107e:	05 96       	adiw	r24, 0x05	; 5
    1080:	9e 01       	movw	r18, r28
    1082:	26 5f       	subi	r18, 0xF6	; 246
    1084:	3f 4f       	sbci	r19, 0xFF	; 255
    1086:	b9 01       	movw	r22, r18
    1088:	0e 94 39 15 	call	0x2a72	; 0x2a72 <xTaskCheckForTimeOut>
    108c:	88 23       	and	r24, r24
    108e:	09 f5       	brne	.+66     	; 0x10d2 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1090:	8a 81       	ldd	r24, Y+2	; 0x02
    1092:	9b 81       	ldd	r25, Y+3	; 0x03
    1094:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <prvIsQueueEmpty>
    1098:	88 23       	and	r24, r24
    109a:	a1 f0       	breq	.+40     	; 0x10c4 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    109c:	8a 81       	ldd	r24, Y+2	; 0x02
    109e:	9b 81       	ldd	r25, Y+3	; 0x03
    10a0:	41 96       	adiw	r24, 0x11	; 17
    10a2:	2a 85       	ldd	r18, Y+10	; 0x0a
    10a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    10a6:	b9 01       	movw	r22, r18
    10a8:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    10ac:	8a 81       	ldd	r24, Y+2	; 0x02
    10ae:	9b 81       	ldd	r25, Y+3	; 0x03
    10b0:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    10b4:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    10b8:	88 23       	and	r24, r24
    10ba:	09 f0       	breq	.+2      	; 0x10be <xQueueSemaphoreTake+0x100>
    10bc:	93 cf       	rjmp	.-218    	; 0xfe4 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    10be:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
    10c2:	90 cf       	rjmp	.-224    	; 0xfe4 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    10c4:	8a 81       	ldd	r24, Y+2	; 0x02
    10c6:	9b 81       	ldd	r25, Y+3	; 0x03
    10c8:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    10cc:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    10d0:	89 cf       	rjmp	.-238    	; 0xfe4 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    10d2:	8a 81       	ldd	r24, Y+2	; 0x02
    10d4:	9b 81       	ldd	r25, Y+3	; 0x03
    10d6:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10da:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    10de:	8a 81       	ldd	r24, Y+2	; 0x02
    10e0:	9b 81       	ldd	r25, Y+3	; 0x03
    10e2:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <prvIsQueueEmpty>
    10e6:	88 23       	and	r24, r24
    10e8:	09 f4       	brne	.+2      	; 0x10ec <xQueueSemaphoreTake+0x12e>
    10ea:	7c cf       	rjmp	.-264    	; 0xfe4 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    10ec:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    10ee:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    10f0:	2c 96       	adiw	r28, 0x0c	; 12
    10f2:	0f b6       	in	r0, 0x3f	; 63
    10f4:	f8 94       	cli
    10f6:	de bf       	out	0x3e, r29	; 62
    10f8:	0f be       	out	0x3f, r0	; 63
    10fa:	cd bf       	out	0x3d, r28	; 61
    10fc:	cf 91       	pop	r28
    10fe:	df 91       	pop	r29
    1100:	08 95       	ret

00001102 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1102:	df 93       	push	r29
    1104:	cf 93       	push	r28
    1106:	cd b7       	in	r28, 0x3d	; 61
    1108:	de b7       	in	r29, 0x3e	; 62
    110a:	60 97       	sbiw	r28, 0x10	; 16
    110c:	0f b6       	in	r0, 0x3f	; 63
    110e:	f8 94       	cli
    1110:	de bf       	out	0x3e, r29	; 62
    1112:	0f be       	out	0x3f, r0	; 63
    1114:	cd bf       	out	0x3d, r28	; 61
    1116:	9b 87       	std	Y+11, r25	; 0x0b
    1118:	8a 87       	std	Y+10, r24	; 0x0a
    111a:	7d 87       	std	Y+13, r23	; 0x0d
    111c:	6c 87       	std	Y+12, r22	; 0x0c
    111e:	5f 87       	std	Y+15, r21	; 0x0f
    1120:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    1122:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1124:	8a 85       	ldd	r24, Y+10	; 0x0a
    1126:	9b 85       	ldd	r25, Y+11	; 0x0b
    1128:	9b 83       	std	Y+3, r25	; 0x03
    112a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1132:	ea 81       	ldd	r30, Y+2	; 0x02
    1134:	fb 81       	ldd	r31, Y+3	; 0x03
    1136:	82 8d       	ldd	r24, Z+26	; 0x1a
    1138:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    113a:	89 81       	ldd	r24, Y+1	; 0x01
    113c:	88 23       	and	r24, r24
    113e:	31 f1       	breq	.+76     	; 0x118c <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1140:	ea 81       	ldd	r30, Y+2	; 0x02
    1142:	fb 81       	ldd	r31, Y+3	; 0x03
    1144:	86 81       	ldd	r24, Z+6	; 0x06
    1146:	97 81       	ldd	r25, Z+7	; 0x07
    1148:	9d 83       	std	Y+5, r25	; 0x05
    114a:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    114c:	8a 81       	ldd	r24, Y+2	; 0x02
    114e:	9b 81       	ldd	r25, Y+3	; 0x03
    1150:	2c 85       	ldd	r18, Y+12	; 0x0c
    1152:	3d 85       	ldd	r19, Y+13	; 0x0d
    1154:	b9 01       	movw	r22, r18
    1156:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    115a:	ea 81       	ldd	r30, Y+2	; 0x02
    115c:	fb 81       	ldd	r31, Y+3	; 0x03
    115e:	8c 81       	ldd	r24, Y+4	; 0x04
    1160:	9d 81       	ldd	r25, Y+5	; 0x05
    1162:	97 83       	std	Z+7, r25	; 0x07
    1164:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1166:	ea 81       	ldd	r30, Y+2	; 0x02
    1168:	fb 81       	ldd	r31, Y+3	; 0x03
    116a:	81 89       	ldd	r24, Z+17	; 0x11
    116c:	88 23       	and	r24, r24
    116e:	49 f0       	breq	.+18     	; 0x1182 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1170:	8a 81       	ldd	r24, Y+2	; 0x02
    1172:	9b 81       	ldd	r25, Y+3	; 0x03
    1174:	41 96       	adiw	r24, 0x11	; 17
    1176:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
    117a:	88 23       	and	r24, r24
    117c:	11 f0       	breq	.+4      	; 0x1182 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    117e:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1182:	0f 90       	pop	r0
    1184:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1186:	81 e0       	ldi	r24, 0x01	; 1
    1188:	88 8b       	std	Y+16, r24	; 0x10
    118a:	63 c0       	rjmp	.+198    	; 0x1252 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    118c:	8e 85       	ldd	r24, Y+14	; 0x0e
    118e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1190:	00 97       	sbiw	r24, 0x00	; 0
    1192:	21 f4       	brne	.+8      	; 0x119c <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1194:	0f 90       	pop	r0
    1196:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1198:	18 8a       	std	Y+16, r1	; 0x10
    119a:	5b c0       	rjmp	.+182    	; 0x1252 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    119c:	8e 81       	ldd	r24, Y+6	; 0x06
    119e:	88 23       	and	r24, r24
    11a0:	31 f4       	brne	.+12     	; 0x11ae <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    11a2:	ce 01       	movw	r24, r28
    11a4:	07 96       	adiw	r24, 0x07	; 7
    11a6:	0e 94 20 15 	call	0x2a40	; 0x2a40 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11ae:	0f 90       	pop	r0
    11b0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11b2:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11b6:	0f b6       	in	r0, 0x3f	; 63
    11b8:	f8 94       	cli
    11ba:	0f 92       	push	r0
    11bc:	ea 81       	ldd	r30, Y+2	; 0x02
    11be:	fb 81       	ldd	r31, Y+3	; 0x03
    11c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    11c2:	8f 3f       	cpi	r24, 0xFF	; 255
    11c4:	19 f4       	brne	.+6      	; 0x11cc <xQueuePeek+0xca>
    11c6:	ea 81       	ldd	r30, Y+2	; 0x02
    11c8:	fb 81       	ldd	r31, Y+3	; 0x03
    11ca:	15 8e       	std	Z+29, r1	; 0x1d
    11cc:	ea 81       	ldd	r30, Y+2	; 0x02
    11ce:	fb 81       	ldd	r31, Y+3	; 0x03
    11d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    11d2:	8f 3f       	cpi	r24, 0xFF	; 255
    11d4:	19 f4       	brne	.+6      	; 0x11dc <xQueuePeek+0xda>
    11d6:	ea 81       	ldd	r30, Y+2	; 0x02
    11d8:	fb 81       	ldd	r31, Y+3	; 0x03
    11da:	16 8e       	std	Z+30, r1	; 0x1e
    11dc:	0f 90       	pop	r0
    11de:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11e0:	ce 01       	movw	r24, r28
    11e2:	07 96       	adiw	r24, 0x07	; 7
    11e4:	9e 01       	movw	r18, r28
    11e6:	22 5f       	subi	r18, 0xF2	; 242
    11e8:	3f 4f       	sbci	r19, 0xFF	; 255
    11ea:	b9 01       	movw	r22, r18
    11ec:	0e 94 39 15 	call	0x2a72	; 0x2a72 <xTaskCheckForTimeOut>
    11f0:	88 23       	and	r24, r24
    11f2:	09 f5       	brne	.+66     	; 0x1236 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11f4:	8a 81       	ldd	r24, Y+2	; 0x02
    11f6:	9b 81       	ldd	r25, Y+3	; 0x03
    11f8:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <prvIsQueueEmpty>
    11fc:	88 23       	and	r24, r24
    11fe:	a1 f0       	breq	.+40     	; 0x1228 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1200:	8a 81       	ldd	r24, Y+2	; 0x02
    1202:	9b 81       	ldd	r25, Y+3	; 0x03
    1204:	41 96       	adiw	r24, 0x11	; 17
    1206:	2e 85       	ldd	r18, Y+14	; 0x0e
    1208:	3f 85       	ldd	r19, Y+15	; 0x0f
    120a:	b9 01       	movw	r22, r18
    120c:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1210:	8a 81       	ldd	r24, Y+2	; 0x02
    1212:	9b 81       	ldd	r25, Y+3	; 0x03
    1214:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1218:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    121c:	88 23       	and	r24, r24
    121e:	09 f0       	breq	.+2      	; 0x1222 <xQueuePeek+0x120>
    1220:	85 cf       	rjmp	.-246    	; 0x112c <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    1222:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
    1226:	82 cf       	rjmp	.-252    	; 0x112c <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1228:	8a 81       	ldd	r24, Y+2	; 0x02
    122a:	9b 81       	ldd	r25, Y+3	; 0x03
    122c:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1230:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1234:	7b cf       	rjmp	.-266    	; 0x112c <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1236:	8a 81       	ldd	r24, Y+2	; 0x02
    1238:	9b 81       	ldd	r25, Y+3	; 0x03
    123a:	0e 94 1e 0b 	call	0x163c	; 0x163c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    123e:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1242:	8a 81       	ldd	r24, Y+2	; 0x02
    1244:	9b 81       	ldd	r25, Y+3	; 0x03
    1246:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <prvIsQueueEmpty>
    124a:	88 23       	and	r24, r24
    124c:	09 f4       	brne	.+2      	; 0x1250 <xQueuePeek+0x14e>
    124e:	6e cf       	rjmp	.-292    	; 0x112c <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1250:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1252:	88 89       	ldd	r24, Y+16	; 0x10
}
    1254:	60 96       	adiw	r28, 0x10	; 16
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	de bf       	out	0x3e, r29	; 62
    125c:	0f be       	out	0x3f, r0	; 63
    125e:	cd bf       	out	0x3d, r28	; 61
    1260:	cf 91       	pop	r28
    1262:	df 91       	pop	r29
    1264:	08 95       	ret

00001266 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1266:	df 93       	push	r29
    1268:	cf 93       	push	r28
    126a:	cd b7       	in	r28, 0x3d	; 61
    126c:	de b7       	in	r29, 0x3e	; 62
    126e:	2c 97       	sbiw	r28, 0x0c	; 12
    1270:	0f b6       	in	r0, 0x3f	; 63
    1272:	f8 94       	cli
    1274:	de bf       	out	0x3e, r29	; 62
    1276:	0f be       	out	0x3f, r0	; 63
    1278:	cd bf       	out	0x3d, r28	; 61
    127a:	98 87       	std	Y+8, r25	; 0x08
    127c:	8f 83       	std	Y+7, r24	; 0x07
    127e:	7a 87       	std	Y+10, r23	; 0x0a
    1280:	69 87       	std	Y+9, r22	; 0x09
    1282:	5c 87       	std	Y+12, r21	; 0x0c
    1284:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1286:	8f 81       	ldd	r24, Y+7	; 0x07
    1288:	98 85       	ldd	r25, Y+8	; 0x08
    128a:	9c 83       	std	Y+4, r25	; 0x04
    128c:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    128e:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1290:	eb 81       	ldd	r30, Y+3	; 0x03
    1292:	fc 81       	ldd	r31, Y+4	; 0x04
    1294:	82 8d       	ldd	r24, Z+26	; 0x1a
    1296:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1298:	8a 81       	ldd	r24, Y+2	; 0x02
    129a:	88 23       	and	r24, r24
    129c:	81 f1       	breq	.+96     	; 0x12fe <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    129e:	eb 81       	ldd	r30, Y+3	; 0x03
    12a0:	fc 81       	ldd	r31, Y+4	; 0x04
    12a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    12a4:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	9c 81       	ldd	r25, Y+4	; 0x04
    12aa:	29 85       	ldd	r18, Y+9	; 0x09
    12ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    12ae:	b9 01       	movw	r22, r18
    12b0:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    12b4:	8a 81       	ldd	r24, Y+2	; 0x02
    12b6:	81 50       	subi	r24, 0x01	; 1
    12b8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ba:	fc 81       	ldd	r31, Y+4	; 0x04
    12bc:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    12be:	89 81       	ldd	r24, Y+1	; 0x01
    12c0:	8f 3f       	cpi	r24, 0xFF	; 255
    12c2:	a9 f4       	brne	.+42     	; 0x12ee <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12c4:	eb 81       	ldd	r30, Y+3	; 0x03
    12c6:	fc 81       	ldd	r31, Y+4	; 0x04
    12c8:	80 85       	ldd	r24, Z+8	; 0x08
    12ca:	88 23       	and	r24, r24
    12cc:	a9 f0       	breq	.+42     	; 0x12f8 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12ce:	8b 81       	ldd	r24, Y+3	; 0x03
    12d0:	9c 81       	ldd	r25, Y+4	; 0x04
    12d2:	08 96       	adiw	r24, 0x08	; 8
    12d4:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
    12d8:	88 23       	and	r24, r24
    12da:	71 f0       	breq	.+28     	; 0x12f8 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    12dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    12de:	9c 85       	ldd	r25, Y+12	; 0x0c
    12e0:	00 97       	sbiw	r24, 0x00	; 0
    12e2:	51 f0       	breq	.+20     	; 0x12f8 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    12e4:	eb 85       	ldd	r30, Y+11	; 0x0b
    12e6:	fc 85       	ldd	r31, Y+12	; 0x0c
    12e8:	81 e0       	ldi	r24, 0x01	; 1
    12ea:	80 83       	st	Z, r24
    12ec:	05 c0       	rjmp	.+10     	; 0x12f8 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    12ee:	89 81       	ldd	r24, Y+1	; 0x01
    12f0:	8f 5f       	subi	r24, 0xFF	; 255
    12f2:	eb 81       	ldd	r30, Y+3	; 0x03
    12f4:	fc 81       	ldd	r31, Y+4	; 0x04
    12f6:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	8e 83       	std	Y+6, r24	; 0x06
    12fc:	01 c0       	rjmp	.+2      	; 0x1300 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    12fe:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1300:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1302:	2c 96       	adiw	r28, 0x0c	; 12
    1304:	0f b6       	in	r0, 0x3f	; 63
    1306:	f8 94       	cli
    1308:	de bf       	out	0x3e, r29	; 62
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	cd bf       	out	0x3d, r28	; 61
    130e:	cf 91       	pop	r28
    1310:	df 91       	pop	r29
    1312:	08 95       	ret

00001314 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1314:	df 93       	push	r29
    1316:	cf 93       	push	r28
    1318:	cd b7       	in	r28, 0x3d	; 61
    131a:	de b7       	in	r29, 0x3e	; 62
    131c:	2a 97       	sbiw	r28, 0x0a	; 10
    131e:	0f b6       	in	r0, 0x3f	; 63
    1320:	f8 94       	cli
    1322:	de bf       	out	0x3e, r29	; 62
    1324:	0f be       	out	0x3f, r0	; 63
    1326:	cd bf       	out	0x3d, r28	; 61
    1328:	98 87       	std	Y+8, r25	; 0x08
    132a:	8f 83       	std	Y+7, r24	; 0x07
    132c:	7a 87       	std	Y+10, r23	; 0x0a
    132e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1330:	8f 81       	ldd	r24, Y+7	; 0x07
    1332:	98 85       	ldd	r25, Y+8	; 0x08
    1334:	9a 83       	std	Y+2, r25	; 0x02
    1336:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1338:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    133a:	e9 81       	ldd	r30, Y+1	; 0x01
    133c:	fa 81       	ldd	r31, Y+2	; 0x02
    133e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1340:	88 23       	and	r24, r24
    1342:	b1 f0       	breq	.+44     	; 0x1370 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1344:	e9 81       	ldd	r30, Y+1	; 0x01
    1346:	fa 81       	ldd	r31, Y+2	; 0x02
    1348:	86 81       	ldd	r24, Z+6	; 0x06
    134a:	97 81       	ldd	r25, Z+7	; 0x07
    134c:	9c 83       	std	Y+4, r25	; 0x04
    134e:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1350:	89 81       	ldd	r24, Y+1	; 0x01
    1352:	9a 81       	ldd	r25, Y+2	; 0x02
    1354:	29 85       	ldd	r18, Y+9	; 0x09
    1356:	3a 85       	ldd	r19, Y+10	; 0x0a
    1358:	b9 01       	movw	r22, r18
    135a:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    135e:	e9 81       	ldd	r30, Y+1	; 0x01
    1360:	fa 81       	ldd	r31, Y+2	; 0x02
    1362:	8b 81       	ldd	r24, Y+3	; 0x03
    1364:	9c 81       	ldd	r25, Y+4	; 0x04
    1366:	97 83       	std	Z+7, r25	; 0x07
    1368:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	8e 83       	std	Y+6, r24	; 0x06
    136e:	01 c0       	rjmp	.+2      	; 0x1372 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1370:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1372:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1374:	2a 96       	adiw	r28, 0x0a	; 10
    1376:	0f b6       	in	r0, 0x3f	; 63
    1378:	f8 94       	cli
    137a:	de bf       	out	0x3e, r29	; 62
    137c:	0f be       	out	0x3f, r0	; 63
    137e:	cd bf       	out	0x3d, r28	; 61
    1380:	cf 91       	pop	r28
    1382:	df 91       	pop	r29
    1384:	08 95       	ret

00001386 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1386:	df 93       	push	r29
    1388:	cf 93       	push	r28
    138a:	00 d0       	rcall	.+0      	; 0x138c <uxQueueMessagesWaiting+0x6>
    138c:	0f 92       	push	r0
    138e:	cd b7       	in	r28, 0x3d	; 61
    1390:	de b7       	in	r29, 0x3e	; 62
    1392:	9b 83       	std	Y+3, r25	; 0x03
    1394:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1396:	0f b6       	in	r0, 0x3f	; 63
    1398:	f8 94       	cli
    139a:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    139c:	ea 81       	ldd	r30, Y+2	; 0x02
    139e:	fb 81       	ldd	r31, Y+3	; 0x03
    13a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    13a2:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    13a4:	0f 90       	pop	r0
    13a6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    13a8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    13aa:	0f 90       	pop	r0
    13ac:	0f 90       	pop	r0
    13ae:	0f 90       	pop	r0
    13b0:	cf 91       	pop	r28
    13b2:	df 91       	pop	r29
    13b4:	08 95       	ret

000013b6 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    13b6:	df 93       	push	r29
    13b8:	cf 93       	push	r28
    13ba:	00 d0       	rcall	.+0      	; 0x13bc <uxQueueSpacesAvailable+0x6>
    13bc:	00 d0       	rcall	.+0      	; 0x13be <uxQueueSpacesAvailable+0x8>
    13be:	0f 92       	push	r0
    13c0:	cd b7       	in	r28, 0x3d	; 61
    13c2:	de b7       	in	r29, 0x3e	; 62
    13c4:	9d 83       	std	Y+5, r25	; 0x05
    13c6:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    13c8:	8c 81       	ldd	r24, Y+4	; 0x04
    13ca:	9d 81       	ldd	r25, Y+5	; 0x05
    13cc:	9a 83       	std	Y+2, r25	; 0x02
    13ce:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	f8 94       	cli
    13d4:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    13d6:	e9 81       	ldd	r30, Y+1	; 0x01
    13d8:	fa 81       	ldd	r31, Y+2	; 0x02
    13da:	93 8d       	ldd	r25, Z+27	; 0x1b
    13dc:	e9 81       	ldd	r30, Y+1	; 0x01
    13de:	fa 81       	ldd	r31, Y+2	; 0x02
    13e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    13e2:	29 2f       	mov	r18, r25
    13e4:	28 1b       	sub	r18, r24
    13e6:	82 2f       	mov	r24, r18
    13e8:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    13ee:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    13f0:	0f 90       	pop	r0
    13f2:	0f 90       	pop	r0
    13f4:	0f 90       	pop	r0
    13f6:	0f 90       	pop	r0
    13f8:	0f 90       	pop	r0
    13fa:	cf 91       	pop	r28
    13fc:	df 91       	pop	r29
    13fe:	08 95       	ret

00001400 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1400:	df 93       	push	r29
    1402:	cf 93       	push	r28
    1404:	00 d0       	rcall	.+0      	; 0x1406 <uxQueueMessagesWaitingFromISR+0x6>
    1406:	00 d0       	rcall	.+0      	; 0x1408 <uxQueueMessagesWaitingFromISR+0x8>
    1408:	0f 92       	push	r0
    140a:	cd b7       	in	r28, 0x3d	; 61
    140c:	de b7       	in	r29, 0x3e	; 62
    140e:	9d 83       	std	Y+5, r25	; 0x05
    1410:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1412:	8c 81       	ldd	r24, Y+4	; 0x04
    1414:	9d 81       	ldd	r25, Y+5	; 0x05
    1416:	9a 83       	std	Y+2, r25	; 0x02
    1418:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    141a:	e9 81       	ldd	r30, Y+1	; 0x01
    141c:	fa 81       	ldd	r31, Y+2	; 0x02
    141e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1420:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1422:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1424:	0f 90       	pop	r0
    1426:	0f 90       	pop	r0
    1428:	0f 90       	pop	r0
    142a:	0f 90       	pop	r0
    142c:	0f 90       	pop	r0
    142e:	cf 91       	pop	r28
    1430:	df 91       	pop	r29
    1432:	08 95       	ret

00001434 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1434:	df 93       	push	r29
    1436:	cf 93       	push	r28
    1438:	00 d0       	rcall	.+0      	; 0x143a <vQueueDelete+0x6>
    143a:	00 d0       	rcall	.+0      	; 0x143c <vQueueDelete+0x8>
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62
    1440:	9c 83       	std	Y+4, r25	; 0x04
    1442:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	9a 83       	std	Y+2, r25	; 0x02
    144a:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    144c:	89 81       	ldd	r24, Y+1	; 0x01
    144e:	9a 81       	ldd	r25, Y+2	; 0x02
    1450:	0e 94 9f 00 	call	0x13e	; 0x13e <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1454:	0f 90       	pop	r0
    1456:	0f 90       	pop	r0
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	cf 91       	pop	r28
    145e:	df 91       	pop	r29
    1460:	08 95       	ret

00001462 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1462:	df 93       	push	r29
    1464:	cf 93       	push	r28
    1466:	cd b7       	in	r28, 0x3d	; 61
    1468:	de b7       	in	r29, 0x3e	; 62
    146a:	27 97       	sbiw	r28, 0x07	; 7
    146c:	0f b6       	in	r0, 0x3f	; 63
    146e:	f8 94       	cli
    1470:	de bf       	out	0x3e, r29	; 62
    1472:	0f be       	out	0x3f, r0	; 63
    1474:	cd bf       	out	0x3d, r28	; 61
    1476:	9c 83       	std	Y+4, r25	; 0x04
    1478:	8b 83       	std	Y+3, r24	; 0x03
    147a:	7e 83       	std	Y+6, r23	; 0x06
    147c:	6d 83       	std	Y+5, r22	; 0x05
    147e:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1480:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	fc 81       	ldd	r31, Y+4	; 0x04
    1486:	82 8d       	ldd	r24, Z+26	; 0x1a
    1488:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    148a:	eb 81       	ldd	r30, Y+3	; 0x03
    148c:	fc 81       	ldd	r31, Y+4	; 0x04
    148e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1490:	88 23       	and	r24, r24
    1492:	09 f4       	brne	.+2      	; 0x1496 <prvCopyDataToQueue+0x34>
    1494:	7d c0       	rjmp	.+250    	; 0x1590 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1496:	8f 81       	ldd	r24, Y+7	; 0x07
    1498:	88 23       	and	r24, r24
    149a:	99 f5       	brne	.+102    	; 0x1502 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    149c:	eb 81       	ldd	r30, Y+3	; 0x03
    149e:	fc 81       	ldd	r31, Y+4	; 0x04
    14a0:	62 81       	ldd	r22, Z+2	; 0x02
    14a2:	73 81       	ldd	r23, Z+3	; 0x03
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    14aa:	48 2f       	mov	r20, r24
    14ac:	50 e0       	ldi	r21, 0x00	; 0
    14ae:	2d 81       	ldd	r18, Y+5	; 0x05
    14b0:	3e 81       	ldd	r19, Y+6	; 0x06
    14b2:	cb 01       	movw	r24, r22
    14b4:	b9 01       	movw	r22, r18
    14b6:	0e 94 f2 1e 	call	0x3de4	; 0x3de4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    14ba:	eb 81       	ldd	r30, Y+3	; 0x03
    14bc:	fc 81       	ldd	r31, Y+4	; 0x04
    14be:	22 81       	ldd	r18, Z+2	; 0x02
    14c0:	33 81       	ldd	r19, Z+3	; 0x03
    14c2:	eb 81       	ldd	r30, Y+3	; 0x03
    14c4:	fc 81       	ldd	r31, Y+4	; 0x04
    14c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    14c8:	88 2f       	mov	r24, r24
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	82 0f       	add	r24, r18
    14ce:	93 1f       	adc	r25, r19
    14d0:	eb 81       	ldd	r30, Y+3	; 0x03
    14d2:	fc 81       	ldd	r31, Y+4	; 0x04
    14d4:	93 83       	std	Z+3, r25	; 0x03
    14d6:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	22 81       	ldd	r18, Z+2	; 0x02
    14de:	33 81       	ldd	r19, Z+3	; 0x03
    14e0:	eb 81       	ldd	r30, Y+3	; 0x03
    14e2:	fc 81       	ldd	r31, Y+4	; 0x04
    14e4:	84 81       	ldd	r24, Z+4	; 0x04
    14e6:	95 81       	ldd	r25, Z+5	; 0x05
    14e8:	28 17       	cp	r18, r24
    14ea:	39 07       	cpc	r19, r25
    14ec:	08 f4       	brcc	.+2      	; 0x14f0 <prvCopyDataToQueue+0x8e>
    14ee:	50 c0       	rjmp	.+160    	; 0x1590 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    14f0:	eb 81       	ldd	r30, Y+3	; 0x03
    14f2:	fc 81       	ldd	r31, Y+4	; 0x04
    14f4:	80 81       	ld	r24, Z
    14f6:	91 81       	ldd	r25, Z+1	; 0x01
    14f8:	eb 81       	ldd	r30, Y+3	; 0x03
    14fa:	fc 81       	ldd	r31, Y+4	; 0x04
    14fc:	93 83       	std	Z+3, r25	; 0x03
    14fe:	82 83       	std	Z+2, r24	; 0x02
    1500:	47 c0       	rjmp	.+142    	; 0x1590 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1502:	eb 81       	ldd	r30, Y+3	; 0x03
    1504:	fc 81       	ldd	r31, Y+4	; 0x04
    1506:	66 81       	ldd	r22, Z+6	; 0x06
    1508:	77 81       	ldd	r23, Z+7	; 0x07
    150a:	eb 81       	ldd	r30, Y+3	; 0x03
    150c:	fc 81       	ldd	r31, Y+4	; 0x04
    150e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1510:	48 2f       	mov	r20, r24
    1512:	50 e0       	ldi	r21, 0x00	; 0
    1514:	2d 81       	ldd	r18, Y+5	; 0x05
    1516:	3e 81       	ldd	r19, Y+6	; 0x06
    1518:	cb 01       	movw	r24, r22
    151a:	b9 01       	movw	r22, r18
    151c:	0e 94 f2 1e 	call	0x3de4	; 0x3de4 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1520:	eb 81       	ldd	r30, Y+3	; 0x03
    1522:	fc 81       	ldd	r31, Y+4	; 0x04
    1524:	26 81       	ldd	r18, Z+6	; 0x06
    1526:	37 81       	ldd	r19, Z+7	; 0x07
    1528:	eb 81       	ldd	r30, Y+3	; 0x03
    152a:	fc 81       	ldd	r31, Y+4	; 0x04
    152c:	84 8d       	ldd	r24, Z+28	; 0x1c
    152e:	88 2f       	mov	r24, r24
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	90 95       	com	r25
    1534:	81 95       	neg	r24
    1536:	9f 4f       	sbci	r25, 0xFF	; 255
    1538:	82 0f       	add	r24, r18
    153a:	93 1f       	adc	r25, r19
    153c:	eb 81       	ldd	r30, Y+3	; 0x03
    153e:	fc 81       	ldd	r31, Y+4	; 0x04
    1540:	97 83       	std	Z+7, r25	; 0x07
    1542:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1544:	eb 81       	ldd	r30, Y+3	; 0x03
    1546:	fc 81       	ldd	r31, Y+4	; 0x04
    1548:	26 81       	ldd	r18, Z+6	; 0x06
    154a:	37 81       	ldd	r19, Z+7	; 0x07
    154c:	eb 81       	ldd	r30, Y+3	; 0x03
    154e:	fc 81       	ldd	r31, Y+4	; 0x04
    1550:	80 81       	ld	r24, Z
    1552:	91 81       	ldd	r25, Z+1	; 0x01
    1554:	28 17       	cp	r18, r24
    1556:	39 07       	cpc	r19, r25
    1558:	90 f4       	brcc	.+36     	; 0x157e <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	24 81       	ldd	r18, Z+4	; 0x04
    1560:	35 81       	ldd	r19, Z+5	; 0x05
    1562:	eb 81       	ldd	r30, Y+3	; 0x03
    1564:	fc 81       	ldd	r31, Y+4	; 0x04
    1566:	84 8d       	ldd	r24, Z+28	; 0x1c
    1568:	88 2f       	mov	r24, r24
    156a:	90 e0       	ldi	r25, 0x00	; 0
    156c:	90 95       	com	r25
    156e:	81 95       	neg	r24
    1570:	9f 4f       	sbci	r25, 0xFF	; 255
    1572:	82 0f       	add	r24, r18
    1574:	93 1f       	adc	r25, r19
    1576:	eb 81       	ldd	r30, Y+3	; 0x03
    1578:	fc 81       	ldd	r31, Y+4	; 0x04
    157a:	97 83       	std	Z+7, r25	; 0x07
    157c:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    157e:	8f 81       	ldd	r24, Y+7	; 0x07
    1580:	82 30       	cpi	r24, 0x02	; 2
    1582:	31 f4       	brne	.+12     	; 0x1590 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1584:	89 81       	ldd	r24, Y+1	; 0x01
    1586:	88 23       	and	r24, r24
    1588:	19 f0       	breq	.+6      	; 0x1590 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	81 50       	subi	r24, 0x01	; 1
    158e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	8f 5f       	subi	r24, 0xFF	; 255
    1594:	eb 81       	ldd	r30, Y+3	; 0x03
    1596:	fc 81       	ldd	r31, Y+4	; 0x04
    1598:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    159a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    159c:	27 96       	adiw	r28, 0x07	; 7
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	de bf       	out	0x3e, r29	; 62
    15a4:	0f be       	out	0x3f, r0	; 63
    15a6:	cd bf       	out	0x3d, r28	; 61
    15a8:	cf 91       	pop	r28
    15aa:	df 91       	pop	r29
    15ac:	08 95       	ret

000015ae <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    15ae:	df 93       	push	r29
    15b0:	cf 93       	push	r28
    15b2:	00 d0       	rcall	.+0      	; 0x15b4 <prvCopyDataFromQueue+0x6>
    15b4:	00 d0       	rcall	.+0      	; 0x15b6 <prvCopyDataFromQueue+0x8>
    15b6:	cd b7       	in	r28, 0x3d	; 61
    15b8:	de b7       	in	r29, 0x3e	; 62
    15ba:	9a 83       	std	Y+2, r25	; 0x02
    15bc:	89 83       	std	Y+1, r24	; 0x01
    15be:	7c 83       	std	Y+4, r23	; 0x04
    15c0:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    15c2:	e9 81       	ldd	r30, Y+1	; 0x01
    15c4:	fa 81       	ldd	r31, Y+2	; 0x02
    15c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    15c8:	88 23       	and	r24, r24
    15ca:	89 f1       	breq	.+98     	; 0x162e <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	26 81       	ldd	r18, Z+6	; 0x06
    15d2:	37 81       	ldd	r19, Z+7	; 0x07
    15d4:	e9 81       	ldd	r30, Y+1	; 0x01
    15d6:	fa 81       	ldd	r31, Y+2	; 0x02
    15d8:	84 8d       	ldd	r24, Z+28	; 0x1c
    15da:	88 2f       	mov	r24, r24
    15dc:	90 e0       	ldi	r25, 0x00	; 0
    15de:	82 0f       	add	r24, r18
    15e0:	93 1f       	adc	r25, r19
    15e2:	e9 81       	ldd	r30, Y+1	; 0x01
    15e4:	fa 81       	ldd	r31, Y+2	; 0x02
    15e6:	97 83       	std	Z+7, r25	; 0x07
    15e8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    15ea:	e9 81       	ldd	r30, Y+1	; 0x01
    15ec:	fa 81       	ldd	r31, Y+2	; 0x02
    15ee:	26 81       	ldd	r18, Z+6	; 0x06
    15f0:	37 81       	ldd	r19, Z+7	; 0x07
    15f2:	e9 81       	ldd	r30, Y+1	; 0x01
    15f4:	fa 81       	ldd	r31, Y+2	; 0x02
    15f6:	84 81       	ldd	r24, Z+4	; 0x04
    15f8:	95 81       	ldd	r25, Z+5	; 0x05
    15fa:	28 17       	cp	r18, r24
    15fc:	39 07       	cpc	r19, r25
    15fe:	40 f0       	brcs	.+16     	; 0x1610 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1600:	e9 81       	ldd	r30, Y+1	; 0x01
    1602:	fa 81       	ldd	r31, Y+2	; 0x02
    1604:	80 81       	ld	r24, Z
    1606:	91 81       	ldd	r25, Z+1	; 0x01
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	97 83       	std	Z+7, r25	; 0x07
    160e:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1610:	e9 81       	ldd	r30, Y+1	; 0x01
    1612:	fa 81       	ldd	r31, Y+2	; 0x02
    1614:	46 81       	ldd	r20, Z+6	; 0x06
    1616:	57 81       	ldd	r21, Z+7	; 0x07
    1618:	e9 81       	ldd	r30, Y+1	; 0x01
    161a:	fa 81       	ldd	r31, Y+2	; 0x02
    161c:	84 8d       	ldd	r24, Z+28	; 0x1c
    161e:	28 2f       	mov	r18, r24
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	9c 81       	ldd	r25, Y+4	; 0x04
    1626:	ba 01       	movw	r22, r20
    1628:	a9 01       	movw	r20, r18
    162a:	0e 94 f2 1e 	call	0x3de4	; 0x3de4 <memcpy>
	}
}
    162e:	0f 90       	pop	r0
    1630:	0f 90       	pop	r0
    1632:	0f 90       	pop	r0
    1634:	0f 90       	pop	r0
    1636:	cf 91       	pop	r28
    1638:	df 91       	pop	r29
    163a:	08 95       	ret

0000163c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    163c:	df 93       	push	r29
    163e:	cf 93       	push	r28
    1640:	00 d0       	rcall	.+0      	; 0x1642 <prvUnlockQueue+0x6>
    1642:	00 d0       	rcall	.+0      	; 0x1644 <prvUnlockQueue+0x8>
    1644:	cd b7       	in	r28, 0x3d	; 61
    1646:	de b7       	in	r29, 0x3e	; 62
    1648:	9c 83       	std	Y+4, r25	; 0x04
    164a:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1652:	eb 81       	ldd	r30, Y+3	; 0x03
    1654:	fc 81       	ldd	r31, Y+4	; 0x04
    1656:	86 8d       	ldd	r24, Z+30	; 0x1e
    1658:	8a 83       	std	Y+2, r24	; 0x02
    165a:	11 c0       	rjmp	.+34     	; 0x167e <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    165c:	eb 81       	ldd	r30, Y+3	; 0x03
    165e:	fc 81       	ldd	r31, Y+4	; 0x04
    1660:	81 89       	ldd	r24, Z+17	; 0x11
    1662:	88 23       	and	r24, r24
    1664:	79 f0       	breq	.+30     	; 0x1684 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1666:	8b 81       	ldd	r24, Y+3	; 0x03
    1668:	9c 81       	ldd	r25, Y+4	; 0x04
    166a:	41 96       	adiw	r24, 0x11	; 17
    166c:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
    1670:	88 23       	and	r24, r24
    1672:	11 f0       	breq	.+4      	; 0x1678 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1674:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1678:	8a 81       	ldd	r24, Y+2	; 0x02
    167a:	81 50       	subi	r24, 0x01	; 1
    167c:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    167e:	8a 81       	ldd	r24, Y+2	; 0x02
    1680:	18 16       	cp	r1, r24
    1682:	64 f3       	brlt	.-40     	; 0x165c <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1684:	eb 81       	ldd	r30, Y+3	; 0x03
    1686:	fc 81       	ldd	r31, Y+4	; 0x04
    1688:	8f ef       	ldi	r24, 0xFF	; 255
    168a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    168c:	0f 90       	pop	r0
    168e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1690:	0f b6       	in	r0, 0x3f	; 63
    1692:	f8 94       	cli
    1694:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1696:	eb 81       	ldd	r30, Y+3	; 0x03
    1698:	fc 81       	ldd	r31, Y+4	; 0x04
    169a:	85 8d       	ldd	r24, Z+29	; 0x1d
    169c:	89 83       	std	Y+1, r24	; 0x01
    169e:	11 c0       	rjmp	.+34     	; 0x16c2 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16a0:	eb 81       	ldd	r30, Y+3	; 0x03
    16a2:	fc 81       	ldd	r31, Y+4	; 0x04
    16a4:	80 85       	ldd	r24, Z+8	; 0x08
    16a6:	88 23       	and	r24, r24
    16a8:	79 f0       	breq	.+30     	; 0x16c8 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16aa:	8b 81       	ldd	r24, Y+3	; 0x03
    16ac:	9c 81       	ldd	r25, Y+4	; 0x04
    16ae:	08 96       	adiw	r24, 0x08	; 8
    16b0:	0e 94 3a 14 	call	0x2874	; 0x2874 <xTaskRemoveFromEventList>
    16b4:	88 23       	and	r24, r24
    16b6:	11 f0       	breq	.+4      	; 0x16bc <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    16b8:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    16bc:	89 81       	ldd	r24, Y+1	; 0x01
    16be:	81 50       	subi	r24, 0x01	; 1
    16c0:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
    16c4:	18 16       	cp	r1, r24
    16c6:	64 f3       	brlt	.-40     	; 0x16a0 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    16c8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ca:	fc 81       	ldd	r31, Y+4	; 0x04
    16cc:	8f ef       	ldi	r24, 0xFF	; 255
    16ce:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
}
    16d4:	0f 90       	pop	r0
    16d6:	0f 90       	pop	r0
    16d8:	0f 90       	pop	r0
    16da:	0f 90       	pop	r0
    16dc:	cf 91       	pop	r28
    16de:	df 91       	pop	r29
    16e0:	08 95       	ret

000016e2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    16e2:	df 93       	push	r29
    16e4:	cf 93       	push	r28
    16e6:	00 d0       	rcall	.+0      	; 0x16e8 <prvIsQueueEmpty+0x6>
    16e8:	0f 92       	push	r0
    16ea:	cd b7       	in	r28, 0x3d	; 61
    16ec:	de b7       	in	r29, 0x3e	; 62
    16ee:	9b 83       	std	Y+3, r25	; 0x03
    16f0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    16f8:	ea 81       	ldd	r30, Y+2	; 0x02
    16fa:	fb 81       	ldd	r31, Y+3	; 0x03
    16fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    16fe:	88 23       	and	r24, r24
    1700:	19 f4       	brne	.+6      	; 0x1708 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    1702:	81 e0       	ldi	r24, 0x01	; 1
    1704:	89 83       	std	Y+1, r24	; 0x01
    1706:	01 c0       	rjmp	.+2      	; 0x170a <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    1708:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    170a:	0f 90       	pop	r0
    170c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    170e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	0f 90       	pop	r0
    1716:	cf 91       	pop	r28
    1718:	df 91       	pop	r29
    171a:	08 95       	ret

0000171c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    171c:	df 93       	push	r29
    171e:	cf 93       	push	r28
    1720:	00 d0       	rcall	.+0      	; 0x1722 <xQueueIsQueueEmptyFromISR+0x6>
    1722:	00 d0       	rcall	.+0      	; 0x1724 <xQueueIsQueueEmptyFromISR+0x8>
    1724:	0f 92       	push	r0
    1726:	cd b7       	in	r28, 0x3d	; 61
    1728:	de b7       	in	r29, 0x3e	; 62
    172a:	9d 83       	std	Y+5, r25	; 0x05
    172c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    172e:	8c 81       	ldd	r24, Y+4	; 0x04
    1730:	9d 81       	ldd	r25, Y+5	; 0x05
    1732:	9a 83       	std	Y+2, r25	; 0x02
    1734:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1736:	e9 81       	ldd	r30, Y+1	; 0x01
    1738:	fa 81       	ldd	r31, Y+2	; 0x02
    173a:	82 8d       	ldd	r24, Z+26	; 0x1a
    173c:	88 23       	and	r24, r24
    173e:	19 f4       	brne	.+6      	; 0x1746 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1740:	81 e0       	ldi	r24, 0x01	; 1
    1742:	8b 83       	std	Y+3, r24	; 0x03
    1744:	01 c0       	rjmp	.+2      	; 0x1748 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1746:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1748:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	0f 90       	pop	r0
    1750:	0f 90       	pop	r0
    1752:	0f 90       	pop	r0
    1754:	cf 91       	pop	r28
    1756:	df 91       	pop	r29
    1758:	08 95       	ret

0000175a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    175a:	df 93       	push	r29
    175c:	cf 93       	push	r28
    175e:	00 d0       	rcall	.+0      	; 0x1760 <prvIsQueueFull+0x6>
    1760:	0f 92       	push	r0
    1762:	cd b7       	in	r28, 0x3d	; 61
    1764:	de b7       	in	r29, 0x3e	; 62
    1766:	9b 83       	std	Y+3, r25	; 0x03
    1768:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    176a:	0f b6       	in	r0, 0x3f	; 63
    176c:	f8 94       	cli
    176e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1770:	ea 81       	ldd	r30, Y+2	; 0x02
    1772:	fb 81       	ldd	r31, Y+3	; 0x03
    1774:	92 8d       	ldd	r25, Z+26	; 0x1a
    1776:	ea 81       	ldd	r30, Y+2	; 0x02
    1778:	fb 81       	ldd	r31, Y+3	; 0x03
    177a:	83 8d       	ldd	r24, Z+27	; 0x1b
    177c:	98 17       	cp	r25, r24
    177e:	19 f4       	brne	.+6      	; 0x1786 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    1780:	81 e0       	ldi	r24, 0x01	; 1
    1782:	89 83       	std	Y+1, r24	; 0x01
    1784:	01 c0       	rjmp	.+2      	; 0x1788 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    1786:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1788:	0f 90       	pop	r0
    178a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    178c:	89 81       	ldd	r24, Y+1	; 0x01
}
    178e:	0f 90       	pop	r0
    1790:	0f 90       	pop	r0
    1792:	0f 90       	pop	r0
    1794:	cf 91       	pop	r28
    1796:	df 91       	pop	r29
    1798:	08 95       	ret

0000179a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	00 d0       	rcall	.+0      	; 0x17a0 <xQueueIsQueueFullFromISR+0x6>
    17a0:	00 d0       	rcall	.+0      	; 0x17a2 <xQueueIsQueueFullFromISR+0x8>
    17a2:	0f 92       	push	r0
    17a4:	cd b7       	in	r28, 0x3d	; 61
    17a6:	de b7       	in	r29, 0x3e	; 62
    17a8:	9d 83       	std	Y+5, r25	; 0x05
    17aa:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    17ac:	8c 81       	ldd	r24, Y+4	; 0x04
    17ae:	9d 81       	ldd	r25, Y+5	; 0x05
    17b0:	9a 83       	std	Y+2, r25	; 0x02
    17b2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    17b4:	e9 81       	ldd	r30, Y+1	; 0x01
    17b6:	fa 81       	ldd	r31, Y+2	; 0x02
    17b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    17ba:	e9 81       	ldd	r30, Y+1	; 0x01
    17bc:	fa 81       	ldd	r31, Y+2	; 0x02
    17be:	83 8d       	ldd	r24, Z+27	; 0x1b
    17c0:	98 17       	cp	r25, r24
    17c2:	19 f4       	brne	.+6      	; 0x17ca <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	8b 83       	std	Y+3, r24	; 0x03
    17c8:	01 c0       	rjmp	.+2      	; 0x17cc <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    17ca:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    17cc:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    17ce:	0f 90       	pop	r0
    17d0:	0f 90       	pop	r0
    17d2:	0f 90       	pop	r0
    17d4:	0f 90       	pop	r0
    17d6:	0f 90       	pop	r0
    17d8:	cf 91       	pop	r28
    17da:	df 91       	pop	r29
    17dc:	08 95       	ret

000017de <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    17de:	8f 92       	push	r8
    17e0:	9f 92       	push	r9
    17e2:	af 92       	push	r10
    17e4:	bf 92       	push	r11
    17e6:	cf 92       	push	r12
    17e8:	df 92       	push	r13
    17ea:	ef 92       	push	r14
    17ec:	ff 92       	push	r15
    17ee:	0f 93       	push	r16
    17f0:	1f 93       	push	r17
    17f2:	df 93       	push	r29
    17f4:	cf 93       	push	r28
    17f6:	cd b7       	in	r28, 0x3d	; 61
    17f8:	de b7       	in	r29, 0x3e	; 62
    17fa:	60 97       	sbiw	r28, 0x10	; 16
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	de bf       	out	0x3e, r29	; 62
    1802:	0f be       	out	0x3f, r0	; 63
    1804:	cd bf       	out	0x3d, r28	; 61
    1806:	9f 83       	std	Y+7, r25	; 0x07
    1808:	8e 83       	std	Y+6, r24	; 0x06
    180a:	79 87       	std	Y+9, r23	; 0x09
    180c:	68 87       	std	Y+8, r22	; 0x08
    180e:	5b 87       	std	Y+11, r21	; 0x0b
    1810:	4a 87       	std	Y+10, r20	; 0x0a
    1812:	3d 87       	std	Y+13, r19	; 0x0d
    1814:	2c 87       	std	Y+12, r18	; 0x0c
    1816:	0e 87       	std	Y+14, r16	; 0x0e
    1818:	f8 8a       	std	Y+16, r15	; 0x10
    181a:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    181c:	8a 85       	ldd	r24, Y+10	; 0x0a
    181e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1820:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1824:	9a 83       	std	Y+2, r25	; 0x02
    1826:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    1828:	89 81       	ldd	r24, Y+1	; 0x01
    182a:	9a 81       	ldd	r25, Y+2	; 0x02
    182c:	00 97       	sbiw	r24, 0x00	; 0
    182e:	b1 f0       	breq	.+44     	; 0x185c <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    1830:	86 e2       	ldi	r24, 0x26	; 38
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1838:	9d 83       	std	Y+5, r25	; 0x05
    183a:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    183c:	8c 81       	ldd	r24, Y+4	; 0x04
    183e:	9d 81       	ldd	r25, Y+5	; 0x05
    1840:	00 97       	sbiw	r24, 0x00	; 0
    1842:	39 f0       	breq	.+14     	; 0x1852 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1844:	ec 81       	ldd	r30, Y+4	; 0x04
    1846:	fd 81       	ldd	r31, Y+5	; 0x05
    1848:	89 81       	ldd	r24, Y+1	; 0x01
    184a:	9a 81       	ldd	r25, Y+2	; 0x02
    184c:	90 8f       	std	Z+24, r25	; 0x18
    184e:	87 8b       	std	Z+23, r24	; 0x17
    1850:	07 c0       	rjmp	.+14     	; 0x1860 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1852:	89 81       	ldd	r24, Y+1	; 0x01
    1854:	9a 81       	ldd	r25, Y+2	; 0x02
    1856:	0e 94 9f 00 	call	0x13e	; 0x13e <vPortFree>
    185a:	02 c0       	rjmp	.+4      	; 0x1860 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    185c:	1d 82       	std	Y+5, r1	; 0x05
    185e:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    1860:	8c 81       	ldd	r24, Y+4	; 0x04
    1862:	9d 81       	ldd	r25, Y+5	; 0x05
    1864:	00 97       	sbiw	r24, 0x00	; 0
    1866:	e9 f0       	breq	.+58     	; 0x18a2 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1868:	8a 85       	ldd	r24, Y+10	; 0x0a
    186a:	9b 85       	ldd	r25, Y+11	; 0x0b
    186c:	9c 01       	movw	r18, r24
    186e:	40 e0       	ldi	r20, 0x00	; 0
    1870:	50 e0       	ldi	r21, 0x00	; 0
    1872:	8e 81       	ldd	r24, Y+6	; 0x06
    1874:	9f 81       	ldd	r25, Y+7	; 0x07
    1876:	68 85       	ldd	r22, Y+8	; 0x08
    1878:	79 85       	ldd	r23, Y+9	; 0x09
    187a:	ec 85       	ldd	r30, Y+12	; 0x0c
    187c:	fd 85       	ldd	r31, Y+13	; 0x0d
    187e:	af 85       	ldd	r26, Y+15	; 0x0f
    1880:	b8 89       	ldd	r27, Y+16	; 0x10
    1882:	ac 80       	ldd	r10, Y+4	; 0x04
    1884:	bd 80       	ldd	r11, Y+5	; 0x05
    1886:	8f 01       	movw	r16, r30
    1888:	ee 84       	ldd	r14, Y+14	; 0x0e
    188a:	6d 01       	movw	r12, r26
    188c:	88 24       	eor	r8, r8
    188e:	99 24       	eor	r9, r9
    1890:	0e 94 67 0c 	call	0x18ce	; 0x18ce <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    1894:	8c 81       	ldd	r24, Y+4	; 0x04
    1896:	9d 81       	ldd	r25, Y+5	; 0x05
    1898:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    189c:	81 e0       	ldi	r24, 0x01	; 1
    189e:	8b 83       	std	Y+3, r24	; 0x03
    18a0:	02 c0       	rjmp	.+4      	; 0x18a6 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    18a2:	8f ef       	ldi	r24, 0xFF	; 255
    18a4:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    18a8:	60 96       	adiw	r28, 0x10	; 16
    18aa:	0f b6       	in	r0, 0x3f	; 63
    18ac:	f8 94       	cli
    18ae:	de bf       	out	0x3e, r29	; 62
    18b0:	0f be       	out	0x3f, r0	; 63
    18b2:	cd bf       	out	0x3d, r28	; 61
    18b4:	cf 91       	pop	r28
    18b6:	df 91       	pop	r29
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	ff 90       	pop	r15
    18be:	ef 90       	pop	r14
    18c0:	df 90       	pop	r13
    18c2:	cf 90       	pop	r12
    18c4:	bf 90       	pop	r11
    18c6:	af 90       	pop	r10
    18c8:	9f 90       	pop	r9
    18ca:	8f 90       	pop	r8
    18cc:	08 95       	ret

000018ce <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    18ce:	8f 92       	push	r8
    18d0:	9f 92       	push	r9
    18d2:	af 92       	push	r10
    18d4:	bf 92       	push	r11
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ef 92       	push	r14
    18dc:	0f 93       	push	r16
    18de:	1f 93       	push	r17
    18e0:	df 93       	push	r29
    18e2:	cf 93       	push	r28
    18e4:	cd b7       	in	r28, 0x3d	; 61
    18e6:	de b7       	in	r29, 0x3e	; 62
    18e8:	64 97       	sbiw	r28, 0x14	; 20
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	f8 94       	cli
    18ee:	de bf       	out	0x3e, r29	; 62
    18f0:	0f be       	out	0x3f, r0	; 63
    18f2:	cd bf       	out	0x3d, r28	; 61
    18f4:	9d 83       	std	Y+5, r25	; 0x05
    18f6:	8c 83       	std	Y+4, r24	; 0x04
    18f8:	7f 83       	std	Y+7, r23	; 0x07
    18fa:	6e 83       	std	Y+6, r22	; 0x06
    18fc:	28 87       	std	Y+8, r18	; 0x08
    18fe:	39 87       	std	Y+9, r19	; 0x09
    1900:	4a 87       	std	Y+10, r20	; 0x0a
    1902:	5b 87       	std	Y+11, r21	; 0x0b
    1904:	1d 87       	std	Y+13, r17	; 0x0d
    1906:	0c 87       	std	Y+12, r16	; 0x0c
    1908:	ee 86       	std	Y+14, r14	; 0x0e
    190a:	d8 8a       	std	Y+16, r13	; 0x10
    190c:	cf 86       	std	Y+15, r12	; 0x0f
    190e:	ba 8a       	std	Y+18, r11	; 0x12
    1910:	a9 8a       	std	Y+17, r10	; 0x11
    1912:	9c 8a       	std	Y+20, r9	; 0x14
    1914:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    1916:	e9 89       	ldd	r30, Y+17	; 0x11
    1918:	fa 89       	ldd	r31, Y+18	; 0x12
    191a:	27 89       	ldd	r18, Z+23	; 0x17
    191c:	30 8d       	ldd	r19, Z+24	; 0x18
    191e:	88 85       	ldd	r24, Y+8	; 0x08
    1920:	99 85       	ldd	r25, Y+9	; 0x09
    1922:	01 97       	sbiw	r24, 0x01	; 1
    1924:	82 0f       	add	r24, r18
    1926:	93 1f       	adc	r25, r19
    1928:	9b 83       	std	Y+3, r25	; 0x03
    192a:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    192c:	8e 81       	ldd	r24, Y+6	; 0x06
    192e:	9f 81       	ldd	r25, Y+7	; 0x07
    1930:	00 97       	sbiw	r24, 0x00	; 0
    1932:	51 f1       	breq	.+84     	; 0x1988 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1934:	19 82       	std	Y+1, r1	; 0x01
    1936:	21 c0       	rjmp	.+66     	; 0x197a <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	48 2f       	mov	r20, r24
    193c:	50 e0       	ldi	r21, 0x00	; 0
    193e:	89 81       	ldd	r24, Y+1	; 0x01
    1940:	28 2f       	mov	r18, r24
    1942:	30 e0       	ldi	r19, 0x00	; 0
    1944:	8e 81       	ldd	r24, Y+6	; 0x06
    1946:	9f 81       	ldd	r25, Y+7	; 0x07
    1948:	fc 01       	movw	r30, r24
    194a:	e2 0f       	add	r30, r18
    194c:	f3 1f       	adc	r31, r19
    194e:	20 81       	ld	r18, Z
    1950:	89 89       	ldd	r24, Y+17	; 0x11
    1952:	9a 89       	ldd	r25, Y+18	; 0x12
    1954:	84 0f       	add	r24, r20
    1956:	95 1f       	adc	r25, r21
    1958:	fc 01       	movw	r30, r24
    195a:	79 96       	adiw	r30, 0x19	; 25
    195c:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    195e:	89 81       	ldd	r24, Y+1	; 0x01
    1960:	28 2f       	mov	r18, r24
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	8e 81       	ldd	r24, Y+6	; 0x06
    1966:	9f 81       	ldd	r25, Y+7	; 0x07
    1968:	fc 01       	movw	r30, r24
    196a:	e2 0f       	add	r30, r18
    196c:	f3 1f       	adc	r31, r19
    196e:	80 81       	ld	r24, Z
    1970:	88 23       	and	r24, r24
    1972:	31 f0       	breq	.+12     	; 0x1980 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1974:	89 81       	ldd	r24, Y+1	; 0x01
    1976:	8f 5f       	subi	r24, 0xFF	; 255
    1978:	89 83       	std	Y+1, r24	; 0x01
    197a:	89 81       	ldd	r24, Y+1	; 0x01
    197c:	88 30       	cpi	r24, 0x08	; 8
    197e:	e0 f2       	brcs	.-72     	; 0x1938 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1980:	e9 89       	ldd	r30, Y+17	; 0x11
    1982:	fa 89       	ldd	r31, Y+18	; 0x12
    1984:	10 a2       	std	Z+32, r1	; 0x20
    1986:	03 c0       	rjmp	.+6      	; 0x198e <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    1988:	e9 89       	ldd	r30, Y+17	; 0x11
    198a:	fa 89       	ldd	r31, Y+18	; 0x12
    198c:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    198e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1990:	85 30       	cpi	r24, 0x05	; 5
    1992:	10 f0       	brcs	.+4      	; 0x1998 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1994:	84 e0       	ldi	r24, 0x04	; 4
    1996:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1998:	e9 89       	ldd	r30, Y+17	; 0x11
    199a:	fa 89       	ldd	r31, Y+18	; 0x12
    199c:	8e 85       	ldd	r24, Y+14	; 0x0e
    199e:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    19a0:	89 89       	ldd	r24, Y+17	; 0x11
    19a2:	9a 89       	ldd	r25, Y+18	; 0x12
    19a4:	02 96       	adiw	r24, 0x02	; 2
    19a6:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    19aa:	89 89       	ldd	r24, Y+17	; 0x11
    19ac:	9a 89       	ldd	r25, Y+18	; 0x12
    19ae:	0c 96       	adiw	r24, 0x0c	; 12
    19b0:	0e 94 ef 00 	call	0x1de	; 0x1de <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    19b4:	e9 89       	ldd	r30, Y+17	; 0x11
    19b6:	fa 89       	ldd	r31, Y+18	; 0x12
    19b8:	89 89       	ldd	r24, Y+17	; 0x11
    19ba:	9a 89       	ldd	r25, Y+18	; 0x12
    19bc:	91 87       	std	Z+9, r25	; 0x09
    19be:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    19c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    19c2:	28 2f       	mov	r18, r24
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	85 e0       	ldi	r24, 0x05	; 5
    19c8:	90 e0       	ldi	r25, 0x00	; 0
    19ca:	82 1b       	sub	r24, r18
    19cc:	93 0b       	sbc	r25, r19
    19ce:	e9 89       	ldd	r30, Y+17	; 0x11
    19d0:	fa 89       	ldd	r31, Y+18	; 0x12
    19d2:	95 87       	std	Z+13, r25	; 0x0d
    19d4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    19d6:	e9 89       	ldd	r30, Y+17	; 0x11
    19d8:	fa 89       	ldd	r31, Y+18	; 0x12
    19da:	89 89       	ldd	r24, Y+17	; 0x11
    19dc:	9a 89       	ldd	r25, Y+18	; 0x12
    19de:	93 8b       	std	Z+19, r25	; 0x13
    19e0:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    19e2:	e9 89       	ldd	r30, Y+17	; 0x11
    19e4:	fa 89       	ldd	r31, Y+18	; 0x12
    19e6:	11 a2       	std	Z+33, r1	; 0x21
    19e8:	12 a2       	std	Z+34, r1	; 0x22
    19ea:	13 a2       	std	Z+35, r1	; 0x23
    19ec:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    19ee:	e9 89       	ldd	r30, Y+17	; 0x11
    19f0:	fa 89       	ldd	r31, Y+18	; 0x12
    19f2:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    19f4:	8a 81       	ldd	r24, Y+2	; 0x02
    19f6:	9b 81       	ldd	r25, Y+3	; 0x03
    19f8:	2c 81       	ldd	r18, Y+4	; 0x04
    19fa:	3d 81       	ldd	r19, Y+5	; 0x05
    19fc:	4c 85       	ldd	r20, Y+12	; 0x0c
    19fe:	5d 85       	ldd	r21, Y+13	; 0x0d
    1a00:	b9 01       	movw	r22, r18
    1a02:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <pxPortInitialiseStack>
    1a06:	e9 89       	ldd	r30, Y+17	; 0x11
    1a08:	fa 89       	ldd	r31, Y+18	; 0x12
    1a0a:	91 83       	std	Z+1, r25	; 0x01
    1a0c:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    1a0e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a10:	98 89       	ldd	r25, Y+16	; 0x10
    1a12:	00 97       	sbiw	r24, 0x00	; 0
    1a14:	31 f0       	breq	.+12     	; 0x1a22 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1a16:	ef 85       	ldd	r30, Y+15	; 0x0f
    1a18:	f8 89       	ldd	r31, Y+16	; 0x10
    1a1a:	89 89       	ldd	r24, Y+17	; 0x11
    1a1c:	9a 89       	ldd	r25, Y+18	; 0x12
    1a1e:	91 83       	std	Z+1, r25	; 0x01
    1a20:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    1a22:	64 96       	adiw	r28, 0x14	; 20
    1a24:	0f b6       	in	r0, 0x3f	; 63
    1a26:	f8 94       	cli
    1a28:	de bf       	out	0x3e, r29	; 62
    1a2a:	0f be       	out	0x3f, r0	; 63
    1a2c:	cd bf       	out	0x3d, r28	; 61
    1a2e:	cf 91       	pop	r28
    1a30:	df 91       	pop	r29
    1a32:	1f 91       	pop	r17
    1a34:	0f 91       	pop	r16
    1a36:	ef 90       	pop	r14
    1a38:	df 90       	pop	r13
    1a3a:	cf 90       	pop	r12
    1a3c:	bf 90       	pop	r11
    1a3e:	af 90       	pop	r10
    1a40:	9f 90       	pop	r9
    1a42:	8f 90       	pop	r8
    1a44:	08 95       	ret

00001a46 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    1a46:	df 93       	push	r29
    1a48:	cf 93       	push	r28
    1a4a:	00 d0       	rcall	.+0      	; 0x1a4c <prvAddNewTaskToReadyList+0x6>
    1a4c:	cd b7       	in	r28, 0x3d	; 61
    1a4e:	de b7       	in	r29, 0x3e	; 62
    1a50:	9a 83       	std	Y+2, r25	; 0x02
    1a52:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1a54:	0f b6       	in	r0, 0x3f	; 63
    1a56:	f8 94       	cli
    1a58:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1a5a:	80 91 55 04 	lds	r24, 0x0455
    1a5e:	8f 5f       	subi	r24, 0xFF	; 255
    1a60:	80 93 55 04 	sts	0x0455, r24
		if( pxCurrentTCB == NULL )
    1a64:	80 91 52 04 	lds	r24, 0x0452
    1a68:	90 91 53 04 	lds	r25, 0x0453
    1a6c:	00 97       	sbiw	r24, 0x00	; 0
    1a6e:	69 f4       	brne	.+26     	; 0x1a8a <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1a70:	89 81       	ldd	r24, Y+1	; 0x01
    1a72:	9a 81       	ldd	r25, Y+2	; 0x02
    1a74:	90 93 53 04 	sts	0x0453, r25
    1a78:	80 93 52 04 	sts	0x0452, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1a7c:	80 91 55 04 	lds	r24, 0x0455
    1a80:	81 30       	cpi	r24, 0x01	; 1
    1a82:	b9 f4       	brne	.+46     	; 0x1ab2 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    1a84:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <prvInitialiseTaskLists>
    1a88:	14 c0       	rjmp	.+40     	; 0x1ab2 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1a8a:	80 91 59 04 	lds	r24, 0x0459
    1a8e:	88 23       	and	r24, r24
    1a90:	81 f4       	brne	.+32     	; 0x1ab2 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1a92:	e0 91 52 04 	lds	r30, 0x0452
    1a96:	f0 91 53 04 	lds	r31, 0x0453
    1a9a:	96 89       	ldd	r25, Z+22	; 0x16
    1a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa0:	86 89       	ldd	r24, Z+22	; 0x16
    1aa2:	89 17       	cp	r24, r25
    1aa4:	30 f0       	brcs	.+12     	; 0x1ab2 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    1aa6:	89 81       	ldd	r24, Y+1	; 0x01
    1aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aaa:	90 93 53 04 	sts	0x0453, r25
    1aae:	80 93 52 04 	sts	0x0452, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1ab2:	80 91 5e 04 	lds	r24, 0x045E
    1ab6:	8f 5f       	subi	r24, 0xFF	; 255
    1ab8:	80 93 5e 04 	sts	0x045E, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1abc:	e9 81       	ldd	r30, Y+1	; 0x01
    1abe:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac0:	96 89       	ldd	r25, Z+22	; 0x16
    1ac2:	80 91 58 04 	lds	r24, 0x0458
    1ac6:	89 17       	cp	r24, r25
    1ac8:	28 f4       	brcc	.+10     	; 0x1ad4 <prvAddNewTaskToReadyList+0x8e>
    1aca:	e9 81       	ldd	r30, Y+1	; 0x01
    1acc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ace:	86 89       	ldd	r24, Z+22	; 0x16
    1ad0:	80 93 58 04 	sts	0x0458, r24
    1ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ad8:	86 89       	ldd	r24, Z+22	; 0x16
    1ada:	28 2f       	mov	r18, r24
    1adc:	30 e0       	ldi	r19, 0x00	; 0
    1ade:	c9 01       	movw	r24, r18
    1ae0:	88 0f       	add	r24, r24
    1ae2:	99 1f       	adc	r25, r25
    1ae4:	88 0f       	add	r24, r24
    1ae6:	99 1f       	adc	r25, r25
    1ae8:	88 0f       	add	r24, r24
    1aea:	99 1f       	adc	r25, r25
    1aec:	82 0f       	add	r24, r18
    1aee:	93 1f       	adc	r25, r19
    1af0:	ac 01       	movw	r20, r24
    1af2:	4c 59       	subi	r20, 0x9C	; 156
    1af4:	5b 4f       	sbci	r21, 0xFB	; 251
    1af6:	89 81       	ldd	r24, Y+1	; 0x01
    1af8:	9a 81       	ldd	r25, Y+2	; 0x02
    1afa:	9c 01       	movw	r18, r24
    1afc:	2e 5f       	subi	r18, 0xFE	; 254
    1afe:	3f 4f       	sbci	r19, 0xFF	; 255
    1b00:	ca 01       	movw	r24, r20
    1b02:	b9 01       	movw	r22, r18
    1b04:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1b08:	0f 90       	pop	r0
    1b0a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1b0c:	80 91 59 04 	lds	r24, 0x0459
    1b10:	88 23       	and	r24, r24
    1b12:	61 f0       	breq	.+24     	; 0x1b2c <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1b14:	e0 91 52 04 	lds	r30, 0x0452
    1b18:	f0 91 53 04 	lds	r31, 0x0453
    1b1c:	96 89       	ldd	r25, Z+22	; 0x16
    1b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b20:	fa 81       	ldd	r31, Y+2	; 0x02
    1b22:	86 89       	ldd	r24, Z+22	; 0x16
    1b24:	98 17       	cp	r25, r24
    1b26:	10 f4       	brcc	.+4      	; 0x1b2c <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1b28:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    1b2c:	0f 90       	pop	r0
    1b2e:	0f 90       	pop	r0
    1b30:	cf 91       	pop	r28
    1b32:	df 91       	pop	r29
    1b34:	08 95       	ret

00001b36 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1b36:	df 93       	push	r29
    1b38:	cf 93       	push	r28
    1b3a:	00 d0       	rcall	.+0      	; 0x1b3c <vTaskDelete+0x6>
    1b3c:	00 d0       	rcall	.+0      	; 0x1b3e <vTaskDelete+0x8>
    1b3e:	00 d0       	rcall	.+0      	; 0x1b40 <vTaskDelete+0xa>
    1b40:	cd b7       	in	r28, 0x3d	; 61
    1b42:	de b7       	in	r29, 0x3e	; 62
    1b44:	9c 83       	std	Y+4, r25	; 0x04
    1b46:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1b48:	0f b6       	in	r0, 0x3f	; 63
    1b4a:	f8 94       	cli
    1b4c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b50:	9c 81       	ldd	r25, Y+4	; 0x04
    1b52:	00 97       	sbiw	r24, 0x00	; 0
    1b54:	39 f4       	brne	.+14     	; 0x1b64 <vTaskDelete+0x2e>
    1b56:	80 91 52 04 	lds	r24, 0x0452
    1b5a:	90 91 53 04 	lds	r25, 0x0453
    1b5e:	9e 83       	std	Y+6, r25	; 0x06
    1b60:	8d 83       	std	Y+5, r24	; 0x05
    1b62:	04 c0       	rjmp	.+8      	; 0x1b6c <vTaskDelete+0x36>
    1b64:	8b 81       	ldd	r24, Y+3	; 0x03
    1b66:	9c 81       	ldd	r25, Y+4	; 0x04
    1b68:	9e 83       	std	Y+6, r25	; 0x06
    1b6a:	8d 83       	std	Y+5, r24	; 0x05
    1b6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b70:	9a 83       	std	Y+2, r25	; 0x02
    1b72:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1b74:	89 81       	ldd	r24, Y+1	; 0x01
    1b76:	9a 81       	ldd	r25, Y+2	; 0x02
    1b78:	02 96       	adiw	r24, 0x02	; 2
    1b7a:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b80:	fa 81       	ldd	r31, Y+2	; 0x02
    1b82:	84 89       	ldd	r24, Z+20	; 0x14
    1b84:	95 89       	ldd	r25, Z+21	; 0x15
    1b86:	00 97       	sbiw	r24, 0x00	; 0
    1b88:	29 f0       	breq	.+10     	; 0x1b94 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1b8a:	89 81       	ldd	r24, Y+1	; 0x01
    1b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8e:	0c 96       	adiw	r24, 0x0c	; 12
    1b90:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1b94:	80 91 5e 04 	lds	r24, 0x045E
    1b98:	8f 5f       	subi	r24, 0xFF	; 255
    1b9a:	80 93 5e 04 	sts	0x045E, r24

			if( pxTCB == pxCurrentTCB )
    1b9e:	20 91 52 04 	lds	r18, 0x0452
    1ba2:	30 91 53 04 	lds	r19, 0x0453
    1ba6:	89 81       	ldd	r24, Y+1	; 0x01
    1ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    1baa:	82 17       	cp	r24, r18
    1bac:	93 07       	cpc	r25, r19
    1bae:	81 f4       	brne	.+32     	; 0x1bd0 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1bb0:	89 81       	ldd	r24, Y+1	; 0x01
    1bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb4:	9c 01       	movw	r18, r24
    1bb6:	2e 5f       	subi	r18, 0xFE	; 254
    1bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    1bba:	80 eb       	ldi	r24, 0xB0	; 176
    1bbc:	94 e0       	ldi	r25, 0x04	; 4
    1bbe:	b9 01       	movw	r22, r18
    1bc0:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1bc4:	80 91 54 04 	lds	r24, 0x0454
    1bc8:	8f 5f       	subi	r24, 0xFF	; 255
    1bca:	80 93 54 04 	sts	0x0454, r24
    1bce:	0b c0       	rjmp	.+22     	; 0x1be6 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1bd0:	80 91 55 04 	lds	r24, 0x0455
    1bd4:	81 50       	subi	r24, 0x01	; 1
    1bd6:	80 93 55 04 	sts	0x0455, r24
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
    1bda:	89 81       	ldd	r24, Y+1	; 0x01
    1bdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1bde:	0e 94 2a 16 	call	0x2c54	; 0x2c54 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1be2:	0e 94 40 16 	call	0x2c80	; 0x2c80 <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
    1be6:	0f 90       	pop	r0
    1be8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1bea:	80 91 59 04 	lds	r24, 0x0459
    1bee:	88 23       	and	r24, r24
    1bf0:	59 f0       	breq	.+22     	; 0x1c08 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    1bf2:	20 91 52 04 	lds	r18, 0x0452
    1bf6:	30 91 53 04 	lds	r19, 0x0453
    1bfa:	89 81       	ldd	r24, Y+1	; 0x01
    1bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    1bfe:	82 17       	cp	r24, r18
    1c00:	93 07       	cpc	r25, r19
    1c02:	11 f4       	brne	.+4      	; 0x1c08 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1c04:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1c08:	26 96       	adiw	r28, 0x06	; 6
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	de bf       	out	0x3e, r29	; 62
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	cd bf       	out	0x3d, r28	; 61
    1c14:	cf 91       	pop	r28
    1c16:	df 91       	pop	r29
    1c18:	08 95       	ret

00001c1a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1c1a:	df 93       	push	r29
    1c1c:	cf 93       	push	r28
    1c1e:	cd b7       	in	r28, 0x3d	; 61
    1c20:	de b7       	in	r29, 0x3e	; 62
    1c22:	2a 97       	sbiw	r28, 0x0a	; 10
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	de bf       	out	0x3e, r29	; 62
    1c2a:	0f be       	out	0x3f, r0	; 63
    1c2c:	cd bf       	out	0x3d, r28	; 61
    1c2e:	98 87       	std	Y+8, r25	; 0x08
    1c30:	8f 83       	std	Y+7, r24	; 0x07
    1c32:	7a 87       	std	Y+10, r23	; 0x0a
    1c34:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1c36:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1c38:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1c3c:	80 91 56 04 	lds	r24, 0x0456
    1c40:	90 91 57 04 	lds	r25, 0x0457
    1c44:	9a 83       	std	Y+2, r25	; 0x02
    1c46:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c48:	ef 81       	ldd	r30, Y+7	; 0x07
    1c4a:	f8 85       	ldd	r31, Y+8	; 0x08
    1c4c:	20 81       	ld	r18, Z
    1c4e:	31 81       	ldd	r19, Z+1	; 0x01
    1c50:	89 85       	ldd	r24, Y+9	; 0x09
    1c52:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c54:	82 0f       	add	r24, r18
    1c56:	93 1f       	adc	r25, r19
    1c58:	9e 83       	std	Y+6, r25	; 0x06
    1c5a:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    1c5c:	ef 81       	ldd	r30, Y+7	; 0x07
    1c5e:	f8 85       	ldd	r31, Y+8	; 0x08
    1c60:	20 81       	ld	r18, Z
    1c62:	31 81       	ldd	r19, Z+1	; 0x01
    1c64:	89 81       	ldd	r24, Y+1	; 0x01
    1c66:	9a 81       	ldd	r25, Y+2	; 0x02
    1c68:	82 17       	cp	r24, r18
    1c6a:	93 07       	cpc	r25, r19
    1c6c:	98 f4       	brcc	.+38     	; 0x1c94 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1c6e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c70:	f8 85       	ldd	r31, Y+8	; 0x08
    1c72:	20 81       	ld	r18, Z
    1c74:	31 81       	ldd	r19, Z+1	; 0x01
    1c76:	8d 81       	ldd	r24, Y+5	; 0x05
    1c78:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7a:	82 17       	cp	r24, r18
    1c7c:	93 07       	cpc	r25, r19
    1c7e:	e0 f4       	brcc	.+56     	; 0x1cb8 <vTaskDelayUntil+0x9e>
    1c80:	2d 81       	ldd	r18, Y+5	; 0x05
    1c82:	3e 81       	ldd	r19, Y+6	; 0x06
    1c84:	89 81       	ldd	r24, Y+1	; 0x01
    1c86:	9a 81       	ldd	r25, Y+2	; 0x02
    1c88:	82 17       	cp	r24, r18
    1c8a:	93 07       	cpc	r25, r19
    1c8c:	a8 f4       	brcc	.+42     	; 0x1cb8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	8b 83       	std	Y+3, r24	; 0x03
    1c92:	12 c0       	rjmp	.+36     	; 0x1cb8 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1c94:	ef 81       	ldd	r30, Y+7	; 0x07
    1c96:	f8 85       	ldd	r31, Y+8	; 0x08
    1c98:	20 81       	ld	r18, Z
    1c9a:	31 81       	ldd	r19, Z+1	; 0x01
    1c9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9e:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca0:	82 17       	cp	r24, r18
    1ca2:	93 07       	cpc	r25, r19
    1ca4:	38 f0       	brcs	.+14     	; 0x1cb4 <vTaskDelayUntil+0x9a>
    1ca6:	2d 81       	ldd	r18, Y+5	; 0x05
    1ca8:	3e 81       	ldd	r19, Y+6	; 0x06
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	9a 81       	ldd	r25, Y+2	; 0x02
    1cae:	82 17       	cp	r24, r18
    1cb0:	93 07       	cpc	r25, r19
    1cb2:	10 f4       	brcc	.+4      	; 0x1cb8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1cb8:	ef 81       	ldd	r30, Y+7	; 0x07
    1cba:	f8 85       	ldd	r31, Y+8	; 0x08
    1cbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1cbe:	9e 81       	ldd	r25, Y+6	; 0x06
    1cc0:	91 83       	std	Z+1, r25	; 0x01
    1cc2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc6:	88 23       	and	r24, r24
    1cc8:	49 f0       	breq	.+18     	; 0x1cdc <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1cca:	8d 81       	ldd	r24, Y+5	; 0x05
    1ccc:	9e 81       	ldd	r25, Y+6	; 0x06
    1cce:	29 81       	ldd	r18, Y+1	; 0x01
    1cd0:	3a 81       	ldd	r19, Y+2	; 0x02
    1cd2:	82 1b       	sub	r24, r18
    1cd4:	93 0b       	sbc	r25, r19
    1cd6:	60 e0       	ldi	r22, 0x00	; 0
    1cd8:	0e 94 95 1a 	call	0x352a	; 0x352a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1cdc:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1ce0:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ce2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ce4:	88 23       	and	r24, r24
    1ce6:	11 f4       	brne	.+4      	; 0x1cec <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    1ce8:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1cec:	2a 96       	adiw	r28, 0x0a	; 10
    1cee:	0f b6       	in	r0, 0x3f	; 63
    1cf0:	f8 94       	cli
    1cf2:	de bf       	out	0x3e, r29	; 62
    1cf4:	0f be       	out	0x3f, r0	; 63
    1cf6:	cd bf       	out	0x3d, r28	; 61
    1cf8:	cf 91       	pop	r28
    1cfa:	df 91       	pop	r29
    1cfc:	08 95       	ret

00001cfe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1cfe:	df 93       	push	r29
    1d00:	cf 93       	push	r28
    1d02:	00 d0       	rcall	.+0      	; 0x1d04 <vTaskDelay+0x6>
    1d04:	0f 92       	push	r0
    1d06:	cd b7       	in	r28, 0x3d	; 61
    1d08:	de b7       	in	r29, 0x3e	; 62
    1d0a:	9b 83       	std	Y+3, r25	; 0x03
    1d0c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    1d0e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1d10:	8a 81       	ldd	r24, Y+2	; 0x02
    1d12:	9b 81       	ldd	r25, Y+3	; 0x03
    1d14:	00 97       	sbiw	r24, 0x00	; 0
    1d16:	51 f0       	breq	.+20     	; 0x1d2c <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1d18:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1d1c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d1e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d20:	60 e0       	ldi	r22, 0x00	; 0
    1d22:	0e 94 95 1a 	call	0x352a	; 0x352a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1d26:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1d2a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d2c:	89 81       	ldd	r24, Y+1	; 0x01
    1d2e:	88 23       	and	r24, r24
    1d30:	11 f4       	brne	.+4      	; 0x1d36 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    1d32:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
    1d3c:	cf 91       	pop	r28
    1d3e:	df 91       	pop	r29
    1d40:	08 95       	ret

00001d42 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    1d42:	df 93       	push	r29
    1d44:	cf 93       	push	r28
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
    1d4a:	27 97       	sbiw	r28, 0x07	; 7
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	f8 94       	cli
    1d50:	de bf       	out	0x3e, r29	; 62
    1d52:	0f be       	out	0x3f, r0	; 63
    1d54:	cd bf       	out	0x3d, r28	; 61
    1d56:	9d 83       	std	Y+5, r25	; 0x05
    1d58:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1d5a:	0f b6       	in	r0, 0x3f	; 63
    1d5c:	f8 94       	cli
    1d5e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1d60:	8c 81       	ldd	r24, Y+4	; 0x04
    1d62:	9d 81       	ldd	r25, Y+5	; 0x05
    1d64:	00 97       	sbiw	r24, 0x00	; 0
    1d66:	39 f4       	brne	.+14     	; 0x1d76 <uxTaskPriorityGet+0x34>
    1d68:	80 91 52 04 	lds	r24, 0x0452
    1d6c:	90 91 53 04 	lds	r25, 0x0453
    1d70:	9f 83       	std	Y+7, r25	; 0x07
    1d72:	8e 83       	std	Y+6, r24	; 0x06
    1d74:	04 c0       	rjmp	.+8      	; 0x1d7e <uxTaskPriorityGet+0x3c>
    1d76:	8c 81       	ldd	r24, Y+4	; 0x04
    1d78:	9d 81       	ldd	r25, Y+5	; 0x05
    1d7a:	9f 83       	std	Y+7, r25	; 0x07
    1d7c:	8e 83       	std	Y+6, r24	; 0x06
    1d7e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d80:	9f 81       	ldd	r25, Y+7	; 0x07
    1d82:	9b 83       	std	Y+3, r25	; 0x03
    1d84:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    1d86:	ea 81       	ldd	r30, Y+2	; 0x02
    1d88:	fb 81       	ldd	r31, Y+3	; 0x03
    1d8a:	86 89       	ldd	r24, Z+22	; 0x16
    1d8c:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    1d8e:	0f 90       	pop	r0
    1d90:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    1d92:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1d94:	27 96       	adiw	r28, 0x07	; 7
    1d96:	0f b6       	in	r0, 0x3f	; 63
    1d98:	f8 94       	cli
    1d9a:	de bf       	out	0x3e, r29	; 62
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	cd bf       	out	0x3d, r28	; 61
    1da0:	cf 91       	pop	r28
    1da2:	df 91       	pop	r29
    1da4:	08 95       	ret

00001da6 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    1da6:	df 93       	push	r29
    1da8:	cf 93       	push	r28
    1daa:	cd b7       	in	r28, 0x3d	; 61
    1dac:	de b7       	in	r29, 0x3e	; 62
    1dae:	28 97       	sbiw	r28, 0x08	; 8
    1db0:	0f b6       	in	r0, 0x3f	; 63
    1db2:	f8 94       	cli
    1db4:	de bf       	out	0x3e, r29	; 62
    1db6:	0f be       	out	0x3f, r0	; 63
    1db8:	cd bf       	out	0x3d, r28	; 61
    1dba:	9e 83       	std	Y+6, r25	; 0x06
    1dbc:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    1dbe:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1dc0:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc2:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc4:	00 97       	sbiw	r24, 0x00	; 0
    1dc6:	39 f4       	brne	.+14     	; 0x1dd6 <uxTaskPriorityGetFromISR+0x30>
    1dc8:	80 91 52 04 	lds	r24, 0x0452
    1dcc:	90 91 53 04 	lds	r25, 0x0453
    1dd0:	98 87       	std	Y+8, r25	; 0x08
    1dd2:	8f 83       	std	Y+7, r24	; 0x07
    1dd4:	04 c0       	rjmp	.+8      	; 0x1dde <uxTaskPriorityGetFromISR+0x38>
    1dd6:	8d 81       	ldd	r24, Y+5	; 0x05
    1dd8:	9e 81       	ldd	r25, Y+6	; 0x06
    1dda:	98 87       	std	Y+8, r25	; 0x08
    1ddc:	8f 83       	std	Y+7, r24	; 0x07
    1dde:	8f 81       	ldd	r24, Y+7	; 0x07
    1de0:	98 85       	ldd	r25, Y+8	; 0x08
    1de2:	9c 83       	std	Y+4, r25	; 0x04
    1de4:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    1de6:	eb 81       	ldd	r30, Y+3	; 0x03
    1de8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dea:	86 89       	ldd	r24, Z+22	; 0x16
    1dec:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    1dee:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    1df0:	28 96       	adiw	r28, 0x08	; 8
    1df2:	0f b6       	in	r0, 0x3f	; 63
    1df4:	f8 94       	cli
    1df6:	de bf       	out	0x3e, r29	; 62
    1df8:	0f be       	out	0x3f, r0	; 63
    1dfa:	cd bf       	out	0x3d, r28	; 61
    1dfc:	cf 91       	pop	r28
    1dfe:	df 91       	pop	r29
    1e00:	08 95       	ret

00001e02 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1e02:	df 93       	push	r29
    1e04:	cf 93       	push	r28
    1e06:	cd b7       	in	r28, 0x3d	; 61
    1e08:	de b7       	in	r29, 0x3e	; 62
    1e0a:	2a 97       	sbiw	r28, 0x0a	; 10
    1e0c:	0f b6       	in	r0, 0x3f	; 63
    1e0e:	f8 94       	cli
    1e10:	de bf       	out	0x3e, r29	; 62
    1e12:	0f be       	out	0x3f, r0	; 63
    1e14:	cd bf       	out	0x3d, r28	; 61
    1e16:	9f 83       	std	Y+7, r25	; 0x07
    1e18:	8e 83       	std	Y+6, r24	; 0x06
    1e1a:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1e1c:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1e1e:	88 85       	ldd	r24, Y+8	; 0x08
    1e20:	85 30       	cpi	r24, 0x05	; 5
    1e22:	10 f0       	brcs	.+4      	; 0x1e28 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1e24:	84 e0       	ldi	r24, 0x04	; 4
    1e26:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1e28:	0f b6       	in	r0, 0x3f	; 63
    1e2a:	f8 94       	cli
    1e2c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1e2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1e30:	9f 81       	ldd	r25, Y+7	; 0x07
    1e32:	00 97       	sbiw	r24, 0x00	; 0
    1e34:	39 f4       	brne	.+14     	; 0x1e44 <vTaskPrioritySet+0x42>
    1e36:	80 91 52 04 	lds	r24, 0x0452
    1e3a:	90 91 53 04 	lds	r25, 0x0453
    1e3e:	9a 87       	std	Y+10, r25	; 0x0a
    1e40:	89 87       	std	Y+9, r24	; 0x09
    1e42:	04 c0       	rjmp	.+8      	; 0x1e4c <vTaskPrioritySet+0x4a>
    1e44:	8e 81       	ldd	r24, Y+6	; 0x06
    1e46:	9f 81       	ldd	r25, Y+7	; 0x07
    1e48:	9a 87       	std	Y+10, r25	; 0x0a
    1e4a:	89 87       	std	Y+9, r24	; 0x09
    1e4c:	89 85       	ldd	r24, Y+9	; 0x09
    1e4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e50:	9d 83       	std	Y+5, r25	; 0x05
    1e52:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    1e54:	ec 81       	ldd	r30, Y+4	; 0x04
    1e56:	fd 81       	ldd	r31, Y+5	; 0x05
    1e58:	86 89       	ldd	r24, Z+22	; 0x16
    1e5a:	8b 83       	std	Y+3, r24	; 0x03
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1e5c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e5e:	88 85       	ldd	r24, Y+8	; 0x08
    1e60:	98 17       	cp	r25, r24
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <vTaskPrioritySet+0x64>
    1e64:	81 c0       	rjmp	.+258    	; 0x1f68 <vTaskPrioritySet+0x166>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1e66:	98 85       	ldd	r25, Y+8	; 0x08
    1e68:	8b 81       	ldd	r24, Y+3	; 0x03
    1e6a:	89 17       	cp	r24, r25
    1e6c:	a0 f4       	brcc	.+40     	; 0x1e96 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    1e6e:	20 91 52 04 	lds	r18, 0x0452
    1e72:	30 91 53 04 	lds	r19, 0x0453
    1e76:	8c 81       	ldd	r24, Y+4	; 0x04
    1e78:	9d 81       	ldd	r25, Y+5	; 0x05
    1e7a:	82 17       	cp	r24, r18
    1e7c:	93 07       	cpc	r25, r19
    1e7e:	b1 f0       	breq	.+44     	; 0x1eac <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1e80:	e0 91 52 04 	lds	r30, 0x0452
    1e84:	f0 91 53 04 	lds	r31, 0x0453
    1e88:	96 89       	ldd	r25, Z+22	; 0x16
    1e8a:	88 85       	ldd	r24, Y+8	; 0x08
    1e8c:	89 17       	cp	r24, r25
    1e8e:	70 f0       	brcs	.+28     	; 0x1eac <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    1e90:	81 e0       	ldi	r24, 0x01	; 1
    1e92:	89 83       	std	Y+1, r24	; 0x01
    1e94:	0b c0       	rjmp	.+22     	; 0x1eac <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1e96:	20 91 52 04 	lds	r18, 0x0452
    1e9a:	30 91 53 04 	lds	r19, 0x0453
    1e9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1ea0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ea2:	82 17       	cp	r24, r18
    1ea4:	93 07       	cpc	r25, r19
    1ea6:	11 f4       	brne	.+4      	; 0x1eac <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    1ea8:	81 e0       	ldi	r24, 0x01	; 1
    1eaa:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1eac:	ec 81       	ldd	r30, Y+4	; 0x04
    1eae:	fd 81       	ldd	r31, Y+5	; 0x05
    1eb0:	86 89       	ldd	r24, Z+22	; 0x16
    1eb2:	8a 83       	std	Y+2, r24	; 0x02
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    1eb4:	ec 81       	ldd	r30, Y+4	; 0x04
    1eb6:	fd 81       	ldd	r31, Y+5	; 0x05
    1eb8:	88 85       	ldd	r24, Y+8	; 0x08
    1eba:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1ebc:	ec 81       	ldd	r30, Y+4	; 0x04
    1ebe:	fd 81       	ldd	r31, Y+5	; 0x05
    1ec0:	84 85       	ldd	r24, Z+12	; 0x0c
    1ec2:	95 85       	ldd	r25, Z+13	; 0x0d
    1ec4:	99 23       	and	r25, r25
    1ec6:	5c f0       	brlt	.+22     	; 0x1ede <vTaskPrioritySet+0xdc>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ec8:	88 85       	ldd	r24, Y+8	; 0x08
    1eca:	28 2f       	mov	r18, r24
    1ecc:	30 e0       	ldi	r19, 0x00	; 0
    1ece:	85 e0       	ldi	r24, 0x05	; 5
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	82 1b       	sub	r24, r18
    1ed4:	93 0b       	sbc	r25, r19
    1ed6:	ec 81       	ldd	r30, Y+4	; 0x04
    1ed8:	fd 81       	ldd	r31, Y+5	; 0x05
    1eda:	95 87       	std	Z+13, r25	; 0x0d
    1edc:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1ede:	ec 81       	ldd	r30, Y+4	; 0x04
    1ee0:	fd 81       	ldd	r31, Y+5	; 0x05
    1ee2:	42 85       	ldd	r20, Z+10	; 0x0a
    1ee4:	53 85       	ldd	r21, Z+11	; 0x0b
    1ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee8:	28 2f       	mov	r18, r24
    1eea:	30 e0       	ldi	r19, 0x00	; 0
    1eec:	c9 01       	movw	r24, r18
    1eee:	88 0f       	add	r24, r24
    1ef0:	99 1f       	adc	r25, r25
    1ef2:	88 0f       	add	r24, r24
    1ef4:	99 1f       	adc	r25, r25
    1ef6:	88 0f       	add	r24, r24
    1ef8:	99 1f       	adc	r25, r25
    1efa:	82 0f       	add	r24, r18
    1efc:	93 1f       	adc	r25, r19
    1efe:	8c 59       	subi	r24, 0x9C	; 156
    1f00:	9b 4f       	sbci	r25, 0xFB	; 251
    1f02:	48 17       	cp	r20, r24
    1f04:	59 07       	cpc	r21, r25
    1f06:	59 f5       	brne	.+86     	; 0x1f5e <vTaskPrioritySet+0x15c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1f08:	8c 81       	ldd	r24, Y+4	; 0x04
    1f0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f0c:	02 96       	adiw	r24, 0x02	; 2
    1f0e:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1f12:	ec 81       	ldd	r30, Y+4	; 0x04
    1f14:	fd 81       	ldd	r31, Y+5	; 0x05
    1f16:	96 89       	ldd	r25, Z+22	; 0x16
    1f18:	80 91 58 04 	lds	r24, 0x0458
    1f1c:	89 17       	cp	r24, r25
    1f1e:	28 f4       	brcc	.+10     	; 0x1f2a <vTaskPrioritySet+0x128>
    1f20:	ec 81       	ldd	r30, Y+4	; 0x04
    1f22:	fd 81       	ldd	r31, Y+5	; 0x05
    1f24:	86 89       	ldd	r24, Z+22	; 0x16
    1f26:	80 93 58 04 	sts	0x0458, r24
    1f2a:	ec 81       	ldd	r30, Y+4	; 0x04
    1f2c:	fd 81       	ldd	r31, Y+5	; 0x05
    1f2e:	86 89       	ldd	r24, Z+22	; 0x16
    1f30:	28 2f       	mov	r18, r24
    1f32:	30 e0       	ldi	r19, 0x00	; 0
    1f34:	c9 01       	movw	r24, r18
    1f36:	88 0f       	add	r24, r24
    1f38:	99 1f       	adc	r25, r25
    1f3a:	88 0f       	add	r24, r24
    1f3c:	99 1f       	adc	r25, r25
    1f3e:	88 0f       	add	r24, r24
    1f40:	99 1f       	adc	r25, r25
    1f42:	82 0f       	add	r24, r18
    1f44:	93 1f       	adc	r25, r19
    1f46:	ac 01       	movw	r20, r24
    1f48:	4c 59       	subi	r20, 0x9C	; 156
    1f4a:	5b 4f       	sbci	r21, 0xFB	; 251
    1f4c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f4e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f50:	9c 01       	movw	r18, r24
    1f52:	2e 5f       	subi	r18, 0xFE	; 254
    1f54:	3f 4f       	sbci	r19, 0xFF	; 255
    1f56:	ca 01       	movw	r24, r20
    1f58:	b9 01       	movw	r22, r18
    1f5a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    1f5e:	89 81       	ldd	r24, Y+1	; 0x01
    1f60:	88 23       	and	r24, r24
    1f62:	11 f0       	breq	.+4      	; 0x1f68 <vTaskPrioritySet+0x166>
				{
					taskYIELD_IF_USING_PREEMPTION();
    1f64:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1f68:	0f 90       	pop	r0
    1f6a:	0f be       	out	0x3f, r0	; 63
	}
    1f6c:	2a 96       	adiw	r28, 0x0a	; 10
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	f8 94       	cli
    1f72:	de bf       	out	0x3e, r29	; 62
    1f74:	0f be       	out	0x3f, r0	; 63
    1f76:	cd bf       	out	0x3d, r28	; 61
    1f78:	cf 91       	pop	r28
    1f7a:	df 91       	pop	r29
    1f7c:	08 95       	ret

00001f7e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    1f7e:	df 93       	push	r29
    1f80:	cf 93       	push	r28
    1f82:	00 d0       	rcall	.+0      	; 0x1f84 <vTaskSuspend+0x6>
    1f84:	00 d0       	rcall	.+0      	; 0x1f86 <vTaskSuspend+0x8>
    1f86:	00 d0       	rcall	.+0      	; 0x1f88 <vTaskSuspend+0xa>
    1f88:	cd b7       	in	r28, 0x3d	; 61
    1f8a:	de b7       	in	r29, 0x3e	; 62
    1f8c:	9c 83       	std	Y+4, r25	; 0x04
    1f8e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1f90:	0f b6       	in	r0, 0x3f	; 63
    1f92:	f8 94       	cli
    1f94:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    1f96:	8b 81       	ldd	r24, Y+3	; 0x03
    1f98:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9a:	00 97       	sbiw	r24, 0x00	; 0
    1f9c:	39 f4       	brne	.+14     	; 0x1fac <vTaskSuspend+0x2e>
    1f9e:	80 91 52 04 	lds	r24, 0x0452
    1fa2:	90 91 53 04 	lds	r25, 0x0453
    1fa6:	9e 83       	std	Y+6, r25	; 0x06
    1fa8:	8d 83       	std	Y+5, r24	; 0x05
    1faa:	04 c0       	rjmp	.+8      	; 0x1fb4 <vTaskSuspend+0x36>
    1fac:	8b 81       	ldd	r24, Y+3	; 0x03
    1fae:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb0:	9e 83       	std	Y+6, r25	; 0x06
    1fb2:	8d 83       	std	Y+5, r24	; 0x05
    1fb4:	8d 81       	ldd	r24, Y+5	; 0x05
    1fb6:	9e 81       	ldd	r25, Y+6	; 0x06
    1fb8:	9a 83       	std	Y+2, r25	; 0x02
    1fba:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1fbc:	89 81       	ldd	r24, Y+1	; 0x01
    1fbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc0:	02 96       	adiw	r24, 0x02	; 2
    1fc2:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fca:	84 89       	ldd	r24, Z+20	; 0x14
    1fcc:	95 89       	ldd	r25, Z+21	; 0x15
    1fce:	00 97       	sbiw	r24, 0x00	; 0
    1fd0:	29 f0       	breq	.+10     	; 0x1fdc <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1fd2:	89 81       	ldd	r24, Y+1	; 0x01
    1fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd6:	0c 96       	adiw	r24, 0x0c	; 12
    1fd8:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    1fdc:	89 81       	ldd	r24, Y+1	; 0x01
    1fde:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe0:	9c 01       	movw	r18, r24
    1fe2:	2e 5f       	subi	r18, 0xFE	; 254
    1fe4:	3f 4f       	sbci	r19, 0xFF	; 255
    1fe6:	89 eb       	ldi	r24, 0xB9	; 185
    1fe8:	94 e0       	ldi	r25, 0x04	; 4
    1fea:	b9 01       	movw	r22, r18
    1fec:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    1ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff4:	85 a1       	ldd	r24, Z+37	; 0x25
    1ff6:	81 30       	cpi	r24, 0x01	; 1
    1ff8:	19 f4       	brne	.+6      	; 0x2000 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1ffa:	e9 81       	ldd	r30, Y+1	; 0x01
    1ffc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ffe:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    2000:	0f 90       	pop	r0
    2002:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    2004:	80 91 59 04 	lds	r24, 0x0459
    2008:	88 23       	and	r24, r24
    200a:	39 f0       	breq	.+14     	; 0x201a <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    2012:	0e 94 40 16 	call	0x2c80	; 0x2c80 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    2016:	0f 90       	pop	r0
    2018:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    201a:	20 91 52 04 	lds	r18, 0x0452
    201e:	30 91 53 04 	lds	r19, 0x0453
    2022:	89 81       	ldd	r24, Y+1	; 0x01
    2024:	9a 81       	ldd	r25, Y+2	; 0x02
    2026:	82 17       	cp	r24, r18
    2028:	93 07       	cpc	r25, r19
    202a:	a1 f4       	brne	.+40     	; 0x2054 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    202c:	80 91 59 04 	lds	r24, 0x0459
    2030:	88 23       	and	r24, r24
    2032:	19 f0       	breq	.+6      	; 0x203a <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2034:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
    2038:	0d c0       	rjmp	.+26     	; 0x2054 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    203a:	90 91 b9 04 	lds	r25, 0x04B9
    203e:	80 91 55 04 	lds	r24, 0x0455
    2042:	98 17       	cp	r25, r24
    2044:	29 f4       	brne	.+10     	; 0x2050 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2046:	10 92 53 04 	sts	0x0453, r1
    204a:	10 92 52 04 	sts	0x0452, r1
    204e:	02 c0       	rjmp	.+4      	; 0x2054 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    2050:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2054:	26 96       	adiw	r28, 0x06	; 6
    2056:	0f b6       	in	r0, 0x3f	; 63
    2058:	f8 94       	cli
    205a:	de bf       	out	0x3e, r29	; 62
    205c:	0f be       	out	0x3f, r0	; 63
    205e:	cd bf       	out	0x3d, r28	; 61
    2060:	cf 91       	pop	r28
    2062:	df 91       	pop	r29
    2064:	08 95       	ret

00002066 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    2066:	df 93       	push	r29
    2068:	cf 93       	push	r28
    206a:	00 d0       	rcall	.+0      	; 0x206c <prvTaskIsTaskSuspended+0x6>
    206c:	00 d0       	rcall	.+0      	; 0x206e <prvTaskIsTaskSuspended+0x8>
    206e:	0f 92       	push	r0
    2070:	cd b7       	in	r28, 0x3d	; 61
    2072:	de b7       	in	r29, 0x3e	; 62
    2074:	9d 83       	std	Y+5, r25	; 0x05
    2076:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    2078:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    207a:	8c 81       	ldd	r24, Y+4	; 0x04
    207c:	9d 81       	ldd	r25, Y+5	; 0x05
    207e:	9a 83       	std	Y+2, r25	; 0x02
    2080:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    2082:	e9 81       	ldd	r30, Y+1	; 0x01
    2084:	fa 81       	ldd	r31, Y+2	; 0x02
    2086:	82 85       	ldd	r24, Z+10	; 0x0a
    2088:	93 85       	ldd	r25, Z+11	; 0x0b
    208a:	24 e0       	ldi	r18, 0x04	; 4
    208c:	89 3b       	cpi	r24, 0xB9	; 185
    208e:	92 07       	cpc	r25, r18
    2090:	81 f4       	brne	.+32     	; 0x20b2 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    2092:	e9 81       	ldd	r30, Y+1	; 0x01
    2094:	fa 81       	ldd	r31, Y+2	; 0x02
    2096:	84 89       	ldd	r24, Z+20	; 0x14
    2098:	95 89       	ldd	r25, Z+21	; 0x15
    209a:	24 e0       	ldi	r18, 0x04	; 4
    209c:	87 3a       	cpi	r24, 0xA7	; 167
    209e:	92 07       	cpc	r25, r18
    20a0:	41 f0       	breq	.+16     	; 0x20b2 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    20a2:	e9 81       	ldd	r30, Y+1	; 0x01
    20a4:	fa 81       	ldd	r31, Y+2	; 0x02
    20a6:	84 89       	ldd	r24, Z+20	; 0x14
    20a8:	95 89       	ldd	r25, Z+21	; 0x15
    20aa:	00 97       	sbiw	r24, 0x00	; 0
    20ac:	11 f4       	brne	.+4      	; 0x20b2 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    20ae:	81 e0       	ldi	r24, 0x01	; 1
    20b0:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    20b2:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    20b4:	0f 90       	pop	r0
    20b6:	0f 90       	pop	r0
    20b8:	0f 90       	pop	r0
    20ba:	0f 90       	pop	r0
    20bc:	0f 90       	pop	r0
    20be:	cf 91       	pop	r28
    20c0:	df 91       	pop	r29
    20c2:	08 95       	ret

000020c4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    20c4:	df 93       	push	r29
    20c6:	cf 93       	push	r28
    20c8:	00 d0       	rcall	.+0      	; 0x20ca <vTaskResume+0x6>
    20ca:	00 d0       	rcall	.+0      	; 0x20cc <vTaskResume+0x8>
    20cc:	cd b7       	in	r28, 0x3d	; 61
    20ce:	de b7       	in	r29, 0x3e	; 62
    20d0:	9c 83       	std	Y+4, r25	; 0x04
    20d2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    20d4:	8b 81       	ldd	r24, Y+3	; 0x03
    20d6:	9c 81       	ldd	r25, Y+4	; 0x04
    20d8:	9a 83       	std	Y+2, r25	; 0x02
    20da:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    20dc:	20 91 52 04 	lds	r18, 0x0452
    20e0:	30 91 53 04 	lds	r19, 0x0453
    20e4:	89 81       	ldd	r24, Y+1	; 0x01
    20e6:	9a 81       	ldd	r25, Y+2	; 0x02
    20e8:	82 17       	cp	r24, r18
    20ea:	93 07       	cpc	r25, r19
    20ec:	09 f4       	brne	.+2      	; 0x20f0 <vTaskResume+0x2c>
    20ee:	47 c0       	rjmp	.+142    	; 0x217e <vTaskResume+0xba>
    20f0:	89 81       	ldd	r24, Y+1	; 0x01
    20f2:	9a 81       	ldd	r25, Y+2	; 0x02
    20f4:	00 97       	sbiw	r24, 0x00	; 0
    20f6:	09 f4       	brne	.+2      	; 0x20fa <vTaskResume+0x36>
    20f8:	42 c0       	rjmp	.+132    	; 0x217e <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	f8 94       	cli
    20fe:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2100:	89 81       	ldd	r24, Y+1	; 0x01
    2102:	9a 81       	ldd	r25, Y+2	; 0x02
    2104:	0e 94 33 10 	call	0x2066	; 0x2066 <prvTaskIsTaskSuspended>
    2108:	88 23       	and	r24, r24
    210a:	b9 f1       	breq	.+110    	; 0x217a <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	9a 81       	ldd	r25, Y+2	; 0x02
    2110:	02 96       	adiw	r24, 0x02	; 2
    2112:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2116:	e9 81       	ldd	r30, Y+1	; 0x01
    2118:	fa 81       	ldd	r31, Y+2	; 0x02
    211a:	96 89       	ldd	r25, Z+22	; 0x16
    211c:	80 91 58 04 	lds	r24, 0x0458
    2120:	89 17       	cp	r24, r25
    2122:	28 f4       	brcc	.+10     	; 0x212e <vTaskResume+0x6a>
    2124:	e9 81       	ldd	r30, Y+1	; 0x01
    2126:	fa 81       	ldd	r31, Y+2	; 0x02
    2128:	86 89       	ldd	r24, Z+22	; 0x16
    212a:	80 93 58 04 	sts	0x0458, r24
    212e:	e9 81       	ldd	r30, Y+1	; 0x01
    2130:	fa 81       	ldd	r31, Y+2	; 0x02
    2132:	86 89       	ldd	r24, Z+22	; 0x16
    2134:	28 2f       	mov	r18, r24
    2136:	30 e0       	ldi	r19, 0x00	; 0
    2138:	c9 01       	movw	r24, r18
    213a:	88 0f       	add	r24, r24
    213c:	99 1f       	adc	r25, r25
    213e:	88 0f       	add	r24, r24
    2140:	99 1f       	adc	r25, r25
    2142:	88 0f       	add	r24, r24
    2144:	99 1f       	adc	r25, r25
    2146:	82 0f       	add	r24, r18
    2148:	93 1f       	adc	r25, r19
    214a:	ac 01       	movw	r20, r24
    214c:	4c 59       	subi	r20, 0x9C	; 156
    214e:	5b 4f       	sbci	r21, 0xFB	; 251
    2150:	89 81       	ldd	r24, Y+1	; 0x01
    2152:	9a 81       	ldd	r25, Y+2	; 0x02
    2154:	9c 01       	movw	r18, r24
    2156:	2e 5f       	subi	r18, 0xFE	; 254
    2158:	3f 4f       	sbci	r19, 0xFF	; 255
    215a:	ca 01       	movw	r24, r20
    215c:	b9 01       	movw	r22, r18
    215e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2162:	e9 81       	ldd	r30, Y+1	; 0x01
    2164:	fa 81       	ldd	r31, Y+2	; 0x02
    2166:	96 89       	ldd	r25, Z+22	; 0x16
    2168:	e0 91 52 04 	lds	r30, 0x0452
    216c:	f0 91 53 04 	lds	r31, 0x0453
    2170:	86 89       	ldd	r24, Z+22	; 0x16
    2172:	98 17       	cp	r25, r24
    2174:	10 f0       	brcs	.+4      	; 0x217a <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    2176:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    217a:	0f 90       	pop	r0
    217c:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    217e:	0f 90       	pop	r0
    2180:	0f 90       	pop	r0
    2182:	0f 90       	pop	r0
    2184:	0f 90       	pop	r0
    2186:	cf 91       	pop	r28
    2188:	df 91       	pop	r29
    218a:	08 95       	ret

0000218c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    218c:	df 93       	push	r29
    218e:	cf 93       	push	r28
    2190:	00 d0       	rcall	.+0      	; 0x2192 <xTaskResumeFromISR+0x6>
    2192:	00 d0       	rcall	.+0      	; 0x2194 <xTaskResumeFromISR+0x8>
    2194:	00 d0       	rcall	.+0      	; 0x2196 <xTaskResumeFromISR+0xa>
    2196:	cd b7       	in	r28, 0x3d	; 61
    2198:	de b7       	in	r29, 0x3e	; 62
    219a:	9e 83       	std	Y+6, r25	; 0x06
    219c:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    219e:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    21a0:	8d 81       	ldd	r24, Y+5	; 0x05
    21a2:	9e 81       	ldd	r25, Y+6	; 0x06
    21a4:	9b 83       	std	Y+3, r25	; 0x03
    21a6:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21a8:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    21aa:	8a 81       	ldd	r24, Y+2	; 0x02
    21ac:	9b 81       	ldd	r25, Y+3	; 0x03
    21ae:	0e 94 33 10 	call	0x2066	; 0x2066 <prvTaskIsTaskSuspended>
    21b2:	88 23       	and	r24, r24
    21b4:	09 f4       	brne	.+2      	; 0x21b8 <xTaskResumeFromISR+0x2c>
    21b6:	46 c0       	rjmp	.+140    	; 0x2244 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    21b8:	80 91 63 04 	lds	r24, 0x0463
    21bc:	88 23       	and	r24, r24
    21be:	c1 f5       	brne	.+112    	; 0x2230 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21c0:	ea 81       	ldd	r30, Y+2	; 0x02
    21c2:	fb 81       	ldd	r31, Y+3	; 0x03
    21c4:	96 89       	ldd	r25, Z+22	; 0x16
    21c6:	e0 91 52 04 	lds	r30, 0x0452
    21ca:	f0 91 53 04 	lds	r31, 0x0453
    21ce:	86 89       	ldd	r24, Z+22	; 0x16
    21d0:	98 17       	cp	r25, r24
    21d2:	10 f0       	brcs	.+4      	; 0x21d8 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    21d8:	8a 81       	ldd	r24, Y+2	; 0x02
    21da:	9b 81       	ldd	r25, Y+3	; 0x03
    21dc:	02 96       	adiw	r24, 0x02	; 2
    21de:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    21e2:	ea 81       	ldd	r30, Y+2	; 0x02
    21e4:	fb 81       	ldd	r31, Y+3	; 0x03
    21e6:	96 89       	ldd	r25, Z+22	; 0x16
    21e8:	80 91 58 04 	lds	r24, 0x0458
    21ec:	89 17       	cp	r24, r25
    21ee:	28 f4       	brcc	.+10     	; 0x21fa <xTaskResumeFromISR+0x6e>
    21f0:	ea 81       	ldd	r30, Y+2	; 0x02
    21f2:	fb 81       	ldd	r31, Y+3	; 0x03
    21f4:	86 89       	ldd	r24, Z+22	; 0x16
    21f6:	80 93 58 04 	sts	0x0458, r24
    21fa:	ea 81       	ldd	r30, Y+2	; 0x02
    21fc:	fb 81       	ldd	r31, Y+3	; 0x03
    21fe:	86 89       	ldd	r24, Z+22	; 0x16
    2200:	28 2f       	mov	r18, r24
    2202:	30 e0       	ldi	r19, 0x00	; 0
    2204:	c9 01       	movw	r24, r18
    2206:	88 0f       	add	r24, r24
    2208:	99 1f       	adc	r25, r25
    220a:	88 0f       	add	r24, r24
    220c:	99 1f       	adc	r25, r25
    220e:	88 0f       	add	r24, r24
    2210:	99 1f       	adc	r25, r25
    2212:	82 0f       	add	r24, r18
    2214:	93 1f       	adc	r25, r19
    2216:	ac 01       	movw	r20, r24
    2218:	4c 59       	subi	r20, 0x9C	; 156
    221a:	5b 4f       	sbci	r21, 0xFB	; 251
    221c:	8a 81       	ldd	r24, Y+2	; 0x02
    221e:	9b 81       	ldd	r25, Y+3	; 0x03
    2220:	9c 01       	movw	r18, r24
    2222:	2e 5f       	subi	r18, 0xFE	; 254
    2224:	3f 4f       	sbci	r19, 0xFF	; 255
    2226:	ca 01       	movw	r24, r20
    2228:	b9 01       	movw	r22, r18
    222a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
    222e:	0a c0       	rjmp	.+20     	; 0x2244 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2230:	8a 81       	ldd	r24, Y+2	; 0x02
    2232:	9b 81       	ldd	r25, Y+3	; 0x03
    2234:	9c 01       	movw	r18, r24
    2236:	24 5f       	subi	r18, 0xF4	; 244
    2238:	3f 4f       	sbci	r19, 0xFF	; 255
    223a:	87 ea       	ldi	r24, 0xA7	; 167
    223c:	94 e0       	ldi	r25, 0x04	; 4
    223e:	b9 01       	movw	r22, r18
    2240:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    2244:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    2246:	26 96       	adiw	r28, 0x06	; 6
    2248:	0f b6       	in	r0, 0x3f	; 63
    224a:	f8 94       	cli
    224c:	de bf       	out	0x3e, r29	; 62
    224e:	0f be       	out	0x3f, r0	; 63
    2250:	cd bf       	out	0x3d, r28	; 61
    2252:	cf 91       	pop	r28
    2254:	df 91       	pop	r29
    2256:	08 95       	ret

00002258 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2258:	ef 92       	push	r14
    225a:	ff 92       	push	r15
    225c:	0f 93       	push	r16
    225e:	df 93       	push	r29
    2260:	cf 93       	push	r28
    2262:	0f 92       	push	r0
    2264:	cd b7       	in	r28, 0x3d	; 61
    2266:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2268:	80 eb       	ldi	r24, 0xB0	; 176
    226a:	95 e1       	ldi	r25, 0x15	; 21
    226c:	20 e6       	ldi	r18, 0x60	; 96
    226e:	30 e0       	ldi	r19, 0x00	; 0
    2270:	e1 e6       	ldi	r30, 0x61	; 97
    2272:	f4 e0       	ldi	r31, 0x04	; 4
    2274:	b9 01       	movw	r22, r18
    2276:	4a ef       	ldi	r20, 0xFA	; 250
    2278:	50 e0       	ldi	r21, 0x00	; 0
    227a:	20 e0       	ldi	r18, 0x00	; 0
    227c:	30 e0       	ldi	r19, 0x00	; 0
    227e:	00 e0       	ldi	r16, 0x00	; 0
    2280:	7f 01       	movw	r14, r30
    2282:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskCreate>
    2286:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	81 30       	cpi	r24, 0x01	; 1
    228c:	81 f4       	brne	.+32     	; 0x22ae <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    228e:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2290:	8f ef       	ldi	r24, 0xFF	; 255
    2292:	9f ef       	ldi	r25, 0xFF	; 255
    2294:	90 93 60 04 	sts	0x0460, r25
    2298:	80 93 5f 04 	sts	0x045F, r24
		xSchedulerRunning = pdTRUE;
    229c:	81 e0       	ldi	r24, 0x01	; 1
    229e:	80 93 59 04 	sts	0x0459, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    22a2:	10 92 57 04 	sts	0x0457, r1
    22a6:	10 92 56 04 	sts	0x0456, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    22aa:	0e 94 7e 03 	call	0x6fc	; 0x6fc <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    22ae:	0f 90       	pop	r0
    22b0:	cf 91       	pop	r28
    22b2:	df 91       	pop	r29
    22b4:	0f 91       	pop	r16
    22b6:	ff 90       	pop	r15
    22b8:	ef 90       	pop	r14
    22ba:	08 95       	ret

000022bc <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    22bc:	df 93       	push	r29
    22be:	cf 93       	push	r28
    22c0:	cd b7       	in	r28, 0x3d	; 61
    22c2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    22c4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    22c6:	10 92 59 04 	sts	0x0459, r1
	vPortEndScheduler();
    22ca:	0e 94 b3 03 	call	0x766	; 0x766 <vPortEndScheduler>
}
    22ce:	cf 91       	pop	r28
    22d0:	df 91       	pop	r29
    22d2:	08 95       	ret

000022d4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    22d4:	df 93       	push	r29
    22d6:	cf 93       	push	r28
    22d8:	cd b7       	in	r28, 0x3d	; 61
    22da:	de b7       	in	r29, 0x3e	; 62
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
    22dc:	80 91 63 04 	lds	r24, 0x0463
    22e0:	8f 5f       	subi	r24, 0xFF	; 255
    22e2:	80 93 63 04 	sts	0x0463, r24

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
    22e6:	cf 91       	pop	r28
    22e8:	df 91       	pop	r29
    22ea:	08 95       	ret

000022ec <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    22ec:	df 93       	push	r29
    22ee:	cf 93       	push	r28
    22f0:	00 d0       	rcall	.+0      	; 0x22f2 <xTaskResumeAll+0x6>
    22f2:	00 d0       	rcall	.+0      	; 0x22f4 <xTaskResumeAll+0x8>
    22f4:	0f 92       	push	r0
    22f6:	cd b7       	in	r28, 0x3d	; 61
    22f8:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    22fa:	1d 82       	std	Y+5, r1	; 0x05
    22fc:	1c 82       	std	Y+4, r1	; 0x04
BaseType_t xAlreadyYielded = pdFALSE;
    22fe:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2300:	0f b6       	in	r0, 0x3f	; 63
    2302:	f8 94       	cli
    2304:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2306:	80 91 63 04 	lds	r24, 0x0463
    230a:	81 50       	subi	r24, 0x01	; 1
    230c:	80 93 63 04 	sts	0x0463, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2310:	80 91 63 04 	lds	r24, 0x0463
    2314:	88 23       	and	r24, r24
    2316:	09 f0       	breq	.+2      	; 0x231a <xTaskResumeAll+0x2e>
    2318:	7c c0       	rjmp	.+248    	; 0x2412 <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    231a:	80 91 55 04 	lds	r24, 0x0455
    231e:	88 23       	and	r24, r24
    2320:	09 f4       	brne	.+2      	; 0x2324 <xTaskResumeAll+0x38>
    2322:	77 c0       	rjmp	.+238    	; 0x2412 <xTaskResumeAll+0x126>
    2324:	45 c0       	rjmp	.+138    	; 0x23b0 <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2326:	e0 91 ac 04 	lds	r30, 0x04AC
    232a:	f0 91 ad 04 	lds	r31, 0x04AD
    232e:	86 81       	ldd	r24, Z+6	; 0x06
    2330:	97 81       	ldd	r25, Z+7	; 0x07
    2332:	9d 83       	std	Y+5, r25	; 0x05
    2334:	8c 83       	std	Y+4, r24	; 0x04
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2336:	8c 81       	ldd	r24, Y+4	; 0x04
    2338:	9d 81       	ldd	r25, Y+5	; 0x05
    233a:	0c 96       	adiw	r24, 0x0c	; 12
    233c:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2340:	8c 81       	ldd	r24, Y+4	; 0x04
    2342:	9d 81       	ldd	r25, Y+5	; 0x05
    2344:	02 96       	adiw	r24, 0x02	; 2
    2346:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    234a:	ec 81       	ldd	r30, Y+4	; 0x04
    234c:	fd 81       	ldd	r31, Y+5	; 0x05
    234e:	96 89       	ldd	r25, Z+22	; 0x16
    2350:	80 91 58 04 	lds	r24, 0x0458
    2354:	89 17       	cp	r24, r25
    2356:	28 f4       	brcc	.+10     	; 0x2362 <xTaskResumeAll+0x76>
    2358:	ec 81       	ldd	r30, Y+4	; 0x04
    235a:	fd 81       	ldd	r31, Y+5	; 0x05
    235c:	86 89       	ldd	r24, Z+22	; 0x16
    235e:	80 93 58 04 	sts	0x0458, r24
    2362:	ec 81       	ldd	r30, Y+4	; 0x04
    2364:	fd 81       	ldd	r31, Y+5	; 0x05
    2366:	86 89       	ldd	r24, Z+22	; 0x16
    2368:	28 2f       	mov	r18, r24
    236a:	30 e0       	ldi	r19, 0x00	; 0
    236c:	c9 01       	movw	r24, r18
    236e:	88 0f       	add	r24, r24
    2370:	99 1f       	adc	r25, r25
    2372:	88 0f       	add	r24, r24
    2374:	99 1f       	adc	r25, r25
    2376:	88 0f       	add	r24, r24
    2378:	99 1f       	adc	r25, r25
    237a:	82 0f       	add	r24, r18
    237c:	93 1f       	adc	r25, r19
    237e:	ac 01       	movw	r20, r24
    2380:	4c 59       	subi	r20, 0x9C	; 156
    2382:	5b 4f       	sbci	r21, 0xFB	; 251
    2384:	8c 81       	ldd	r24, Y+4	; 0x04
    2386:	9d 81       	ldd	r25, Y+5	; 0x05
    2388:	9c 01       	movw	r18, r24
    238a:	2e 5f       	subi	r18, 0xFE	; 254
    238c:	3f 4f       	sbci	r19, 0xFF	; 255
    238e:	ca 01       	movw	r24, r20
    2390:	b9 01       	movw	r22, r18
    2392:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2396:	ec 81       	ldd	r30, Y+4	; 0x04
    2398:	fd 81       	ldd	r31, Y+5	; 0x05
    239a:	96 89       	ldd	r25, Z+22	; 0x16
    239c:	e0 91 52 04 	lds	r30, 0x0452
    23a0:	f0 91 53 04 	lds	r31, 0x0453
    23a4:	86 89       	ldd	r24, Z+22	; 0x16
    23a6:	98 17       	cp	r25, r24
    23a8:	18 f0       	brcs	.+6      	; 0x23b0 <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    23aa:	81 e0       	ldi	r24, 0x01	; 1
    23ac:	80 93 5c 04 	sts	0x045C, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    23b0:	80 91 a7 04 	lds	r24, 0x04A7
    23b4:	88 23       	and	r24, r24
    23b6:	09 f0       	breq	.+2      	; 0x23ba <xTaskResumeAll+0xce>
    23b8:	b6 cf       	rjmp	.-148    	; 0x2326 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    23ba:	8c 81       	ldd	r24, Y+4	; 0x04
    23bc:	9d 81       	ldd	r25, Y+5	; 0x05
    23be:	00 97       	sbiw	r24, 0x00	; 0
    23c0:	11 f0       	breq	.+4      	; 0x23c6 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    23c2:	0e 94 40 16 	call	0x2c80	; 0x2c80 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    23c6:	80 91 5a 04 	lds	r24, 0x045A
    23ca:	90 91 5b 04 	lds	r25, 0x045B
    23ce:	9a 83       	std	Y+2, r25	; 0x02
    23d0:	89 83       	std	Y+1, r24	; 0x01

					if( xPendedCounts > ( TickType_t ) 0U )
    23d2:	89 81       	ldd	r24, Y+1	; 0x01
    23d4:	9a 81       	ldd	r25, Y+2	; 0x02
    23d6:	00 97       	sbiw	r24, 0x00	; 0
    23d8:	a1 f0       	breq	.+40     	; 0x2402 <xTaskResumeAll+0x116>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    23da:	0e 94 92 12 	call	0x2524	; 0x2524 <xTaskIncrementTick>
    23de:	88 23       	and	r24, r24
    23e0:	19 f0       	breq	.+6      	; 0x23e8 <xTaskResumeAll+0xfc>
							{
								xYieldPending = pdTRUE;
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	80 93 5c 04 	sts	0x045C, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
    23e8:	89 81       	ldd	r24, Y+1	; 0x01
    23ea:	9a 81       	ldd	r25, Y+2	; 0x02
    23ec:	01 97       	sbiw	r24, 0x01	; 1
    23ee:	9a 83       	std	Y+2, r25	; 0x02
    23f0:	89 83       	std	Y+1, r24	; 0x01
						} while( xPendedCounts > ( TickType_t ) 0U );
    23f2:	89 81       	ldd	r24, Y+1	; 0x01
    23f4:	9a 81       	ldd	r25, Y+2	; 0x02
    23f6:	00 97       	sbiw	r24, 0x00	; 0
    23f8:	81 f7       	brne	.-32     	; 0x23da <xTaskResumeAll+0xee>

						xPendedTicks = 0;
    23fa:	10 92 5b 04 	sts	0x045B, r1
    23fe:	10 92 5a 04 	sts	0x045A, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2402:	80 91 5c 04 	lds	r24, 0x045C
    2406:	88 23       	and	r24, r24
    2408:	21 f0       	breq	.+8      	; 0x2412 <xTaskResumeAll+0x126>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    240e:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2412:	0f 90       	pop	r0
    2414:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2416:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2418:	0f 90       	pop	r0
    241a:	0f 90       	pop	r0
    241c:	0f 90       	pop	r0
    241e:	0f 90       	pop	r0
    2420:	0f 90       	pop	r0
    2422:	cf 91       	pop	r28
    2424:	df 91       	pop	r29
    2426:	08 95       	ret

00002428 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2428:	df 93       	push	r29
    242a:	cf 93       	push	r28
    242c:	00 d0       	rcall	.+0      	; 0x242e <xTaskGetTickCount+0x6>
    242e:	cd b7       	in	r28, 0x3d	; 61
    2430:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
    2436:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2438:	80 91 56 04 	lds	r24, 0x0456
    243c:	90 91 57 04 	lds	r25, 0x0457
    2440:	9a 83       	std	Y+2, r25	; 0x02
    2442:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2444:	0f 90       	pop	r0
    2446:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    244c:	0f 90       	pop	r0
    244e:	0f 90       	pop	r0
    2450:	cf 91       	pop	r28
    2452:	df 91       	pop	r29
    2454:	08 95       	ret

00002456 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2456:	df 93       	push	r29
    2458:	cf 93       	push	r28
    245a:	00 d0       	rcall	.+0      	; 0x245c <xTaskGetTickCountFromISR+0x6>
    245c:	0f 92       	push	r0
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    2462:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    2464:	80 91 56 04 	lds	r24, 0x0456
    2468:	90 91 57 04 	lds	r25, 0x0457
    246c:	9b 83       	std	Y+3, r25	; 0x03
    246e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2470:	8a 81       	ldd	r24, Y+2	; 0x02
    2472:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2474:	0f 90       	pop	r0
    2476:	0f 90       	pop	r0
    2478:	0f 90       	pop	r0
    247a:	cf 91       	pop	r28
    247c:	df 91       	pop	r29
    247e:	08 95       	ret

00002480 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    2480:	df 93       	push	r29
    2482:	cf 93       	push	r28
    2484:	cd b7       	in	r28, 0x3d	; 61
    2486:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2488:	80 91 55 04 	lds	r24, 0x0455
}
    248c:	cf 91       	pop	r28
    248e:	df 91       	pop	r29
    2490:	08 95       	ret

00002492 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2492:	df 93       	push	r29
    2494:	cf 93       	push	r28
    2496:	00 d0       	rcall	.+0      	; 0x2498 <pcTaskGetName+0x6>
    2498:	00 d0       	rcall	.+0      	; 0x249a <pcTaskGetName+0x8>
    249a:	00 d0       	rcall	.+0      	; 0x249c <pcTaskGetName+0xa>
    249c:	cd b7       	in	r28, 0x3d	; 61
    249e:	de b7       	in	r29, 0x3e	; 62
    24a0:	9c 83       	std	Y+4, r25	; 0x04
    24a2:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    24a4:	8b 81       	ldd	r24, Y+3	; 0x03
    24a6:	9c 81       	ldd	r25, Y+4	; 0x04
    24a8:	00 97       	sbiw	r24, 0x00	; 0
    24aa:	39 f4       	brne	.+14     	; 0x24ba <pcTaskGetName+0x28>
    24ac:	80 91 52 04 	lds	r24, 0x0452
    24b0:	90 91 53 04 	lds	r25, 0x0453
    24b4:	9e 83       	std	Y+6, r25	; 0x06
    24b6:	8d 83       	std	Y+5, r24	; 0x05
    24b8:	04 c0       	rjmp	.+8      	; 0x24c2 <pcTaskGetName+0x30>
    24ba:	8b 81       	ldd	r24, Y+3	; 0x03
    24bc:	9c 81       	ldd	r25, Y+4	; 0x04
    24be:	9e 83       	std	Y+6, r25	; 0x06
    24c0:	8d 83       	std	Y+5, r24	; 0x05
    24c2:	8d 81       	ldd	r24, Y+5	; 0x05
    24c4:	9e 81       	ldd	r25, Y+6	; 0x06
    24c6:	9a 83       	std	Y+2, r25	; 0x02
    24c8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    24ca:	89 81       	ldd	r24, Y+1	; 0x01
    24cc:	9a 81       	ldd	r25, Y+2	; 0x02
    24ce:	49 96       	adiw	r24, 0x19	; 25
}
    24d0:	26 96       	adiw	r28, 0x06	; 6
    24d2:	0f b6       	in	r0, 0x3f	; 63
    24d4:	f8 94       	cli
    24d6:	de bf       	out	0x3e, r29	; 62
    24d8:	0f be       	out	0x3f, r0	; 63
    24da:	cd bf       	out	0x3d, r28	; 61
    24dc:	cf 91       	pop	r28
    24de:	df 91       	pop	r29
    24e0:	08 95       	ret

000024e2 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    24e2:	df 93       	push	r29
    24e4:	cf 93       	push	r28
    24e6:	00 d0       	rcall	.+0      	; 0x24e8 <xTaskCatchUpTicks+0x6>
    24e8:	0f 92       	push	r0
    24ea:	cd b7       	in	r28, 0x3d	; 61
    24ec:	de b7       	in	r29, 0x3e	; 62
    24ee:	9b 83       	std	Y+3, r25	; 0x03
    24f0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xYieldRequired = pdFALSE;
    24f2:	19 82       	std	Y+1, r1	; 0x01
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
    24f4:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
    24f8:	20 91 5a 04 	lds	r18, 0x045A
    24fc:	30 91 5b 04 	lds	r19, 0x045B
    2500:	8a 81       	ldd	r24, Y+2	; 0x02
    2502:	9b 81       	ldd	r25, Y+3	; 0x03
    2504:	82 0f       	add	r24, r18
    2506:	93 1f       	adc	r25, r19
    2508:	90 93 5b 04 	sts	0x045B, r25
    250c:	80 93 5a 04 	sts	0x045A, r24
	xYieldRequired = xTaskResumeAll();
    2510:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    2514:	89 83       	std	Y+1, r24	; 0x01

	return xYieldRequired;
    2516:	89 81       	ldd	r24, Y+1	; 0x01
}
    2518:	0f 90       	pop	r0
    251a:	0f 90       	pop	r0
    251c:	0f 90       	pop	r0
    251e:	cf 91       	pop	r28
    2520:	df 91       	pop	r29
    2522:	08 95       	ret

00002524 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2524:	df 93       	push	r29
    2526:	cf 93       	push	r28
    2528:	cd b7       	in	r28, 0x3d	; 61
    252a:	de b7       	in	r29, 0x3e	; 62
    252c:	29 97       	sbiw	r28, 0x09	; 9
    252e:	0f b6       	in	r0, 0x3f	; 63
    2530:	f8 94       	cli
    2532:	de bf       	out	0x3e, r29	; 62
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2538:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    253a:	80 91 63 04 	lds	r24, 0x0463
    253e:	88 23       	and	r24, r24
    2540:	09 f0       	breq	.+2      	; 0x2544 <xTaskIncrementTick+0x20>
    2542:	c6 c0       	rjmp	.+396    	; 0x26d0 <xTaskIncrementTick+0x1ac>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2544:	80 91 56 04 	lds	r24, 0x0456
    2548:	90 91 57 04 	lds	r25, 0x0457
    254c:	01 96       	adiw	r24, 0x01	; 1
    254e:	9c 83       	std	Y+4, r25	; 0x04
    2550:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    2552:	8b 81       	ldd	r24, Y+3	; 0x03
    2554:	9c 81       	ldd	r25, Y+4	; 0x04
    2556:	90 93 57 04 	sts	0x0457, r25
    255a:	80 93 56 04 	sts	0x0456, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    255e:	8b 81       	ldd	r24, Y+3	; 0x03
    2560:	9c 81       	ldd	r25, Y+4	; 0x04
    2562:	00 97       	sbiw	r24, 0x00	; 0
    2564:	d9 f4       	brne	.+54     	; 0x259c <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    2566:	80 91 a3 04 	lds	r24, 0x04A3
    256a:	90 91 a4 04 	lds	r25, 0x04A4
    256e:	9a 83       	std	Y+2, r25	; 0x02
    2570:	89 83       	std	Y+1, r24	; 0x01
    2572:	80 91 a5 04 	lds	r24, 0x04A5
    2576:	90 91 a6 04 	lds	r25, 0x04A6
    257a:	90 93 a4 04 	sts	0x04A4, r25
    257e:	80 93 a3 04 	sts	0x04A3, r24
    2582:	89 81       	ldd	r24, Y+1	; 0x01
    2584:	9a 81       	ldd	r25, Y+2	; 0x02
    2586:	90 93 a6 04 	sts	0x04A6, r25
    258a:	80 93 a5 04 	sts	0x04A5, r24
    258e:	80 91 5d 04 	lds	r24, 0x045D
    2592:	8f 5f       	subi	r24, 0xFF	; 255
    2594:	80 93 5d 04 	sts	0x045D, r24
    2598:	0e 94 40 16 	call	0x2c80	; 0x2c80 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    259c:	20 91 5f 04 	lds	r18, 0x045F
    25a0:	30 91 60 04 	lds	r19, 0x0460
    25a4:	8b 81       	ldd	r24, Y+3	; 0x03
    25a6:	9c 81       	ldd	r25, Y+4	; 0x04
    25a8:	82 17       	cp	r24, r18
    25aa:	93 07       	cpc	r25, r19
    25ac:	08 f4       	brcc	.+2      	; 0x25b0 <xTaskIncrementTick+0x8c>
    25ae:	71 c0       	rjmp	.+226    	; 0x2692 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    25b0:	e0 91 a3 04 	lds	r30, 0x04A3
    25b4:	f0 91 a4 04 	lds	r31, 0x04A4
    25b8:	80 81       	ld	r24, Z
    25ba:	88 23       	and	r24, r24
    25bc:	39 f4       	brne	.+14     	; 0x25cc <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    25be:	8f ef       	ldi	r24, 0xFF	; 255
    25c0:	9f ef       	ldi	r25, 0xFF	; 255
    25c2:	90 93 60 04 	sts	0x0460, r25
    25c6:	80 93 5f 04 	sts	0x045F, r24
    25ca:	63 c0       	rjmp	.+198    	; 0x2692 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    25cc:	e0 91 a3 04 	lds	r30, 0x04A3
    25d0:	f0 91 a4 04 	lds	r31, 0x04A4
    25d4:	05 80       	ldd	r0, Z+5	; 0x05
    25d6:	f6 81       	ldd	r31, Z+6	; 0x06
    25d8:	e0 2d       	mov	r30, r0
    25da:	86 81       	ldd	r24, Z+6	; 0x06
    25dc:	97 81       	ldd	r25, Z+7	; 0x07
    25de:	99 87       	std	Y+9, r25	; 0x09
    25e0:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    25e2:	e8 85       	ldd	r30, Y+8	; 0x08
    25e4:	f9 85       	ldd	r31, Y+9	; 0x09
    25e6:	82 81       	ldd	r24, Z+2	; 0x02
    25e8:	93 81       	ldd	r25, Z+3	; 0x03
    25ea:	9f 83       	std	Y+7, r25	; 0x07
    25ec:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    25ee:	2b 81       	ldd	r18, Y+3	; 0x03
    25f0:	3c 81       	ldd	r19, Y+4	; 0x04
    25f2:	8e 81       	ldd	r24, Y+6	; 0x06
    25f4:	9f 81       	ldd	r25, Y+7	; 0x07
    25f6:	28 17       	cp	r18, r24
    25f8:	39 07       	cpc	r19, r25
    25fa:	38 f4       	brcc	.+14     	; 0x260a <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    25fc:	8e 81       	ldd	r24, Y+6	; 0x06
    25fe:	9f 81       	ldd	r25, Y+7	; 0x07
    2600:	90 93 60 04 	sts	0x0460, r25
    2604:	80 93 5f 04 	sts	0x045F, r24
    2608:	44 c0       	rjmp	.+136    	; 0x2692 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    260a:	88 85       	ldd	r24, Y+8	; 0x08
    260c:	99 85       	ldd	r25, Y+9	; 0x09
    260e:	02 96       	adiw	r24, 0x02	; 2
    2610:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2614:	e8 85       	ldd	r30, Y+8	; 0x08
    2616:	f9 85       	ldd	r31, Y+9	; 0x09
    2618:	84 89       	ldd	r24, Z+20	; 0x14
    261a:	95 89       	ldd	r25, Z+21	; 0x15
    261c:	00 97       	sbiw	r24, 0x00	; 0
    261e:	29 f0       	breq	.+10     	; 0x262a <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2620:	88 85       	ldd	r24, Y+8	; 0x08
    2622:	99 85       	ldd	r25, Y+9	; 0x09
    2624:	0c 96       	adiw	r24, 0x0c	; 12
    2626:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    262a:	e8 85       	ldd	r30, Y+8	; 0x08
    262c:	f9 85       	ldd	r31, Y+9	; 0x09
    262e:	96 89       	ldd	r25, Z+22	; 0x16
    2630:	80 91 58 04 	lds	r24, 0x0458
    2634:	89 17       	cp	r24, r25
    2636:	28 f4       	brcc	.+10     	; 0x2642 <xTaskIncrementTick+0x11e>
    2638:	e8 85       	ldd	r30, Y+8	; 0x08
    263a:	f9 85       	ldd	r31, Y+9	; 0x09
    263c:	86 89       	ldd	r24, Z+22	; 0x16
    263e:	80 93 58 04 	sts	0x0458, r24
    2642:	e8 85       	ldd	r30, Y+8	; 0x08
    2644:	f9 85       	ldd	r31, Y+9	; 0x09
    2646:	86 89       	ldd	r24, Z+22	; 0x16
    2648:	28 2f       	mov	r18, r24
    264a:	30 e0       	ldi	r19, 0x00	; 0
    264c:	c9 01       	movw	r24, r18
    264e:	88 0f       	add	r24, r24
    2650:	99 1f       	adc	r25, r25
    2652:	88 0f       	add	r24, r24
    2654:	99 1f       	adc	r25, r25
    2656:	88 0f       	add	r24, r24
    2658:	99 1f       	adc	r25, r25
    265a:	82 0f       	add	r24, r18
    265c:	93 1f       	adc	r25, r19
    265e:	ac 01       	movw	r20, r24
    2660:	4c 59       	subi	r20, 0x9C	; 156
    2662:	5b 4f       	sbci	r21, 0xFB	; 251
    2664:	88 85       	ldd	r24, Y+8	; 0x08
    2666:	99 85       	ldd	r25, Y+9	; 0x09
    2668:	9c 01       	movw	r18, r24
    266a:	2e 5f       	subi	r18, 0xFE	; 254
    266c:	3f 4f       	sbci	r19, 0xFF	; 255
    266e:	ca 01       	movw	r24, r20
    2670:	b9 01       	movw	r22, r18
    2672:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2676:	e8 85       	ldd	r30, Y+8	; 0x08
    2678:	f9 85       	ldd	r31, Y+9	; 0x09
    267a:	96 89       	ldd	r25, Z+22	; 0x16
    267c:	e0 91 52 04 	lds	r30, 0x0452
    2680:	f0 91 53 04 	lds	r31, 0x0453
    2684:	86 89       	ldd	r24, Z+22	; 0x16
    2686:	98 17       	cp	r25, r24
    2688:	08 f4       	brcc	.+2      	; 0x268c <xTaskIncrementTick+0x168>
    268a:	92 cf       	rjmp	.-220    	; 0x25b0 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	8d 83       	std	Y+5, r24	; 0x05
    2690:	8f cf       	rjmp	.-226    	; 0x25b0 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2692:	e0 91 52 04 	lds	r30, 0x0452
    2696:	f0 91 53 04 	lds	r31, 0x0453
    269a:	86 89       	ldd	r24, Z+22	; 0x16
    269c:	28 2f       	mov	r18, r24
    269e:	30 e0       	ldi	r19, 0x00	; 0
    26a0:	c9 01       	movw	r24, r18
    26a2:	88 0f       	add	r24, r24
    26a4:	99 1f       	adc	r25, r25
    26a6:	88 0f       	add	r24, r24
    26a8:	99 1f       	adc	r25, r25
    26aa:	88 0f       	add	r24, r24
    26ac:	99 1f       	adc	r25, r25
    26ae:	82 0f       	add	r24, r18
    26b0:	93 1f       	adc	r25, r19
    26b2:	fc 01       	movw	r30, r24
    26b4:	ec 59       	subi	r30, 0x9C	; 156
    26b6:	fb 4f       	sbci	r31, 0xFB	; 251
    26b8:	80 81       	ld	r24, Z
    26ba:	82 30       	cpi	r24, 0x02	; 2
    26bc:	10 f0       	brcs	.+4      	; 0x26c2 <xTaskIncrementTick+0x19e>
			{
				xSwitchRequired = pdTRUE;
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	8d 83       	std	Y+5, r24	; 0x05
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
    26c2:	80 91 5c 04 	lds	r24, 0x045C
    26c6:	88 23       	and	r24, r24
    26c8:	61 f0       	breq	.+24     	; 0x26e2 <xTaskIncrementTick+0x1be>
			{
				xSwitchRequired = pdTRUE;
    26ca:	81 e0       	ldi	r24, 0x01	; 1
    26cc:	8d 83       	std	Y+5, r24	; 0x05
    26ce:	09 c0       	rjmp	.+18     	; 0x26e2 <xTaskIncrementTick+0x1be>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
    26d0:	80 91 5a 04 	lds	r24, 0x045A
    26d4:	90 91 5b 04 	lds	r25, 0x045B
    26d8:	01 96       	adiw	r24, 0x01	; 1
    26da:	90 93 5b 04 	sts	0x045B, r25
    26de:	80 93 5a 04 	sts	0x045A, r24
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
    26e2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    26e4:	29 96       	adiw	r28, 0x09	; 9
    26e6:	0f b6       	in	r0, 0x3f	; 63
    26e8:	f8 94       	cli
    26ea:	de bf       	out	0x3e, r29	; 62
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	cd bf       	out	0x3d, r28	; 61
    26f0:	cf 91       	pop	r28
    26f2:	df 91       	pop	r29
    26f4:	08 95       	ret

000026f6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    26f6:	df 93       	push	r29
    26f8:	cf 93       	push	r28
    26fa:	00 d0       	rcall	.+0      	; 0x26fc <vTaskSwitchContext+0x6>
    26fc:	0f 92       	push	r0
    26fe:	cd b7       	in	r28, 0x3d	; 61
    2700:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2702:	80 91 63 04 	lds	r24, 0x0463
    2706:	88 23       	and	r24, r24
    2708:	21 f0       	breq	.+8      	; 0x2712 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    270a:	81 e0       	ldi	r24, 0x01	; 1
    270c:	80 93 5c 04 	sts	0x045C, r24
    2710:	59 c0       	rjmp	.+178    	; 0x27c4 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    2712:	10 92 5c 04 	sts	0x045C, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2716:	80 91 58 04 	lds	r24, 0x0458
    271a:	8b 83       	std	Y+3, r24	; 0x03
    271c:	03 c0       	rjmp	.+6      	; 0x2724 <vTaskSwitchContext+0x2e>
    271e:	8b 81       	ldd	r24, Y+3	; 0x03
    2720:	81 50       	subi	r24, 0x01	; 1
    2722:	8b 83       	std	Y+3, r24	; 0x03
    2724:	8b 81       	ldd	r24, Y+3	; 0x03
    2726:	28 2f       	mov	r18, r24
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	c9 01       	movw	r24, r18
    272c:	88 0f       	add	r24, r24
    272e:	99 1f       	adc	r25, r25
    2730:	88 0f       	add	r24, r24
    2732:	99 1f       	adc	r25, r25
    2734:	88 0f       	add	r24, r24
    2736:	99 1f       	adc	r25, r25
    2738:	82 0f       	add	r24, r18
    273a:	93 1f       	adc	r25, r19
    273c:	fc 01       	movw	r30, r24
    273e:	ec 59       	subi	r30, 0x9C	; 156
    2740:	fb 4f       	sbci	r31, 0xFB	; 251
    2742:	80 81       	ld	r24, Z
    2744:	88 23       	and	r24, r24
    2746:	59 f3       	breq	.-42     	; 0x271e <vTaskSwitchContext+0x28>
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
    274a:	28 2f       	mov	r18, r24
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	c9 01       	movw	r24, r18
    2750:	88 0f       	add	r24, r24
    2752:	99 1f       	adc	r25, r25
    2754:	88 0f       	add	r24, r24
    2756:	99 1f       	adc	r25, r25
    2758:	88 0f       	add	r24, r24
    275a:	99 1f       	adc	r25, r25
    275c:	82 0f       	add	r24, r18
    275e:	93 1f       	adc	r25, r19
    2760:	8c 59       	subi	r24, 0x9C	; 156
    2762:	9b 4f       	sbci	r25, 0xFB	; 251
    2764:	9a 83       	std	Y+2, r25	; 0x02
    2766:	89 83       	std	Y+1, r24	; 0x01
    2768:	e9 81       	ldd	r30, Y+1	; 0x01
    276a:	fa 81       	ldd	r31, Y+2	; 0x02
    276c:	01 80       	ldd	r0, Z+1	; 0x01
    276e:	f2 81       	ldd	r31, Z+2	; 0x02
    2770:	e0 2d       	mov	r30, r0
    2772:	82 81       	ldd	r24, Z+2	; 0x02
    2774:	93 81       	ldd	r25, Z+3	; 0x03
    2776:	e9 81       	ldd	r30, Y+1	; 0x01
    2778:	fa 81       	ldd	r31, Y+2	; 0x02
    277a:	92 83       	std	Z+2, r25	; 0x02
    277c:	81 83       	std	Z+1, r24	; 0x01
    277e:	e9 81       	ldd	r30, Y+1	; 0x01
    2780:	fa 81       	ldd	r31, Y+2	; 0x02
    2782:	21 81       	ldd	r18, Z+1	; 0x01
    2784:	32 81       	ldd	r19, Z+2	; 0x02
    2786:	89 81       	ldd	r24, Y+1	; 0x01
    2788:	9a 81       	ldd	r25, Y+2	; 0x02
    278a:	03 96       	adiw	r24, 0x03	; 3
    278c:	28 17       	cp	r18, r24
    278e:	39 07       	cpc	r19, r25
    2790:	59 f4       	brne	.+22     	; 0x27a8 <vTaskSwitchContext+0xb2>
    2792:	e9 81       	ldd	r30, Y+1	; 0x01
    2794:	fa 81       	ldd	r31, Y+2	; 0x02
    2796:	01 80       	ldd	r0, Z+1	; 0x01
    2798:	f2 81       	ldd	r31, Z+2	; 0x02
    279a:	e0 2d       	mov	r30, r0
    279c:	82 81       	ldd	r24, Z+2	; 0x02
    279e:	93 81       	ldd	r25, Z+3	; 0x03
    27a0:	e9 81       	ldd	r30, Y+1	; 0x01
    27a2:	fa 81       	ldd	r31, Y+2	; 0x02
    27a4:	92 83       	std	Z+2, r25	; 0x02
    27a6:	81 83       	std	Z+1, r24	; 0x01
    27a8:	e9 81       	ldd	r30, Y+1	; 0x01
    27aa:	fa 81       	ldd	r31, Y+2	; 0x02
    27ac:	01 80       	ldd	r0, Z+1	; 0x01
    27ae:	f2 81       	ldd	r31, Z+2	; 0x02
    27b0:	e0 2d       	mov	r30, r0
    27b2:	86 81       	ldd	r24, Z+6	; 0x06
    27b4:	97 81       	ldd	r25, Z+7	; 0x07
    27b6:	90 93 53 04 	sts	0x0453, r25
    27ba:	80 93 52 04 	sts	0x0452, r24
    27be:	8b 81       	ldd	r24, Y+3	; 0x03
    27c0:	80 93 58 04 	sts	0x0458, r24
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    27c4:	0f 90       	pop	r0
    27c6:	0f 90       	pop	r0
    27c8:	0f 90       	pop	r0
    27ca:	cf 91       	pop	r28
    27cc:	df 91       	pop	r29
    27ce:	08 95       	ret

000027d0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    27d0:	df 93       	push	r29
    27d2:	cf 93       	push	r28
    27d4:	00 d0       	rcall	.+0      	; 0x27d6 <vTaskPlaceOnEventList+0x6>
    27d6:	00 d0       	rcall	.+0      	; 0x27d8 <vTaskPlaceOnEventList+0x8>
    27d8:	cd b7       	in	r28, 0x3d	; 61
    27da:	de b7       	in	r29, 0x3e	; 62
    27dc:	9a 83       	std	Y+2, r25	; 0x02
    27de:	89 83       	std	Y+1, r24	; 0x01
    27e0:	7c 83       	std	Y+4, r23	; 0x04
    27e2:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    27e4:	80 91 52 04 	lds	r24, 0x0452
    27e8:	90 91 53 04 	lds	r25, 0x0453
    27ec:	9c 01       	movw	r18, r24
    27ee:	24 5f       	subi	r18, 0xF4	; 244
    27f0:	3f 4f       	sbci	r19, 0xFF	; 255
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	9a 81       	ldd	r25, Y+2	; 0x02
    27f6:	b9 01       	movw	r22, r18
    27f8:	0e 94 43 01 	call	0x286	; 0x286 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    27fc:	8b 81       	ldd	r24, Y+3	; 0x03
    27fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2800:	61 e0       	ldi	r22, 0x01	; 1
    2802:	0e 94 95 1a 	call	0x352a	; 0x352a <prvAddCurrentTaskToDelayedList>
}
    2806:	0f 90       	pop	r0
    2808:	0f 90       	pop	r0
    280a:	0f 90       	pop	r0
    280c:	0f 90       	pop	r0
    280e:	cf 91       	pop	r28
    2810:	df 91       	pop	r29
    2812:	08 95       	ret

00002814 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2814:	df 93       	push	r29
    2816:	cf 93       	push	r28
    2818:	00 d0       	rcall	.+0      	; 0x281a <vTaskPlaceOnUnorderedEventList+0x6>
    281a:	00 d0       	rcall	.+0      	; 0x281c <vTaskPlaceOnUnorderedEventList+0x8>
    281c:	00 d0       	rcall	.+0      	; 0x281e <vTaskPlaceOnUnorderedEventList+0xa>
    281e:	cd b7       	in	r28, 0x3d	; 61
    2820:	de b7       	in	r29, 0x3e	; 62
    2822:	9a 83       	std	Y+2, r25	; 0x02
    2824:	89 83       	std	Y+1, r24	; 0x01
    2826:	7c 83       	std	Y+4, r23	; 0x04
    2828:	6b 83       	std	Y+3, r22	; 0x03
    282a:	5e 83       	std	Y+6, r21	; 0x06
    282c:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    282e:	e0 91 52 04 	lds	r30, 0x0452
    2832:	f0 91 53 04 	lds	r31, 0x0453
    2836:	8b 81       	ldd	r24, Y+3	; 0x03
    2838:	9c 81       	ldd	r25, Y+4	; 0x04
    283a:	90 68       	ori	r25, 0x80	; 128
    283c:	95 87       	std	Z+13, r25	; 0x0d
    283e:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2840:	80 91 52 04 	lds	r24, 0x0452
    2844:	90 91 53 04 	lds	r25, 0x0453
    2848:	9c 01       	movw	r18, r24
    284a:	24 5f       	subi	r18, 0xF4	; 244
    284c:	3f 4f       	sbci	r19, 0xFF	; 255
    284e:	89 81       	ldd	r24, Y+1	; 0x01
    2850:	9a 81       	ldd	r25, Y+2	; 0x02
    2852:	b9 01       	movw	r22, r18
    2854:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2858:	8d 81       	ldd	r24, Y+5	; 0x05
    285a:	9e 81       	ldd	r25, Y+6	; 0x06
    285c:	61 e0       	ldi	r22, 0x01	; 1
    285e:	0e 94 95 1a 	call	0x352a	; 0x352a <prvAddCurrentTaskToDelayedList>
}
    2862:	26 96       	adiw	r28, 0x06	; 6
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	f8 94       	cli
    2868:	de bf       	out	0x3e, r29	; 62
    286a:	0f be       	out	0x3f, r0	; 63
    286c:	cd bf       	out	0x3d, r28	; 61
    286e:	cf 91       	pop	r28
    2870:	df 91       	pop	r29
    2872:	08 95       	ret

00002874 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2874:	df 93       	push	r29
    2876:	cf 93       	push	r28
    2878:	00 d0       	rcall	.+0      	; 0x287a <xTaskRemoveFromEventList+0x6>
    287a:	00 d0       	rcall	.+0      	; 0x287c <xTaskRemoveFromEventList+0x8>
    287c:	0f 92       	push	r0
    287e:	cd b7       	in	r28, 0x3d	; 61
    2880:	de b7       	in	r29, 0x3e	; 62
    2882:	9d 83       	std	Y+5, r25	; 0x05
    2884:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2886:	ec 81       	ldd	r30, Y+4	; 0x04
    2888:	fd 81       	ldd	r31, Y+5	; 0x05
    288a:	05 80       	ldd	r0, Z+5	; 0x05
    288c:	f6 81       	ldd	r31, Z+6	; 0x06
    288e:	e0 2d       	mov	r30, r0
    2890:	86 81       	ldd	r24, Z+6	; 0x06
    2892:	97 81       	ldd	r25, Z+7	; 0x07
    2894:	9b 83       	std	Y+3, r25	; 0x03
    2896:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2898:	8a 81       	ldd	r24, Y+2	; 0x02
    289a:	9b 81       	ldd	r25, Y+3	; 0x03
    289c:	0c 96       	adiw	r24, 0x0c	; 12
    289e:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    28a2:	80 91 63 04 	lds	r24, 0x0463
    28a6:	88 23       	and	r24, r24
    28a8:	61 f5       	brne	.+88     	; 0x2902 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    28aa:	8a 81       	ldd	r24, Y+2	; 0x02
    28ac:	9b 81       	ldd	r25, Y+3	; 0x03
    28ae:	02 96       	adiw	r24, 0x02	; 2
    28b0:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    28b4:	ea 81       	ldd	r30, Y+2	; 0x02
    28b6:	fb 81       	ldd	r31, Y+3	; 0x03
    28b8:	96 89       	ldd	r25, Z+22	; 0x16
    28ba:	80 91 58 04 	lds	r24, 0x0458
    28be:	89 17       	cp	r24, r25
    28c0:	28 f4       	brcc	.+10     	; 0x28cc <xTaskRemoveFromEventList+0x58>
    28c2:	ea 81       	ldd	r30, Y+2	; 0x02
    28c4:	fb 81       	ldd	r31, Y+3	; 0x03
    28c6:	86 89       	ldd	r24, Z+22	; 0x16
    28c8:	80 93 58 04 	sts	0x0458, r24
    28cc:	ea 81       	ldd	r30, Y+2	; 0x02
    28ce:	fb 81       	ldd	r31, Y+3	; 0x03
    28d0:	86 89       	ldd	r24, Z+22	; 0x16
    28d2:	28 2f       	mov	r18, r24
    28d4:	30 e0       	ldi	r19, 0x00	; 0
    28d6:	c9 01       	movw	r24, r18
    28d8:	88 0f       	add	r24, r24
    28da:	99 1f       	adc	r25, r25
    28dc:	88 0f       	add	r24, r24
    28de:	99 1f       	adc	r25, r25
    28e0:	88 0f       	add	r24, r24
    28e2:	99 1f       	adc	r25, r25
    28e4:	82 0f       	add	r24, r18
    28e6:	93 1f       	adc	r25, r19
    28e8:	ac 01       	movw	r20, r24
    28ea:	4c 59       	subi	r20, 0x9C	; 156
    28ec:	5b 4f       	sbci	r21, 0xFB	; 251
    28ee:	8a 81       	ldd	r24, Y+2	; 0x02
    28f0:	9b 81       	ldd	r25, Y+3	; 0x03
    28f2:	9c 01       	movw	r18, r24
    28f4:	2e 5f       	subi	r18, 0xFE	; 254
    28f6:	3f 4f       	sbci	r19, 0xFF	; 255
    28f8:	ca 01       	movw	r24, r20
    28fa:	b9 01       	movw	r22, r18
    28fc:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
    2900:	0a c0       	rjmp	.+20     	; 0x2916 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2902:	8a 81       	ldd	r24, Y+2	; 0x02
    2904:	9b 81       	ldd	r25, Y+3	; 0x03
    2906:	9c 01       	movw	r18, r24
    2908:	24 5f       	subi	r18, 0xF4	; 244
    290a:	3f 4f       	sbci	r19, 0xFF	; 255
    290c:	87 ea       	ldi	r24, 0xA7	; 167
    290e:	94 e0       	ldi	r25, 0x04	; 4
    2910:	b9 01       	movw	r22, r18
    2912:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2916:	ea 81       	ldd	r30, Y+2	; 0x02
    2918:	fb 81       	ldd	r31, Y+3	; 0x03
    291a:	96 89       	ldd	r25, Z+22	; 0x16
    291c:	e0 91 52 04 	lds	r30, 0x0452
    2920:	f0 91 53 04 	lds	r31, 0x0453
    2924:	86 89       	ldd	r24, Z+22	; 0x16
    2926:	89 17       	cp	r24, r25
    2928:	30 f4       	brcc	.+12     	; 0x2936 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    292a:	81 e0       	ldi	r24, 0x01	; 1
    292c:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    292e:	81 e0       	ldi	r24, 0x01	; 1
    2930:	80 93 5c 04 	sts	0x045C, r24
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    2936:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2938:	89 81       	ldd	r24, Y+1	; 0x01
}
    293a:	0f 90       	pop	r0
    293c:	0f 90       	pop	r0
    293e:	0f 90       	pop	r0
    2940:	0f 90       	pop	r0
    2942:	0f 90       	pop	r0
    2944:	cf 91       	pop	r28
    2946:	df 91       	pop	r29
    2948:	08 95       	ret

0000294a <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    294a:	df 93       	push	r29
    294c:	cf 93       	push	r28
    294e:	00 d0       	rcall	.+0      	; 0x2950 <vTaskRemoveFromUnorderedEventList+0x6>
    2950:	00 d0       	rcall	.+0      	; 0x2952 <vTaskRemoveFromUnorderedEventList+0x8>
    2952:	00 d0       	rcall	.+0      	; 0x2954 <vTaskRemoveFromUnorderedEventList+0xa>
    2954:	cd b7       	in	r28, 0x3d	; 61
    2956:	de b7       	in	r29, 0x3e	; 62
    2958:	9c 83       	std	Y+4, r25	; 0x04
    295a:	8b 83       	std	Y+3, r24	; 0x03
    295c:	7e 83       	std	Y+6, r23	; 0x06
    295e:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2960:	8d 81       	ldd	r24, Y+5	; 0x05
    2962:	9e 81       	ldd	r25, Y+6	; 0x06
    2964:	90 68       	ori	r25, 0x80	; 128
    2966:	eb 81       	ldd	r30, Y+3	; 0x03
    2968:	fc 81       	ldd	r31, Y+4	; 0x04
    296a:	91 83       	std	Z+1, r25	; 0x01
    296c:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    296e:	eb 81       	ldd	r30, Y+3	; 0x03
    2970:	fc 81       	ldd	r31, Y+4	; 0x04
    2972:	86 81       	ldd	r24, Z+6	; 0x06
    2974:	97 81       	ldd	r25, Z+7	; 0x07
    2976:	9a 83       	std	Y+2, r25	; 0x02
    2978:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    297a:	8b 81       	ldd	r24, Y+3	; 0x03
    297c:	9c 81       	ldd	r25, Y+4	; 0x04
    297e:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2982:	89 81       	ldd	r24, Y+1	; 0x01
    2984:	9a 81       	ldd	r25, Y+2	; 0x02
    2986:	02 96       	adiw	r24, 0x02	; 2
    2988:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    298c:	e9 81       	ldd	r30, Y+1	; 0x01
    298e:	fa 81       	ldd	r31, Y+2	; 0x02
    2990:	96 89       	ldd	r25, Z+22	; 0x16
    2992:	80 91 58 04 	lds	r24, 0x0458
    2996:	89 17       	cp	r24, r25
    2998:	28 f4       	brcc	.+10     	; 0x29a4 <vTaskRemoveFromUnorderedEventList+0x5a>
    299a:	e9 81       	ldd	r30, Y+1	; 0x01
    299c:	fa 81       	ldd	r31, Y+2	; 0x02
    299e:	86 89       	ldd	r24, Z+22	; 0x16
    29a0:	80 93 58 04 	sts	0x0458, r24
    29a4:	e9 81       	ldd	r30, Y+1	; 0x01
    29a6:	fa 81       	ldd	r31, Y+2	; 0x02
    29a8:	86 89       	ldd	r24, Z+22	; 0x16
    29aa:	28 2f       	mov	r18, r24
    29ac:	30 e0       	ldi	r19, 0x00	; 0
    29ae:	c9 01       	movw	r24, r18
    29b0:	88 0f       	add	r24, r24
    29b2:	99 1f       	adc	r25, r25
    29b4:	88 0f       	add	r24, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	88 0f       	add	r24, r24
    29ba:	99 1f       	adc	r25, r25
    29bc:	82 0f       	add	r24, r18
    29be:	93 1f       	adc	r25, r19
    29c0:	ac 01       	movw	r20, r24
    29c2:	4c 59       	subi	r20, 0x9C	; 156
    29c4:	5b 4f       	sbci	r21, 0xFB	; 251
    29c6:	89 81       	ldd	r24, Y+1	; 0x01
    29c8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ca:	9c 01       	movw	r18, r24
    29cc:	2e 5f       	subi	r18, 0xFE	; 254
    29ce:	3f 4f       	sbci	r19, 0xFF	; 255
    29d0:	ca 01       	movw	r24, r20
    29d2:	b9 01       	movw	r22, r18
    29d4:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    29d8:	e9 81       	ldd	r30, Y+1	; 0x01
    29da:	fa 81       	ldd	r31, Y+2	; 0x02
    29dc:	96 89       	ldd	r25, Z+22	; 0x16
    29de:	e0 91 52 04 	lds	r30, 0x0452
    29e2:	f0 91 53 04 	lds	r31, 0x0453
    29e6:	86 89       	ldd	r24, Z+22	; 0x16
    29e8:	89 17       	cp	r24, r25
    29ea:	18 f4       	brcc	.+6      	; 0x29f2 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    29ec:	81 e0       	ldi	r24, 0x01	; 1
    29ee:	80 93 5c 04 	sts	0x045C, r24
	}
}
    29f2:	26 96       	adiw	r28, 0x06	; 6
    29f4:	0f b6       	in	r0, 0x3f	; 63
    29f6:	f8 94       	cli
    29f8:	de bf       	out	0x3e, r29	; 62
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	cd bf       	out	0x3d, r28	; 61
    29fe:	cf 91       	pop	r28
    2a00:	df 91       	pop	r29
    2a02:	08 95       	ret

00002a04 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2a04:	df 93       	push	r29
    2a06:	cf 93       	push	r28
    2a08:	00 d0       	rcall	.+0      	; 0x2a0a <vTaskSetTimeOutState+0x6>
    2a0a:	cd b7       	in	r28, 0x3d	; 61
    2a0c:	de b7       	in	r29, 0x3e	; 62
    2a0e:	9a 83       	std	Y+2, r25	; 0x02
    2a10:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    2a12:	0f b6       	in	r0, 0x3f	; 63
    2a14:	f8 94       	cli
    2a16:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    2a18:	80 91 5d 04 	lds	r24, 0x045D
    2a1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a20:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    2a22:	80 91 56 04 	lds	r24, 0x0456
    2a26:	90 91 57 04 	lds	r25, 0x0457
    2a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2e:	92 83       	std	Z+2, r25	; 0x02
    2a30:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2a32:	0f 90       	pop	r0
    2a34:	0f be       	out	0x3f, r0	; 63
}
    2a36:	0f 90       	pop	r0
    2a38:	0f 90       	pop	r0
    2a3a:	cf 91       	pop	r28
    2a3c:	df 91       	pop	r29
    2a3e:	08 95       	ret

00002a40 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2a40:	df 93       	push	r29
    2a42:	cf 93       	push	r28
    2a44:	00 d0       	rcall	.+0      	; 0x2a46 <vTaskInternalSetTimeOutState+0x6>
    2a46:	cd b7       	in	r28, 0x3d	; 61
    2a48:	de b7       	in	r29, 0x3e	; 62
    2a4a:	9a 83       	std	Y+2, r25	; 0x02
    2a4c:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2a4e:	80 91 5d 04 	lds	r24, 0x045D
    2a52:	e9 81       	ldd	r30, Y+1	; 0x01
    2a54:	fa 81       	ldd	r31, Y+2	; 0x02
    2a56:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2a58:	80 91 56 04 	lds	r24, 0x0456
    2a5c:	90 91 57 04 	lds	r25, 0x0457
    2a60:	e9 81       	ldd	r30, Y+1	; 0x01
    2a62:	fa 81       	ldd	r31, Y+2	; 0x02
    2a64:	92 83       	std	Z+2, r25	; 0x02
    2a66:	81 83       	std	Z+1, r24	; 0x01
}
    2a68:	0f 90       	pop	r0
    2a6a:	0f 90       	pop	r0
    2a6c:	cf 91       	pop	r28
    2a6e:	df 91       	pop	r29
    2a70:	08 95       	ret

00002a72 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2a72:	df 93       	push	r29
    2a74:	cf 93       	push	r28
    2a76:	cd b7       	in	r28, 0x3d	; 61
    2a78:	de b7       	in	r29, 0x3e	; 62
    2a7a:	29 97       	sbiw	r28, 0x09	; 9
    2a7c:	0f b6       	in	r0, 0x3f	; 63
    2a7e:	f8 94       	cli
    2a80:	de bf       	out	0x3e, r29	; 62
    2a82:	0f be       	out	0x3f, r0	; 63
    2a84:	cd bf       	out	0x3d, r28	; 61
    2a86:	9f 83       	std	Y+7, r25	; 0x07
    2a88:	8e 83       	std	Y+6, r24	; 0x06
    2a8a:	79 87       	std	Y+9, r23	; 0x09
    2a8c:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2a94:	80 91 56 04 	lds	r24, 0x0456
    2a98:	90 91 57 04 	lds	r25, 0x0457
    2a9c:	9c 83       	std	Y+4, r25	; 0x04
    2a9e:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2aa0:	ee 81       	ldd	r30, Y+6	; 0x06
    2aa2:	ff 81       	ldd	r31, Y+7	; 0x07
    2aa4:	21 81       	ldd	r18, Z+1	; 0x01
    2aa6:	32 81       	ldd	r19, Z+2	; 0x02
    2aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2aac:	82 1b       	sub	r24, r18
    2aae:	93 0b       	sbc	r25, r19
    2ab0:	9a 83       	std	Y+2, r25	; 0x02
    2ab2:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    2ab4:	e8 85       	ldd	r30, Y+8	; 0x08
    2ab6:	f9 85       	ldd	r31, Y+9	; 0x09
    2ab8:	80 81       	ld	r24, Z
    2aba:	91 81       	ldd	r25, Z+1	; 0x01
    2abc:	2f ef       	ldi	r18, 0xFF	; 255
    2abe:	8f 3f       	cpi	r24, 0xFF	; 255
    2ac0:	92 07       	cpc	r25, r18
    2ac2:	11 f4       	brne	.+4      	; 0x2ac8 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    2ac4:	1d 82       	std	Y+5, r1	; 0x05
    2ac6:	36 c0       	rjmp	.+108    	; 0x2b34 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2ac8:	ee 81       	ldd	r30, Y+6	; 0x06
    2aca:	ff 81       	ldd	r31, Y+7	; 0x07
    2acc:	90 81       	ld	r25, Z
    2ace:	80 91 5d 04 	lds	r24, 0x045D
    2ad2:	98 17       	cp	r25, r24
    2ad4:	61 f0       	breq	.+24     	; 0x2aee <xTaskCheckForTimeOut+0x7c>
    2ad6:	ee 81       	ldd	r30, Y+6	; 0x06
    2ad8:	ff 81       	ldd	r31, Y+7	; 0x07
    2ada:	21 81       	ldd	r18, Z+1	; 0x01
    2adc:	32 81       	ldd	r19, Z+2	; 0x02
    2ade:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae2:	82 17       	cp	r24, r18
    2ae4:	93 07       	cpc	r25, r19
    2ae6:	18 f0       	brcs	.+6      	; 0x2aee <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2ae8:	81 e0       	ldi	r24, 0x01	; 1
    2aea:	8d 83       	std	Y+5, r24	; 0x05
    2aec:	23 c0       	rjmp	.+70     	; 0x2b34 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2aee:	e8 85       	ldd	r30, Y+8	; 0x08
    2af0:	f9 85       	ldd	r31, Y+9	; 0x09
    2af2:	20 81       	ld	r18, Z
    2af4:	31 81       	ldd	r19, Z+1	; 0x01
    2af6:	89 81       	ldd	r24, Y+1	; 0x01
    2af8:	9a 81       	ldd	r25, Y+2	; 0x02
    2afa:	82 17       	cp	r24, r18
    2afc:	93 07       	cpc	r25, r19
    2afe:	a0 f4       	brcc	.+40     	; 0x2b28 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2b00:	e8 85       	ldd	r30, Y+8	; 0x08
    2b02:	f9 85       	ldd	r31, Y+9	; 0x09
    2b04:	20 81       	ld	r18, Z
    2b06:	31 81       	ldd	r19, Z+1	; 0x01
    2b08:	89 81       	ldd	r24, Y+1	; 0x01
    2b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b0c:	a9 01       	movw	r20, r18
    2b0e:	48 1b       	sub	r20, r24
    2b10:	59 0b       	sbc	r21, r25
    2b12:	ca 01       	movw	r24, r20
    2b14:	e8 85       	ldd	r30, Y+8	; 0x08
    2b16:	f9 85       	ldd	r31, Y+9	; 0x09
    2b18:	91 83       	std	Z+1, r25	; 0x01
    2b1a:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    2b1c:	8e 81       	ldd	r24, Y+6	; 0x06
    2b1e:	9f 81       	ldd	r25, Y+7	; 0x07
    2b20:	0e 94 20 15 	call	0x2a40	; 0x2a40 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    2b24:	1d 82       	std	Y+5, r1	; 0x05
    2b26:	06 c0       	rjmp	.+12     	; 0x2b34 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    2b28:	e8 85       	ldd	r30, Y+8	; 0x08
    2b2a:	f9 85       	ldd	r31, Y+9	; 0x09
    2b2c:	11 82       	std	Z+1, r1	; 0x01
    2b2e:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    2b30:	81 e0       	ldi	r24, 0x01	; 1
    2b32:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    2b34:	0f 90       	pop	r0
    2b36:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2b38:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2b3a:	29 96       	adiw	r28, 0x09	; 9
    2b3c:	0f b6       	in	r0, 0x3f	; 63
    2b3e:	f8 94       	cli
    2b40:	de bf       	out	0x3e, r29	; 62
    2b42:	0f be       	out	0x3f, r0	; 63
    2b44:	cd bf       	out	0x3d, r28	; 61
    2b46:	cf 91       	pop	r28
    2b48:	df 91       	pop	r29
    2b4a:	08 95       	ret

00002b4c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2b4c:	df 93       	push	r29
    2b4e:	cf 93       	push	r28
    2b50:	cd b7       	in	r28, 0x3d	; 61
    2b52:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2b54:	81 e0       	ldi	r24, 0x01	; 1
    2b56:	80 93 5c 04 	sts	0x045C, r24
}
    2b5a:	cf 91       	pop	r28
    2b5c:	df 91       	pop	r29
    2b5e:	08 95       	ret

00002b60 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2b60:	df 93       	push	r29
    2b62:	cf 93       	push	r28
    2b64:	00 d0       	rcall	.+0      	; 0x2b66 <prvIdleTask+0x6>
    2b66:	cd b7       	in	r28, 0x3d	; 61
    2b68:	de b7       	in	r29, 0x3e	; 62
    2b6a:	9a 83       	std	Y+2, r25	; 0x02
    2b6c:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    2b6e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvCheckTasksWaitingTermination>
    2b72:	fd cf       	rjmp	.-6      	; 0x2b6e <prvIdleTask+0xe>

00002b74 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2b74:	df 93       	push	r29
    2b76:	cf 93       	push	r28
    2b78:	0f 92       	push	r0
    2b7a:	cd b7       	in	r28, 0x3d	; 61
    2b7c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2b7e:	19 82       	std	Y+1, r1	; 0x01
    2b80:	13 c0       	rjmp	.+38     	; 0x2ba8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
    2b84:	28 2f       	mov	r18, r24
    2b86:	30 e0       	ldi	r19, 0x00	; 0
    2b88:	c9 01       	movw	r24, r18
    2b8a:	88 0f       	add	r24, r24
    2b8c:	99 1f       	adc	r25, r25
    2b8e:	88 0f       	add	r24, r24
    2b90:	99 1f       	adc	r25, r25
    2b92:	88 0f       	add	r24, r24
    2b94:	99 1f       	adc	r25, r25
    2b96:	82 0f       	add	r24, r18
    2b98:	93 1f       	adc	r25, r19
    2b9a:	8c 59       	subi	r24, 0x9C	; 156
    2b9c:	9b 4f       	sbci	r25, 0xFB	; 251
    2b9e:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2ba2:	89 81       	ldd	r24, Y+1	; 0x01
    2ba4:	8f 5f       	subi	r24, 0xFF	; 255
    2ba6:	89 83       	std	Y+1, r24	; 0x01
    2ba8:	89 81       	ldd	r24, Y+1	; 0x01
    2baa:	85 30       	cpi	r24, 0x05	; 5
    2bac:	50 f3       	brcs	.-44     	; 0x2b82 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2bae:	81 e9       	ldi	r24, 0x91	; 145
    2bb0:	94 e0       	ldi	r25, 0x04	; 4
    2bb2:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2bb6:	8a e9       	ldi	r24, 0x9A	; 154
    2bb8:	94 e0       	ldi	r25, 0x04	; 4
    2bba:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2bbe:	87 ea       	ldi	r24, 0xA7	; 167
    2bc0:	94 e0       	ldi	r25, 0x04	; 4
    2bc2:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    2bc6:	80 eb       	ldi	r24, 0xB0	; 176
    2bc8:	94 e0       	ldi	r25, 0x04	; 4
    2bca:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    2bce:	89 eb       	ldi	r24, 0xB9	; 185
    2bd0:	94 e0       	ldi	r25, 0x04	; 4
    2bd2:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2bd6:	81 e9       	ldi	r24, 0x91	; 145
    2bd8:	94 e0       	ldi	r25, 0x04	; 4
    2bda:	90 93 a4 04 	sts	0x04A4, r25
    2bde:	80 93 a3 04 	sts	0x04A3, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2be2:	8a e9       	ldi	r24, 0x9A	; 154
    2be4:	94 e0       	ldi	r25, 0x04	; 4
    2be6:	90 93 a6 04 	sts	0x04A6, r25
    2bea:	80 93 a5 04 	sts	0x04A5, r24
}
    2bee:	0f 90       	pop	r0
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2bf6:	df 93       	push	r29
    2bf8:	cf 93       	push	r28
    2bfa:	00 d0       	rcall	.+0      	; 0x2bfc <prvCheckTasksWaitingTermination+0x6>
    2bfc:	cd b7       	in	r28, 0x3d	; 61
    2bfe:	de b7       	in	r29, 0x3e	; 62
    2c00:	20 c0       	rjmp	.+64     	; 0x2c42 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    2c02:	0f b6       	in	r0, 0x3f	; 63
    2c04:	f8 94       	cli
    2c06:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2c08:	e0 91 b5 04 	lds	r30, 0x04B5
    2c0c:	f0 91 b6 04 	lds	r31, 0x04B6
    2c10:	86 81       	ldd	r24, Z+6	; 0x06
    2c12:	97 81       	ldd	r25, Z+7	; 0x07
    2c14:	9a 83       	std	Y+2, r25	; 0x02
    2c16:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2c18:	89 81       	ldd	r24, Y+1	; 0x01
    2c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1c:	02 96       	adiw	r24, 0x02	; 2
    2c1e:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
				--uxCurrentNumberOfTasks;
    2c22:	80 91 55 04 	lds	r24, 0x0455
    2c26:	81 50       	subi	r24, 0x01	; 1
    2c28:	80 93 55 04 	sts	0x0455, r24
				--uxDeletedTasksWaitingCleanUp;
    2c2c:	80 91 54 04 	lds	r24, 0x0454
    2c30:	81 50       	subi	r24, 0x01	; 1
    2c32:	80 93 54 04 	sts	0x0454, r24
			}
			taskEXIT_CRITICAL();
    2c36:	0f 90       	pop	r0
    2c38:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    2c3a:	89 81       	ldd	r24, Y+1	; 0x01
    2c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3e:	0e 94 2a 16 	call	0x2c54	; 0x2c54 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2c42:	80 91 54 04 	lds	r24, 0x0454
    2c46:	88 23       	and	r24, r24
    2c48:	e1 f6       	brne	.-72     	; 0x2c02 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    2c4a:	0f 90       	pop	r0
    2c4c:	0f 90       	pop	r0
    2c4e:	cf 91       	pop	r28
    2c50:	df 91       	pop	r29
    2c52:	08 95       	ret

00002c54 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2c54:	df 93       	push	r29
    2c56:	cf 93       	push	r28
    2c58:	00 d0       	rcall	.+0      	; 0x2c5a <prvDeleteTCB+0x6>
    2c5a:	cd b7       	in	r28, 0x3d	; 61
    2c5c:	de b7       	in	r29, 0x3e	; 62
    2c5e:	9a 83       	std	Y+2, r25	; 0x02
    2c60:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    2c62:	e9 81       	ldd	r30, Y+1	; 0x01
    2c64:	fa 81       	ldd	r31, Y+2	; 0x02
    2c66:	87 89       	ldd	r24, Z+23	; 0x17
    2c68:	90 8d       	ldd	r25, Z+24	; 0x18
    2c6a:	0e 94 9f 00 	call	0x13e	; 0x13e <vPortFree>
			vPortFree( pxTCB );
    2c6e:	89 81       	ldd	r24, Y+1	; 0x01
    2c70:	9a 81       	ldd	r25, Y+2	; 0x02
    2c72:	0e 94 9f 00 	call	0x13e	; 0x13e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    2c76:	0f 90       	pop	r0
    2c78:	0f 90       	pop	r0
    2c7a:	cf 91       	pop	r28
    2c7c:	df 91       	pop	r29
    2c7e:	08 95       	ret

00002c80 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2c80:	df 93       	push	r29
    2c82:	cf 93       	push	r28
    2c84:	00 d0       	rcall	.+0      	; 0x2c86 <prvResetNextTaskUnblockTime+0x6>
    2c86:	cd b7       	in	r28, 0x3d	; 61
    2c88:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2c8a:	e0 91 a3 04 	lds	r30, 0x04A3
    2c8e:	f0 91 a4 04 	lds	r31, 0x04A4
    2c92:	80 81       	ld	r24, Z
    2c94:	88 23       	and	r24, r24
    2c96:	39 f4       	brne	.+14     	; 0x2ca6 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2c98:	8f ef       	ldi	r24, 0xFF	; 255
    2c9a:	9f ef       	ldi	r25, 0xFF	; 255
    2c9c:	90 93 60 04 	sts	0x0460, r25
    2ca0:	80 93 5f 04 	sts	0x045F, r24
    2ca4:	13 c0       	rjmp	.+38     	; 0x2ccc <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2ca6:	e0 91 a3 04 	lds	r30, 0x04A3
    2caa:	f0 91 a4 04 	lds	r31, 0x04A4
    2cae:	05 80       	ldd	r0, Z+5	; 0x05
    2cb0:	f6 81       	ldd	r31, Z+6	; 0x06
    2cb2:	e0 2d       	mov	r30, r0
    2cb4:	86 81       	ldd	r24, Z+6	; 0x06
    2cb6:	97 81       	ldd	r25, Z+7	; 0x07
    2cb8:	9a 83       	std	Y+2, r25	; 0x02
    2cba:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    2cbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2cbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2cc0:	82 81       	ldd	r24, Z+2	; 0x02
    2cc2:	93 81       	ldd	r25, Z+3	; 0x03
    2cc4:	90 93 60 04 	sts	0x0460, r25
    2cc8:	80 93 5f 04 	sts	0x045F, r24
	}
}
    2ccc:	0f 90       	pop	r0
    2cce:	0f 90       	pop	r0
    2cd0:	cf 91       	pop	r28
    2cd2:	df 91       	pop	r29
    2cd4:	08 95       	ret

00002cd6 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    2cd6:	df 93       	push	r29
    2cd8:	cf 93       	push	r28
    2cda:	00 d0       	rcall	.+0      	; 0x2cdc <uxTaskResetEventItemValue+0x6>
    2cdc:	cd b7       	in	r28, 0x3d	; 61
    2cde:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2ce0:	e0 91 52 04 	lds	r30, 0x0452
    2ce4:	f0 91 53 04 	lds	r31, 0x0453
    2ce8:	84 85       	ldd	r24, Z+12	; 0x0c
    2cea:	95 85       	ldd	r25, Z+13	; 0x0d
    2cec:	9a 83       	std	Y+2, r25	; 0x02
    2cee:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2cf0:	a0 91 52 04 	lds	r26, 0x0452
    2cf4:	b0 91 53 04 	lds	r27, 0x0453
    2cf8:	e0 91 52 04 	lds	r30, 0x0452
    2cfc:	f0 91 53 04 	lds	r31, 0x0453
    2d00:	86 89       	ldd	r24, Z+22	; 0x16
    2d02:	28 2f       	mov	r18, r24
    2d04:	30 e0       	ldi	r19, 0x00	; 0
    2d06:	85 e0       	ldi	r24, 0x05	; 5
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	82 1b       	sub	r24, r18
    2d0c:	93 0b       	sbc	r25, r19
    2d0e:	1d 96       	adiw	r26, 0x0d	; 13
    2d10:	9c 93       	st	X, r25
    2d12:	8e 93       	st	-X, r24
    2d14:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    2d16:	89 81       	ldd	r24, Y+1	; 0x01
    2d18:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d1a:	0f 90       	pop	r0
    2d1c:	0f 90       	pop	r0
    2d1e:	cf 91       	pop	r28
    2d20:	df 91       	pop	r29
    2d22:	08 95       	ret

00002d24 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2d24:	df 93       	push	r29
    2d26:	cf 93       	push	r28
    2d28:	cd b7       	in	r28, 0x3d	; 61
    2d2a:	de b7       	in	r29, 0x3e	; 62
    2d2c:	27 97       	sbiw	r28, 0x07	; 7
    2d2e:	0f b6       	in	r0, 0x3f	; 63
    2d30:	f8 94       	cli
    2d32:	de bf       	out	0x3e, r29	; 62
    2d34:	0f be       	out	0x3f, r0	; 63
    2d36:	cd bf       	out	0x3d, r28	; 61
    2d38:	8d 83       	std	Y+5, r24	; 0x05
    2d3a:	7f 83       	std	Y+7, r23	; 0x07
    2d3c:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2d3e:	0f b6       	in	r0, 0x3f	; 63
    2d40:	f8 94       	cli
    2d42:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2d44:	e0 91 52 04 	lds	r30, 0x0452
    2d48:	f0 91 53 04 	lds	r31, 0x0453
    2d4c:	81 a1       	ldd	r24, Z+33	; 0x21
    2d4e:	92 a1       	ldd	r25, Z+34	; 0x22
    2d50:	a3 a1       	ldd	r26, Z+35	; 0x23
    2d52:	b4 a1       	ldd	r27, Z+36	; 0x24
    2d54:	00 97       	sbiw	r24, 0x00	; 0
    2d56:	a1 05       	cpc	r26, r1
    2d58:	b1 05       	cpc	r27, r1
    2d5a:	89 f4       	brne	.+34     	; 0x2d7e <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2d5c:	e0 91 52 04 	lds	r30, 0x0452
    2d60:	f0 91 53 04 	lds	r31, 0x0453
    2d64:	81 e0       	ldi	r24, 0x01	; 1
    2d66:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    2d68:	8e 81       	ldd	r24, Y+6	; 0x06
    2d6a:	9f 81       	ldd	r25, Y+7	; 0x07
    2d6c:	00 97       	sbiw	r24, 0x00	; 0
    2d6e:	39 f0       	breq	.+14     	; 0x2d7e <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2d70:	8e 81       	ldd	r24, Y+6	; 0x06
    2d72:	9f 81       	ldd	r25, Y+7	; 0x07
    2d74:	61 e0       	ldi	r22, 0x01	; 1
    2d76:	0e 94 95 1a 	call	0x352a	; 0x352a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2d7a:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2d7e:	0f 90       	pop	r0
    2d80:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2d82:	0f b6       	in	r0, 0x3f	; 63
    2d84:	f8 94       	cli
    2d86:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2d88:	e0 91 52 04 	lds	r30, 0x0452
    2d8c:	f0 91 53 04 	lds	r31, 0x0453
    2d90:	81 a1       	ldd	r24, Z+33	; 0x21
    2d92:	92 a1       	ldd	r25, Z+34	; 0x22
    2d94:	a3 a1       	ldd	r26, Z+35	; 0x23
    2d96:	b4 a1       	ldd	r27, Z+36	; 0x24
    2d98:	89 83       	std	Y+1, r24	; 0x01
    2d9a:	9a 83       	std	Y+2, r25	; 0x02
    2d9c:	ab 83       	std	Y+3, r26	; 0x03
    2d9e:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    2da0:	89 81       	ldd	r24, Y+1	; 0x01
    2da2:	9a 81       	ldd	r25, Y+2	; 0x02
    2da4:	ab 81       	ldd	r26, Y+3	; 0x03
    2da6:	bc 81       	ldd	r27, Y+4	; 0x04
    2da8:	00 97       	sbiw	r24, 0x00	; 0
    2daa:	a1 05       	cpc	r26, r1
    2dac:	b1 05       	cpc	r27, r1
    2dae:	d9 f0       	breq	.+54     	; 0x2de6 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    2db0:	8d 81       	ldd	r24, Y+5	; 0x05
    2db2:	88 23       	and	r24, r24
    2db4:	49 f0       	breq	.+18     	; 0x2dc8 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2db6:	e0 91 52 04 	lds	r30, 0x0452
    2dba:	f0 91 53 04 	lds	r31, 0x0453
    2dbe:	11 a2       	std	Z+33, r1	; 0x21
    2dc0:	12 a2       	std	Z+34, r1	; 0x22
    2dc2:	13 a2       	std	Z+35, r1	; 0x23
    2dc4:	14 a2       	std	Z+36, r1	; 0x24
    2dc6:	0f c0       	rjmp	.+30     	; 0x2de6 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    2dc8:	e0 91 52 04 	lds	r30, 0x0452
    2dcc:	f0 91 53 04 	lds	r31, 0x0453
    2dd0:	89 81       	ldd	r24, Y+1	; 0x01
    2dd2:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd4:	ab 81       	ldd	r26, Y+3	; 0x03
    2dd6:	bc 81       	ldd	r27, Y+4	; 0x04
    2dd8:	01 97       	sbiw	r24, 0x01	; 1
    2dda:	a1 09       	sbc	r26, r1
    2ddc:	b1 09       	sbc	r27, r1
    2dde:	81 a3       	std	Z+33, r24	; 0x21
    2de0:	92 a3       	std	Z+34, r25	; 0x22
    2de2:	a3 a3       	std	Z+35, r26	; 0x23
    2de4:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2de6:	e0 91 52 04 	lds	r30, 0x0452
    2dea:	f0 91 53 04 	lds	r31, 0x0453
    2dee:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    2df0:	0f 90       	pop	r0
    2df2:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    2df4:	89 81       	ldd	r24, Y+1	; 0x01
    2df6:	9a 81       	ldd	r25, Y+2	; 0x02
    2df8:	ab 81       	ldd	r26, Y+3	; 0x03
    2dfa:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    2dfc:	bc 01       	movw	r22, r24
    2dfe:	cd 01       	movw	r24, r26
    2e00:	27 96       	adiw	r28, 0x07	; 7
    2e02:	0f b6       	in	r0, 0x3f	; 63
    2e04:	f8 94       	cli
    2e06:	de bf       	out	0x3e, r29	; 62
    2e08:	0f be       	out	0x3f, r0	; 63
    2e0a:	cd bf       	out	0x3d, r28	; 61
    2e0c:	cf 91       	pop	r28
    2e0e:	df 91       	pop	r29
    2e10:	08 95       	ret

00002e12 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2e12:	ef 92       	push	r14
    2e14:	ff 92       	push	r15
    2e16:	0f 93       	push	r16
    2e18:	1f 93       	push	r17
    2e1a:	df 93       	push	r29
    2e1c:	cf 93       	push	r28
    2e1e:	cd b7       	in	r28, 0x3d	; 61
    2e20:	de b7       	in	r29, 0x3e	; 62
    2e22:	2d 97       	sbiw	r28, 0x0d	; 13
    2e24:	0f b6       	in	r0, 0x3f	; 63
    2e26:	f8 94       	cli
    2e28:	de bf       	out	0x3e, r29	; 62
    2e2a:	0f be       	out	0x3f, r0	; 63
    2e2c:	cd bf       	out	0x3d, r28	; 61
    2e2e:	6a 83       	std	Y+2, r22	; 0x02
    2e30:	7b 83       	std	Y+3, r23	; 0x03
    2e32:	8c 83       	std	Y+4, r24	; 0x04
    2e34:	9d 83       	std	Y+5, r25	; 0x05
    2e36:	2e 83       	std	Y+6, r18	; 0x06
    2e38:	3f 83       	std	Y+7, r19	; 0x07
    2e3a:	48 87       	std	Y+8, r20	; 0x08
    2e3c:	59 87       	std	Y+9, r21	; 0x09
    2e3e:	1b 87       	std	Y+11, r17	; 0x0b
    2e40:	0a 87       	std	Y+10, r16	; 0x0a
    2e42:	fd 86       	std	Y+13, r15	; 0x0d
    2e44:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2e46:	0f b6       	in	r0, 0x3f	; 63
    2e48:	f8 94       	cli
    2e4a:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2e4c:	e0 91 52 04 	lds	r30, 0x0452
    2e50:	f0 91 53 04 	lds	r31, 0x0453
    2e54:	85 a1       	ldd	r24, Z+37	; 0x25
    2e56:	82 30       	cpi	r24, 0x02	; 2
    2e58:	49 f1       	breq	.+82     	; 0x2eac <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    2e5a:	e0 91 52 04 	lds	r30, 0x0452
    2e5e:	f0 91 53 04 	lds	r31, 0x0453
    2e62:	21 a1       	ldd	r18, Z+33	; 0x21
    2e64:	32 a1       	ldd	r19, Z+34	; 0x22
    2e66:	43 a1       	ldd	r20, Z+35	; 0x23
    2e68:	54 a1       	ldd	r21, Z+36	; 0x24
    2e6a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e6e:	ac 81       	ldd	r26, Y+4	; 0x04
    2e70:	bd 81       	ldd	r27, Y+5	; 0x05
    2e72:	80 95       	com	r24
    2e74:	90 95       	com	r25
    2e76:	a0 95       	com	r26
    2e78:	b0 95       	com	r27
    2e7a:	82 23       	and	r24, r18
    2e7c:	93 23       	and	r25, r19
    2e7e:	a4 23       	and	r26, r20
    2e80:	b5 23       	and	r27, r21
    2e82:	81 a3       	std	Z+33, r24	; 0x21
    2e84:	92 a3       	std	Z+34, r25	; 0x22
    2e86:	a3 a3       	std	Z+35, r26	; 0x23
    2e88:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2e8a:	e0 91 52 04 	lds	r30, 0x0452
    2e8e:	f0 91 53 04 	lds	r31, 0x0453
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    2e96:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e98:	9d 85       	ldd	r25, Y+13	; 0x0d
    2e9a:	00 97       	sbiw	r24, 0x00	; 0
    2e9c:	39 f0       	breq	.+14     	; 0x2eac <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2e9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ea0:	9d 85       	ldd	r25, Y+13	; 0x0d
    2ea2:	61 e0       	ldi	r22, 0x01	; 1
    2ea4:	0e 94 95 1a 	call	0x352a	; 0x352a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2ea8:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2eac:	0f 90       	pop	r0
    2eae:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2eb0:	0f b6       	in	r0, 0x3f	; 63
    2eb2:	f8 94       	cli
    2eb4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2eb6:	8a 85       	ldd	r24, Y+10	; 0x0a
    2eb8:	9b 85       	ldd	r25, Y+11	; 0x0b
    2eba:	00 97       	sbiw	r24, 0x00	; 0
    2ebc:	71 f0       	breq	.+28     	; 0x2eda <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2ebe:	e0 91 52 04 	lds	r30, 0x0452
    2ec2:	f0 91 53 04 	lds	r31, 0x0453
    2ec6:	81 a1       	ldd	r24, Z+33	; 0x21
    2ec8:	92 a1       	ldd	r25, Z+34	; 0x22
    2eca:	a3 a1       	ldd	r26, Z+35	; 0x23
    2ecc:	b4 a1       	ldd	r27, Z+36	; 0x24
    2ece:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ed0:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ed2:	80 83       	st	Z, r24
    2ed4:	91 83       	std	Z+1, r25	; 0x01
    2ed6:	a2 83       	std	Z+2, r26	; 0x02
    2ed8:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2eda:	e0 91 52 04 	lds	r30, 0x0452
    2ede:	f0 91 53 04 	lds	r31, 0x0453
    2ee2:	85 a1       	ldd	r24, Z+37	; 0x25
    2ee4:	82 30       	cpi	r24, 0x02	; 2
    2ee6:	11 f0       	breq	.+4      	; 0x2eec <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2ee8:	19 82       	std	Y+1, r1	; 0x01
    2eea:	1a c0       	rjmp	.+52     	; 0x2f20 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2eec:	e0 91 52 04 	lds	r30, 0x0452
    2ef0:	f0 91 53 04 	lds	r31, 0x0453
    2ef4:	21 a1       	ldd	r18, Z+33	; 0x21
    2ef6:	32 a1       	ldd	r19, Z+34	; 0x22
    2ef8:	43 a1       	ldd	r20, Z+35	; 0x23
    2efa:	54 a1       	ldd	r21, Z+36	; 0x24
    2efc:	8e 81       	ldd	r24, Y+6	; 0x06
    2efe:	9f 81       	ldd	r25, Y+7	; 0x07
    2f00:	a8 85       	ldd	r26, Y+8	; 0x08
    2f02:	b9 85       	ldd	r27, Y+9	; 0x09
    2f04:	80 95       	com	r24
    2f06:	90 95       	com	r25
    2f08:	a0 95       	com	r26
    2f0a:	b0 95       	com	r27
    2f0c:	82 23       	and	r24, r18
    2f0e:	93 23       	and	r25, r19
    2f10:	a4 23       	and	r26, r20
    2f12:	b5 23       	and	r27, r21
    2f14:	81 a3       	std	Z+33, r24	; 0x21
    2f16:	92 a3       	std	Z+34, r25	; 0x22
    2f18:	a3 a3       	std	Z+35, r26	; 0x23
    2f1a:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2f20:	e0 91 52 04 	lds	r30, 0x0452
    2f24:	f0 91 53 04 	lds	r31, 0x0453
    2f28:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    2f2a:	0f 90       	pop	r0
    2f2c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    2f2e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2f30:	2d 96       	adiw	r28, 0x0d	; 13
    2f32:	0f b6       	in	r0, 0x3f	; 63
    2f34:	f8 94       	cli
    2f36:	de bf       	out	0x3e, r29	; 62
    2f38:	0f be       	out	0x3f, r0	; 63
    2f3a:	cd bf       	out	0x3d, r28	; 61
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	1f 91       	pop	r17
    2f42:	0f 91       	pop	r16
    2f44:	ff 90       	pop	r15
    2f46:	ef 90       	pop	r14
    2f48:	08 95       	ret

00002f4a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2f4a:	0f 93       	push	r16
    2f4c:	1f 93       	push	r17
    2f4e:	df 93       	push	r29
    2f50:	cf 93       	push	r28
    2f52:	cd b7       	in	r28, 0x3d	; 61
    2f54:	de b7       	in	r29, 0x3e	; 62
    2f56:	2f 97       	sbiw	r28, 0x0f	; 15
    2f58:	0f b6       	in	r0, 0x3f	; 63
    2f5a:	f8 94       	cli
    2f5c:	de bf       	out	0x3e, r29	; 62
    2f5e:	0f be       	out	0x3f, r0	; 63
    2f60:	cd bf       	out	0x3d, r28	; 61
    2f62:	9e 83       	std	Y+6, r25	; 0x06
    2f64:	8d 83       	std	Y+5, r24	; 0x05
    2f66:	4f 83       	std	Y+7, r20	; 0x07
    2f68:	58 87       	std	Y+8, r21	; 0x08
    2f6a:	69 87       	std	Y+9, r22	; 0x09
    2f6c:	7a 87       	std	Y+10, r23	; 0x0a
    2f6e:	2b 87       	std	Y+11, r18	; 0x0b
    2f70:	1d 87       	std	Y+13, r17	; 0x0d
    2f72:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    2f78:	8d 81       	ldd	r24, Y+5	; 0x05
    2f7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2f7c:	9c 83       	std	Y+4, r25	; 0x04
    2f7e:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    2f80:	0f b6       	in	r0, 0x3f	; 63
    2f82:	f8 94       	cli
    2f84:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2f86:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f88:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f8a:	00 97       	sbiw	r24, 0x00	; 0
    2f8c:	61 f0       	breq	.+24     	; 0x2fa6 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f90:	fc 81       	ldd	r31, Y+4	; 0x04
    2f92:	81 a1       	ldd	r24, Z+33	; 0x21
    2f94:	92 a1       	ldd	r25, Z+34	; 0x22
    2f96:	a3 a1       	ldd	r26, Z+35	; 0x23
    2f98:	b4 a1       	ldd	r27, Z+36	; 0x24
    2f9a:	ec 85       	ldd	r30, Y+12	; 0x0c
    2f9c:	fd 85       	ldd	r31, Y+13	; 0x0d
    2f9e:	80 83       	st	Z, r24
    2fa0:	91 83       	std	Z+1, r25	; 0x01
    2fa2:	a2 83       	std	Z+2, r26	; 0x02
    2fa4:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2fa6:	eb 81       	ldd	r30, Y+3	; 0x03
    2fa8:	fc 81       	ldd	r31, Y+4	; 0x04
    2faa:	85 a1       	ldd	r24, Z+37	; 0x25
    2fac:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2fae:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb2:	82 e0       	ldi	r24, 0x02	; 2
    2fb4:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    2fb6:	8b 85       	ldd	r24, Y+11	; 0x0b
    2fb8:	28 2f       	mov	r18, r24
    2fba:	30 e0       	ldi	r19, 0x00	; 0
    2fbc:	3f 87       	std	Y+15, r19	; 0x0f
    2fbe:	2e 87       	std	Y+14, r18	; 0x0e
    2fc0:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fc2:	9f 85       	ldd	r25, Y+15	; 0x0f
    2fc4:	82 30       	cpi	r24, 0x02	; 2
    2fc6:	91 05       	cpc	r25, r1
    2fc8:	59 f1       	breq	.+86     	; 0x3020 <xTaskGenericNotify+0xd6>
    2fca:	2e 85       	ldd	r18, Y+14	; 0x0e
    2fcc:	3f 85       	ldd	r19, Y+15	; 0x0f
    2fce:	23 30       	cpi	r18, 0x03	; 3
    2fd0:	31 05       	cpc	r19, r1
    2fd2:	34 f4       	brge	.+12     	; 0x2fe0 <xTaskGenericNotify+0x96>
    2fd4:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fd6:	9f 85       	ldd	r25, Y+15	; 0x0f
    2fd8:	81 30       	cpi	r24, 0x01	; 1
    2fda:	91 05       	cpc	r25, r1
    2fdc:	61 f0       	breq	.+24     	; 0x2ff6 <xTaskGenericNotify+0xac>
    2fde:	4a c0       	rjmp	.+148    	; 0x3074 <xTaskGenericNotify+0x12a>
    2fe0:	2e 85       	ldd	r18, Y+14	; 0x0e
    2fe2:	3f 85       	ldd	r19, Y+15	; 0x0f
    2fe4:	23 30       	cpi	r18, 0x03	; 3
    2fe6:	31 05       	cpc	r19, r1
    2fe8:	59 f1       	breq	.+86     	; 0x3040 <xTaskGenericNotify+0xf6>
    2fea:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fec:	9f 85       	ldd	r25, Y+15	; 0x0f
    2fee:	84 30       	cpi	r24, 0x04	; 4
    2ff0:	91 05       	cpc	r25, r1
    2ff2:	89 f1       	breq	.+98     	; 0x3056 <xTaskGenericNotify+0x10c>
    2ff4:	3f c0       	rjmp	.+126    	; 0x3074 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    2ffa:	21 a1       	ldd	r18, Z+33	; 0x21
    2ffc:	32 a1       	ldd	r19, Z+34	; 0x22
    2ffe:	43 a1       	ldd	r20, Z+35	; 0x23
    3000:	54 a1       	ldd	r21, Z+36	; 0x24
    3002:	8f 81       	ldd	r24, Y+7	; 0x07
    3004:	98 85       	ldd	r25, Y+8	; 0x08
    3006:	a9 85       	ldd	r26, Y+9	; 0x09
    3008:	ba 85       	ldd	r27, Y+10	; 0x0a
    300a:	82 2b       	or	r24, r18
    300c:	93 2b       	or	r25, r19
    300e:	a4 2b       	or	r26, r20
    3010:	b5 2b       	or	r27, r21
    3012:	eb 81       	ldd	r30, Y+3	; 0x03
    3014:	fc 81       	ldd	r31, Y+4	; 0x04
    3016:	81 a3       	std	Z+33, r24	; 0x21
    3018:	92 a3       	std	Z+34, r25	; 0x22
    301a:	a3 a3       	std	Z+35, r26	; 0x23
    301c:	b4 a3       	std	Z+36, r27	; 0x24
    301e:	2a c0       	rjmp	.+84     	; 0x3074 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3020:	eb 81       	ldd	r30, Y+3	; 0x03
    3022:	fc 81       	ldd	r31, Y+4	; 0x04
    3024:	81 a1       	ldd	r24, Z+33	; 0x21
    3026:	92 a1       	ldd	r25, Z+34	; 0x22
    3028:	a3 a1       	ldd	r26, Z+35	; 0x23
    302a:	b4 a1       	ldd	r27, Z+36	; 0x24
    302c:	01 96       	adiw	r24, 0x01	; 1
    302e:	a1 1d       	adc	r26, r1
    3030:	b1 1d       	adc	r27, r1
    3032:	eb 81       	ldd	r30, Y+3	; 0x03
    3034:	fc 81       	ldd	r31, Y+4	; 0x04
    3036:	81 a3       	std	Z+33, r24	; 0x21
    3038:	92 a3       	std	Z+34, r25	; 0x22
    303a:	a3 a3       	std	Z+35, r26	; 0x23
    303c:	b4 a3       	std	Z+36, r27	; 0x24
    303e:	1a c0       	rjmp	.+52     	; 0x3074 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3040:	eb 81       	ldd	r30, Y+3	; 0x03
    3042:	fc 81       	ldd	r31, Y+4	; 0x04
    3044:	8f 81       	ldd	r24, Y+7	; 0x07
    3046:	98 85       	ldd	r25, Y+8	; 0x08
    3048:	a9 85       	ldd	r26, Y+9	; 0x09
    304a:	ba 85       	ldd	r27, Y+10	; 0x0a
    304c:	81 a3       	std	Z+33, r24	; 0x21
    304e:	92 a3       	std	Z+34, r25	; 0x22
    3050:	a3 a3       	std	Z+35, r26	; 0x23
    3052:	b4 a3       	std	Z+36, r27	; 0x24
    3054:	0f c0       	rjmp	.+30     	; 0x3074 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3056:	89 81       	ldd	r24, Y+1	; 0x01
    3058:	82 30       	cpi	r24, 0x02	; 2
    305a:	59 f0       	breq	.+22     	; 0x3072 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    305c:	eb 81       	ldd	r30, Y+3	; 0x03
    305e:	fc 81       	ldd	r31, Y+4	; 0x04
    3060:	8f 81       	ldd	r24, Y+7	; 0x07
    3062:	98 85       	ldd	r25, Y+8	; 0x08
    3064:	a9 85       	ldd	r26, Y+9	; 0x09
    3066:	ba 85       	ldd	r27, Y+10	; 0x0a
    3068:	81 a3       	std	Z+33, r24	; 0x21
    306a:	92 a3       	std	Z+34, r25	; 0x22
    306c:	a3 a3       	std	Z+35, r26	; 0x23
    306e:	b4 a3       	std	Z+36, r27	; 0x24
    3070:	01 c0       	rjmp	.+2      	; 0x3074 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3072:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3074:	89 81       	ldd	r24, Y+1	; 0x01
    3076:	81 30       	cpi	r24, 0x01	; 1
    3078:	b9 f5       	brne	.+110    	; 0x30e8 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    307a:	8b 81       	ldd	r24, Y+3	; 0x03
    307c:	9c 81       	ldd	r25, Y+4	; 0x04
    307e:	02 96       	adiw	r24, 0x02	; 2
    3080:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    3084:	eb 81       	ldd	r30, Y+3	; 0x03
    3086:	fc 81       	ldd	r31, Y+4	; 0x04
    3088:	96 89       	ldd	r25, Z+22	; 0x16
    308a:	80 91 58 04 	lds	r24, 0x0458
    308e:	89 17       	cp	r24, r25
    3090:	28 f4       	brcc	.+10     	; 0x309c <xTaskGenericNotify+0x152>
    3092:	eb 81       	ldd	r30, Y+3	; 0x03
    3094:	fc 81       	ldd	r31, Y+4	; 0x04
    3096:	86 89       	ldd	r24, Z+22	; 0x16
    3098:	80 93 58 04 	sts	0x0458, r24
    309c:	eb 81       	ldd	r30, Y+3	; 0x03
    309e:	fc 81       	ldd	r31, Y+4	; 0x04
    30a0:	86 89       	ldd	r24, Z+22	; 0x16
    30a2:	28 2f       	mov	r18, r24
    30a4:	30 e0       	ldi	r19, 0x00	; 0
    30a6:	c9 01       	movw	r24, r18
    30a8:	88 0f       	add	r24, r24
    30aa:	99 1f       	adc	r25, r25
    30ac:	88 0f       	add	r24, r24
    30ae:	99 1f       	adc	r25, r25
    30b0:	88 0f       	add	r24, r24
    30b2:	99 1f       	adc	r25, r25
    30b4:	82 0f       	add	r24, r18
    30b6:	93 1f       	adc	r25, r19
    30b8:	ac 01       	movw	r20, r24
    30ba:	4c 59       	subi	r20, 0x9C	; 156
    30bc:	5b 4f       	sbci	r21, 0xFB	; 251
    30be:	8b 81       	ldd	r24, Y+3	; 0x03
    30c0:	9c 81       	ldd	r25, Y+4	; 0x04
    30c2:	9c 01       	movw	r18, r24
    30c4:	2e 5f       	subi	r18, 0xFE	; 254
    30c6:	3f 4f       	sbci	r19, 0xFF	; 255
    30c8:	ca 01       	movw	r24, r20
    30ca:	b9 01       	movw	r22, r18
    30cc:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    30d0:	eb 81       	ldd	r30, Y+3	; 0x03
    30d2:	fc 81       	ldd	r31, Y+4	; 0x04
    30d4:	96 89       	ldd	r25, Z+22	; 0x16
    30d6:	e0 91 52 04 	lds	r30, 0x0452
    30da:	f0 91 53 04 	lds	r31, 0x0453
    30de:	86 89       	ldd	r24, Z+22	; 0x16
    30e0:	89 17       	cp	r24, r25
    30e2:	10 f4       	brcc	.+4      	; 0x30e8 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    30e4:	0e 94 ba 03 	call	0x774	; 0x774 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    30e8:	0f 90       	pop	r0
    30ea:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    30ec:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    30ee:	2f 96       	adiw	r28, 0x0f	; 15
    30f0:	0f b6       	in	r0, 0x3f	; 63
    30f2:	f8 94       	cli
    30f4:	de bf       	out	0x3e, r29	; 62
    30f6:	0f be       	out	0x3f, r0	; 63
    30f8:	cd bf       	out	0x3d, r28	; 61
    30fa:	cf 91       	pop	r28
    30fc:	df 91       	pop	r29
    30fe:	1f 91       	pop	r17
    3100:	0f 91       	pop	r16
    3102:	08 95       	ret

00003104 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3104:	ef 92       	push	r14
    3106:	ff 92       	push	r15
    3108:	0f 93       	push	r16
    310a:	1f 93       	push	r17
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	cd b7       	in	r28, 0x3d	; 61
    3112:	de b7       	in	r29, 0x3e	; 62
    3114:	62 97       	sbiw	r28, 0x12	; 18
    3116:	0f b6       	in	r0, 0x3f	; 63
    3118:	f8 94       	cli
    311a:	de bf       	out	0x3e, r29	; 62
    311c:	0f be       	out	0x3f, r0	; 63
    311e:	cd bf       	out	0x3d, r28	; 61
    3120:	9f 83       	std	Y+7, r25	; 0x07
    3122:	8e 83       	std	Y+6, r24	; 0x06
    3124:	48 87       	std	Y+8, r20	; 0x08
    3126:	59 87       	std	Y+9, r21	; 0x09
    3128:	6a 87       	std	Y+10, r22	; 0x0a
    312a:	7b 87       	std	Y+11, r23	; 0x0b
    312c:	2c 87       	std	Y+12, r18	; 0x0c
    312e:	1e 87       	std	Y+14, r17	; 0x0e
    3130:	0d 87       	std	Y+13, r16	; 0x0d
    3132:	f8 8a       	std	Y+16, r15	; 0x10
    3134:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    3136:	81 e0       	ldi	r24, 0x01	; 1
    3138:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    313a:	8e 81       	ldd	r24, Y+6	; 0x06
    313c:	9f 81       	ldd	r25, Y+7	; 0x07
    313e:	9d 83       	std	Y+5, r25	; 0x05
    3140:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3142:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    3144:	8d 85       	ldd	r24, Y+13	; 0x0d
    3146:	9e 85       	ldd	r25, Y+14	; 0x0e
    3148:	00 97       	sbiw	r24, 0x00	; 0
    314a:	61 f0       	breq	.+24     	; 0x3164 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    314c:	ec 81       	ldd	r30, Y+4	; 0x04
    314e:	fd 81       	ldd	r31, Y+5	; 0x05
    3150:	81 a1       	ldd	r24, Z+33	; 0x21
    3152:	92 a1       	ldd	r25, Z+34	; 0x22
    3154:	a3 a1       	ldd	r26, Z+35	; 0x23
    3156:	b4 a1       	ldd	r27, Z+36	; 0x24
    3158:	ed 85       	ldd	r30, Y+13	; 0x0d
    315a:	fe 85       	ldd	r31, Y+14	; 0x0e
    315c:	80 83       	st	Z, r24
    315e:	91 83       	std	Z+1, r25	; 0x01
    3160:	a2 83       	std	Z+2, r26	; 0x02
    3162:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3164:	ec 81       	ldd	r30, Y+4	; 0x04
    3166:	fd 81       	ldd	r31, Y+5	; 0x05
    3168:	85 a1       	ldd	r24, Z+37	; 0x25
    316a:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    316c:	ec 81       	ldd	r30, Y+4	; 0x04
    316e:	fd 81       	ldd	r31, Y+5	; 0x05
    3170:	82 e0       	ldi	r24, 0x02	; 2
    3172:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3174:	8c 85       	ldd	r24, Y+12	; 0x0c
    3176:	28 2f       	mov	r18, r24
    3178:	30 e0       	ldi	r19, 0x00	; 0
    317a:	3a 8b       	std	Y+18, r19	; 0x12
    317c:	29 8b       	std	Y+17, r18	; 0x11
    317e:	89 89       	ldd	r24, Y+17	; 0x11
    3180:	9a 89       	ldd	r25, Y+18	; 0x12
    3182:	82 30       	cpi	r24, 0x02	; 2
    3184:	91 05       	cpc	r25, r1
    3186:	59 f1       	breq	.+86     	; 0x31de <xTaskGenericNotifyFromISR+0xda>
    3188:	29 89       	ldd	r18, Y+17	; 0x11
    318a:	3a 89       	ldd	r19, Y+18	; 0x12
    318c:	23 30       	cpi	r18, 0x03	; 3
    318e:	31 05       	cpc	r19, r1
    3190:	34 f4       	brge	.+12     	; 0x319e <xTaskGenericNotifyFromISR+0x9a>
    3192:	89 89       	ldd	r24, Y+17	; 0x11
    3194:	9a 89       	ldd	r25, Y+18	; 0x12
    3196:	81 30       	cpi	r24, 0x01	; 1
    3198:	91 05       	cpc	r25, r1
    319a:	61 f0       	breq	.+24     	; 0x31b4 <xTaskGenericNotifyFromISR+0xb0>
    319c:	4a c0       	rjmp	.+148    	; 0x3232 <xTaskGenericNotifyFromISR+0x12e>
    319e:	29 89       	ldd	r18, Y+17	; 0x11
    31a0:	3a 89       	ldd	r19, Y+18	; 0x12
    31a2:	23 30       	cpi	r18, 0x03	; 3
    31a4:	31 05       	cpc	r19, r1
    31a6:	59 f1       	breq	.+86     	; 0x31fe <xTaskGenericNotifyFromISR+0xfa>
    31a8:	89 89       	ldd	r24, Y+17	; 0x11
    31aa:	9a 89       	ldd	r25, Y+18	; 0x12
    31ac:	84 30       	cpi	r24, 0x04	; 4
    31ae:	91 05       	cpc	r25, r1
    31b0:	89 f1       	breq	.+98     	; 0x3214 <xTaskGenericNotifyFromISR+0x110>
    31b2:	3f c0       	rjmp	.+126    	; 0x3232 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    31b4:	ec 81       	ldd	r30, Y+4	; 0x04
    31b6:	fd 81       	ldd	r31, Y+5	; 0x05
    31b8:	21 a1       	ldd	r18, Z+33	; 0x21
    31ba:	32 a1       	ldd	r19, Z+34	; 0x22
    31bc:	43 a1       	ldd	r20, Z+35	; 0x23
    31be:	54 a1       	ldd	r21, Z+36	; 0x24
    31c0:	88 85       	ldd	r24, Y+8	; 0x08
    31c2:	99 85       	ldd	r25, Y+9	; 0x09
    31c4:	aa 85       	ldd	r26, Y+10	; 0x0a
    31c6:	bb 85       	ldd	r27, Y+11	; 0x0b
    31c8:	82 2b       	or	r24, r18
    31ca:	93 2b       	or	r25, r19
    31cc:	a4 2b       	or	r26, r20
    31ce:	b5 2b       	or	r27, r21
    31d0:	ec 81       	ldd	r30, Y+4	; 0x04
    31d2:	fd 81       	ldd	r31, Y+5	; 0x05
    31d4:	81 a3       	std	Z+33, r24	; 0x21
    31d6:	92 a3       	std	Z+34, r25	; 0x22
    31d8:	a3 a3       	std	Z+35, r26	; 0x23
    31da:	b4 a3       	std	Z+36, r27	; 0x24
    31dc:	2a c0       	rjmp	.+84     	; 0x3232 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    31de:	ec 81       	ldd	r30, Y+4	; 0x04
    31e0:	fd 81       	ldd	r31, Y+5	; 0x05
    31e2:	81 a1       	ldd	r24, Z+33	; 0x21
    31e4:	92 a1       	ldd	r25, Z+34	; 0x22
    31e6:	a3 a1       	ldd	r26, Z+35	; 0x23
    31e8:	b4 a1       	ldd	r27, Z+36	; 0x24
    31ea:	01 96       	adiw	r24, 0x01	; 1
    31ec:	a1 1d       	adc	r26, r1
    31ee:	b1 1d       	adc	r27, r1
    31f0:	ec 81       	ldd	r30, Y+4	; 0x04
    31f2:	fd 81       	ldd	r31, Y+5	; 0x05
    31f4:	81 a3       	std	Z+33, r24	; 0x21
    31f6:	92 a3       	std	Z+34, r25	; 0x22
    31f8:	a3 a3       	std	Z+35, r26	; 0x23
    31fa:	b4 a3       	std	Z+36, r27	; 0x24
    31fc:	1a c0       	rjmp	.+52     	; 0x3232 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    31fe:	ec 81       	ldd	r30, Y+4	; 0x04
    3200:	fd 81       	ldd	r31, Y+5	; 0x05
    3202:	88 85       	ldd	r24, Y+8	; 0x08
    3204:	99 85       	ldd	r25, Y+9	; 0x09
    3206:	aa 85       	ldd	r26, Y+10	; 0x0a
    3208:	bb 85       	ldd	r27, Y+11	; 0x0b
    320a:	81 a3       	std	Z+33, r24	; 0x21
    320c:	92 a3       	std	Z+34, r25	; 0x22
    320e:	a3 a3       	std	Z+35, r26	; 0x23
    3210:	b4 a3       	std	Z+36, r27	; 0x24
    3212:	0f c0       	rjmp	.+30     	; 0x3232 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3214:	8b 81       	ldd	r24, Y+3	; 0x03
    3216:	82 30       	cpi	r24, 0x02	; 2
    3218:	59 f0       	breq	.+22     	; 0x3230 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    321a:	ec 81       	ldd	r30, Y+4	; 0x04
    321c:	fd 81       	ldd	r31, Y+5	; 0x05
    321e:	88 85       	ldd	r24, Y+8	; 0x08
    3220:	99 85       	ldd	r25, Y+9	; 0x09
    3222:	aa 85       	ldd	r26, Y+10	; 0x0a
    3224:	bb 85       	ldd	r27, Y+11	; 0x0b
    3226:	81 a3       	std	Z+33, r24	; 0x21
    3228:	92 a3       	std	Z+34, r25	; 0x22
    322a:	a3 a3       	std	Z+35, r26	; 0x23
    322c:	b4 a3       	std	Z+36, r27	; 0x24
    322e:	01 c0       	rjmp	.+2      	; 0x3232 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3230:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3232:	8b 81       	ldd	r24, Y+3	; 0x03
    3234:	81 30       	cpi	r24, 0x01	; 1
    3236:	09 f0       	breq	.+2      	; 0x323a <xTaskGenericNotifyFromISR+0x136>
    3238:	4f c0       	rjmp	.+158    	; 0x32d8 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    323a:	80 91 63 04 	lds	r24, 0x0463
    323e:	88 23       	and	r24, r24
    3240:	61 f5       	brne	.+88     	; 0x329a <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3242:	8c 81       	ldd	r24, Y+4	; 0x04
    3244:	9d 81       	ldd	r25, Y+5	; 0x05
    3246:	02 96       	adiw	r24, 0x02	; 2
    3248:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    324c:	ec 81       	ldd	r30, Y+4	; 0x04
    324e:	fd 81       	ldd	r31, Y+5	; 0x05
    3250:	96 89       	ldd	r25, Z+22	; 0x16
    3252:	80 91 58 04 	lds	r24, 0x0458
    3256:	89 17       	cp	r24, r25
    3258:	28 f4       	brcc	.+10     	; 0x3264 <xTaskGenericNotifyFromISR+0x160>
    325a:	ec 81       	ldd	r30, Y+4	; 0x04
    325c:	fd 81       	ldd	r31, Y+5	; 0x05
    325e:	86 89       	ldd	r24, Z+22	; 0x16
    3260:	80 93 58 04 	sts	0x0458, r24
    3264:	ec 81       	ldd	r30, Y+4	; 0x04
    3266:	fd 81       	ldd	r31, Y+5	; 0x05
    3268:	86 89       	ldd	r24, Z+22	; 0x16
    326a:	28 2f       	mov	r18, r24
    326c:	30 e0       	ldi	r19, 0x00	; 0
    326e:	c9 01       	movw	r24, r18
    3270:	88 0f       	add	r24, r24
    3272:	99 1f       	adc	r25, r25
    3274:	88 0f       	add	r24, r24
    3276:	99 1f       	adc	r25, r25
    3278:	88 0f       	add	r24, r24
    327a:	99 1f       	adc	r25, r25
    327c:	82 0f       	add	r24, r18
    327e:	93 1f       	adc	r25, r19
    3280:	ac 01       	movw	r20, r24
    3282:	4c 59       	subi	r20, 0x9C	; 156
    3284:	5b 4f       	sbci	r21, 0xFB	; 251
    3286:	8c 81       	ldd	r24, Y+4	; 0x04
    3288:	9d 81       	ldd	r25, Y+5	; 0x05
    328a:	9c 01       	movw	r18, r24
    328c:	2e 5f       	subi	r18, 0xFE	; 254
    328e:	3f 4f       	sbci	r19, 0xFF	; 255
    3290:	ca 01       	movw	r24, r20
    3292:	b9 01       	movw	r22, r18
    3294:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
    3298:	0a c0       	rjmp	.+20     	; 0x32ae <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    329a:	8c 81       	ldd	r24, Y+4	; 0x04
    329c:	9d 81       	ldd	r25, Y+5	; 0x05
    329e:	9c 01       	movw	r18, r24
    32a0:	24 5f       	subi	r18, 0xF4	; 244
    32a2:	3f 4f       	sbci	r19, 0xFF	; 255
    32a4:	87 ea       	ldi	r24, 0xA7	; 167
    32a6:	94 e0       	ldi	r25, 0x04	; 4
    32a8:	b9 01       	movw	r22, r18
    32aa:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    32ae:	ec 81       	ldd	r30, Y+4	; 0x04
    32b0:	fd 81       	ldd	r31, Y+5	; 0x05
    32b2:	96 89       	ldd	r25, Z+22	; 0x16
    32b4:	e0 91 52 04 	lds	r30, 0x0452
    32b8:	f0 91 53 04 	lds	r31, 0x0453
    32bc:	86 89       	ldd	r24, Z+22	; 0x16
    32be:	89 17       	cp	r24, r25
    32c0:	58 f4       	brcc	.+22     	; 0x32d8 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    32c2:	8f 85       	ldd	r24, Y+15	; 0x0f
    32c4:	98 89       	ldd	r25, Y+16	; 0x10
    32c6:	00 97       	sbiw	r24, 0x00	; 0
    32c8:	21 f0       	breq	.+8      	; 0x32d2 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    32ca:	ef 85       	ldd	r30, Y+15	; 0x0f
    32cc:	f8 89       	ldd	r31, Y+16	; 0x10
    32ce:	81 e0       	ldi	r24, 0x01	; 1
    32d0:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    32d2:	81 e0       	ldi	r24, 0x01	; 1
    32d4:	80 93 5c 04 	sts	0x045C, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    32d8:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    32da:	62 96       	adiw	r28, 0x12	; 18
    32dc:	0f b6       	in	r0, 0x3f	; 63
    32de:	f8 94       	cli
    32e0:	de bf       	out	0x3e, r29	; 62
    32e2:	0f be       	out	0x3f, r0	; 63
    32e4:	cd bf       	out	0x3d, r28	; 61
    32e6:	cf 91       	pop	r28
    32e8:	df 91       	pop	r29
    32ea:	1f 91       	pop	r17
    32ec:	0f 91       	pop	r16
    32ee:	ff 90       	pop	r15
    32f0:	ef 90       	pop	r14
    32f2:	08 95       	ret

000032f4 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    32f4:	df 93       	push	r29
    32f6:	cf 93       	push	r28
    32f8:	cd b7       	in	r28, 0x3d	; 61
    32fa:	de b7       	in	r29, 0x3e	; 62
    32fc:	28 97       	sbiw	r28, 0x08	; 8
    32fe:	0f b6       	in	r0, 0x3f	; 63
    3300:	f8 94       	cli
    3302:	de bf       	out	0x3e, r29	; 62
    3304:	0f be       	out	0x3f, r0	; 63
    3306:	cd bf       	out	0x3d, r28	; 61
    3308:	9e 83       	std	Y+6, r25	; 0x06
    330a:	8d 83       	std	Y+5, r24	; 0x05
    330c:	78 87       	std	Y+8, r23	; 0x08
    330e:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3310:	8d 81       	ldd	r24, Y+5	; 0x05
    3312:	9e 81       	ldd	r25, Y+6	; 0x06
    3314:	9c 83       	std	Y+4, r25	; 0x04
    3316:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3318:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    331a:	eb 81       	ldd	r30, Y+3	; 0x03
    331c:	fc 81       	ldd	r31, Y+4	; 0x04
    331e:	85 a1       	ldd	r24, Z+37	; 0x25
    3320:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3322:	eb 81       	ldd	r30, Y+3	; 0x03
    3324:	fc 81       	ldd	r31, Y+4	; 0x04
    3326:	82 e0       	ldi	r24, 0x02	; 2
    3328:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    332a:	eb 81       	ldd	r30, Y+3	; 0x03
    332c:	fc 81       	ldd	r31, Y+4	; 0x04
    332e:	81 a1       	ldd	r24, Z+33	; 0x21
    3330:	92 a1       	ldd	r25, Z+34	; 0x22
    3332:	a3 a1       	ldd	r26, Z+35	; 0x23
    3334:	b4 a1       	ldd	r27, Z+36	; 0x24
    3336:	01 96       	adiw	r24, 0x01	; 1
    3338:	a1 1d       	adc	r26, r1
    333a:	b1 1d       	adc	r27, r1
    333c:	eb 81       	ldd	r30, Y+3	; 0x03
    333e:	fc 81       	ldd	r31, Y+4	; 0x04
    3340:	81 a3       	std	Z+33, r24	; 0x21
    3342:	92 a3       	std	Z+34, r25	; 0x22
    3344:	a3 a3       	std	Z+35, r26	; 0x23
    3346:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3348:	8a 81       	ldd	r24, Y+2	; 0x02
    334a:	81 30       	cpi	r24, 0x01	; 1
    334c:	09 f0       	breq	.+2      	; 0x3350 <vTaskNotifyGiveFromISR+0x5c>
    334e:	4f c0       	rjmp	.+158    	; 0x33ee <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3350:	80 91 63 04 	lds	r24, 0x0463
    3354:	88 23       	and	r24, r24
    3356:	61 f5       	brne	.+88     	; 0x33b0 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3358:	8b 81       	ldd	r24, Y+3	; 0x03
    335a:	9c 81       	ldd	r25, Y+4	; 0x04
    335c:	02 96       	adiw	r24, 0x02	; 2
    335e:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3362:	eb 81       	ldd	r30, Y+3	; 0x03
    3364:	fc 81       	ldd	r31, Y+4	; 0x04
    3366:	96 89       	ldd	r25, Z+22	; 0x16
    3368:	80 91 58 04 	lds	r24, 0x0458
    336c:	89 17       	cp	r24, r25
    336e:	28 f4       	brcc	.+10     	; 0x337a <vTaskNotifyGiveFromISR+0x86>
    3370:	eb 81       	ldd	r30, Y+3	; 0x03
    3372:	fc 81       	ldd	r31, Y+4	; 0x04
    3374:	86 89       	ldd	r24, Z+22	; 0x16
    3376:	80 93 58 04 	sts	0x0458, r24
    337a:	eb 81       	ldd	r30, Y+3	; 0x03
    337c:	fc 81       	ldd	r31, Y+4	; 0x04
    337e:	86 89       	ldd	r24, Z+22	; 0x16
    3380:	28 2f       	mov	r18, r24
    3382:	30 e0       	ldi	r19, 0x00	; 0
    3384:	c9 01       	movw	r24, r18
    3386:	88 0f       	add	r24, r24
    3388:	99 1f       	adc	r25, r25
    338a:	88 0f       	add	r24, r24
    338c:	99 1f       	adc	r25, r25
    338e:	88 0f       	add	r24, r24
    3390:	99 1f       	adc	r25, r25
    3392:	82 0f       	add	r24, r18
    3394:	93 1f       	adc	r25, r19
    3396:	ac 01       	movw	r20, r24
    3398:	4c 59       	subi	r20, 0x9C	; 156
    339a:	5b 4f       	sbci	r21, 0xFB	; 251
    339c:	8b 81       	ldd	r24, Y+3	; 0x03
    339e:	9c 81       	ldd	r25, Y+4	; 0x04
    33a0:	9c 01       	movw	r18, r24
    33a2:	2e 5f       	subi	r18, 0xFE	; 254
    33a4:	3f 4f       	sbci	r19, 0xFF	; 255
    33a6:	ca 01       	movw	r24, r20
    33a8:	b9 01       	movw	r22, r18
    33aa:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
    33ae:	0a c0       	rjmp	.+20     	; 0x33c4 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    33b0:	8b 81       	ldd	r24, Y+3	; 0x03
    33b2:	9c 81       	ldd	r25, Y+4	; 0x04
    33b4:	9c 01       	movw	r18, r24
    33b6:	24 5f       	subi	r18, 0xF4	; 244
    33b8:	3f 4f       	sbci	r19, 0xFF	; 255
    33ba:	87 ea       	ldi	r24, 0xA7	; 167
    33bc:	94 e0       	ldi	r25, 0x04	; 4
    33be:	b9 01       	movw	r22, r18
    33c0:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    33c4:	eb 81       	ldd	r30, Y+3	; 0x03
    33c6:	fc 81       	ldd	r31, Y+4	; 0x04
    33c8:	96 89       	ldd	r25, Z+22	; 0x16
    33ca:	e0 91 52 04 	lds	r30, 0x0452
    33ce:	f0 91 53 04 	lds	r31, 0x0453
    33d2:	86 89       	ldd	r24, Z+22	; 0x16
    33d4:	89 17       	cp	r24, r25
    33d6:	58 f4       	brcc	.+22     	; 0x33ee <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    33d8:	8f 81       	ldd	r24, Y+7	; 0x07
    33da:	98 85       	ldd	r25, Y+8	; 0x08
    33dc:	00 97       	sbiw	r24, 0x00	; 0
    33de:	21 f0       	breq	.+8      	; 0x33e8 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    33e0:	ef 81       	ldd	r30, Y+7	; 0x07
    33e2:	f8 85       	ldd	r31, Y+8	; 0x08
    33e4:	81 e0       	ldi	r24, 0x01	; 1
    33e6:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    33e8:	81 e0       	ldi	r24, 0x01	; 1
    33ea:	80 93 5c 04 	sts	0x045C, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    33ee:	28 96       	adiw	r28, 0x08	; 8
    33f0:	0f b6       	in	r0, 0x3f	; 63
    33f2:	f8 94       	cli
    33f4:	de bf       	out	0x3e, r29	; 62
    33f6:	0f be       	out	0x3f, r0	; 63
    33f8:	cd bf       	out	0x3d, r28	; 61
    33fa:	cf 91       	pop	r28
    33fc:	df 91       	pop	r29
    33fe:	08 95       	ret

00003400 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3400:	df 93       	push	r29
    3402:	cf 93       	push	r28
    3404:	cd b7       	in	r28, 0x3d	; 61
    3406:	de b7       	in	r29, 0x3e	; 62
    3408:	27 97       	sbiw	r28, 0x07	; 7
    340a:	0f b6       	in	r0, 0x3f	; 63
    340c:	f8 94       	cli
    340e:	de bf       	out	0x3e, r29	; 62
    3410:	0f be       	out	0x3f, r0	; 63
    3412:	cd bf       	out	0x3d, r28	; 61
    3414:	9d 83       	std	Y+5, r25	; 0x05
    3416:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3418:	8c 81       	ldd	r24, Y+4	; 0x04
    341a:	9d 81       	ldd	r25, Y+5	; 0x05
    341c:	00 97       	sbiw	r24, 0x00	; 0
    341e:	39 f4       	brne	.+14     	; 0x342e <xTaskNotifyStateClear+0x2e>
    3420:	80 91 52 04 	lds	r24, 0x0452
    3424:	90 91 53 04 	lds	r25, 0x0453
    3428:	9f 83       	std	Y+7, r25	; 0x07
    342a:	8e 83       	std	Y+6, r24	; 0x06
    342c:	04 c0       	rjmp	.+8      	; 0x3436 <xTaskNotifyStateClear+0x36>
    342e:	8c 81       	ldd	r24, Y+4	; 0x04
    3430:	9d 81       	ldd	r25, Y+5	; 0x05
    3432:	9f 83       	std	Y+7, r25	; 0x07
    3434:	8e 83       	std	Y+6, r24	; 0x06
    3436:	8e 81       	ldd	r24, Y+6	; 0x06
    3438:	9f 81       	ldd	r25, Y+7	; 0x07
    343a:	9b 83       	std	Y+3, r25	; 0x03
    343c:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    343e:	0f b6       	in	r0, 0x3f	; 63
    3440:	f8 94       	cli
    3442:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    3444:	ea 81       	ldd	r30, Y+2	; 0x02
    3446:	fb 81       	ldd	r31, Y+3	; 0x03
    3448:	85 a1       	ldd	r24, Z+37	; 0x25
    344a:	82 30       	cpi	r24, 0x02	; 2
    344c:	31 f4       	brne	.+12     	; 0x345a <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    344e:	ea 81       	ldd	r30, Y+2	; 0x02
    3450:	fb 81       	ldd	r31, Y+3	; 0x03
    3452:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    3454:	81 e0       	ldi	r24, 0x01	; 1
    3456:	89 83       	std	Y+1, r24	; 0x01
    3458:	01 c0       	rjmp	.+2      	; 0x345c <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    345a:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    345c:	0f 90       	pop	r0
    345e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3460:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3462:	27 96       	adiw	r28, 0x07	; 7
    3464:	0f b6       	in	r0, 0x3f	; 63
    3466:	f8 94       	cli
    3468:	de bf       	out	0x3e, r29	; 62
    346a:	0f be       	out	0x3f, r0	; 63
    346c:	cd bf       	out	0x3d, r28	; 61
    346e:	cf 91       	pop	r28
    3470:	df 91       	pop	r29
    3472:	08 95       	ret

00003474 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    3474:	df 93       	push	r29
    3476:	cf 93       	push	r28
    3478:	cd b7       	in	r28, 0x3d	; 61
    347a:	de b7       	in	r29, 0x3e	; 62
    347c:	2e 97       	sbiw	r28, 0x0e	; 14
    347e:	0f b6       	in	r0, 0x3f	; 63
    3480:	f8 94       	cli
    3482:	de bf       	out	0x3e, r29	; 62
    3484:	0f be       	out	0x3f, r0	; 63
    3486:	cd bf       	out	0x3d, r28	; 61
    3488:	98 87       	std	Y+8, r25	; 0x08
    348a:	8f 83       	std	Y+7, r24	; 0x07
    348c:	49 87       	std	Y+9, r20	; 0x09
    348e:	5a 87       	std	Y+10, r21	; 0x0a
    3490:	6b 87       	std	Y+11, r22	; 0x0b
    3492:	7c 87       	std	Y+12, r23	; 0x0c
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3494:	8f 81       	ldd	r24, Y+7	; 0x07
    3496:	98 85       	ldd	r25, Y+8	; 0x08
    3498:	00 97       	sbiw	r24, 0x00	; 0
    349a:	39 f4       	brne	.+14     	; 0x34aa <ulTaskNotifyValueClear+0x36>
    349c:	80 91 52 04 	lds	r24, 0x0452
    34a0:	90 91 53 04 	lds	r25, 0x0453
    34a4:	9e 87       	std	Y+14, r25	; 0x0e
    34a6:	8d 87       	std	Y+13, r24	; 0x0d
    34a8:	04 c0       	rjmp	.+8      	; 0x34b2 <ulTaskNotifyValueClear+0x3e>
    34aa:	8f 81       	ldd	r24, Y+7	; 0x07
    34ac:	98 85       	ldd	r25, Y+8	; 0x08
    34ae:	9e 87       	std	Y+14, r25	; 0x0e
    34b0:	8d 87       	std	Y+13, r24	; 0x0d
    34b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    34b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    34b6:	9e 83       	std	Y+6, r25	; 0x06
    34b8:	8d 83       	std	Y+5, r24	; 0x05

		taskENTER_CRITICAL();
    34ba:	0f b6       	in	r0, 0x3f	; 63
    34bc:	f8 94       	cli
    34be:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    34c0:	e0 91 52 04 	lds	r30, 0x0452
    34c4:	f0 91 53 04 	lds	r31, 0x0453
    34c8:	81 a1       	ldd	r24, Z+33	; 0x21
    34ca:	92 a1       	ldd	r25, Z+34	; 0x22
    34cc:	a3 a1       	ldd	r26, Z+35	; 0x23
    34ce:	b4 a1       	ldd	r27, Z+36	; 0x24
    34d0:	89 83       	std	Y+1, r24	; 0x01
    34d2:	9a 83       	std	Y+2, r25	; 0x02
    34d4:	ab 83       	std	Y+3, r26	; 0x03
    34d6:	bc 83       	std	Y+4, r27	; 0x04
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    34d8:	ed 81       	ldd	r30, Y+5	; 0x05
    34da:	fe 81       	ldd	r31, Y+6	; 0x06
    34dc:	21 a1       	ldd	r18, Z+33	; 0x21
    34de:	32 a1       	ldd	r19, Z+34	; 0x22
    34e0:	43 a1       	ldd	r20, Z+35	; 0x23
    34e2:	54 a1       	ldd	r21, Z+36	; 0x24
    34e4:	89 85       	ldd	r24, Y+9	; 0x09
    34e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    34e8:	ab 85       	ldd	r26, Y+11	; 0x0b
    34ea:	bc 85       	ldd	r27, Y+12	; 0x0c
    34ec:	80 95       	com	r24
    34ee:	90 95       	com	r25
    34f0:	a0 95       	com	r26
    34f2:	b0 95       	com	r27
    34f4:	82 23       	and	r24, r18
    34f6:	93 23       	and	r25, r19
    34f8:	a4 23       	and	r26, r20
    34fa:	b5 23       	and	r27, r21
    34fc:	ed 81       	ldd	r30, Y+5	; 0x05
    34fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3500:	81 a3       	std	Z+33, r24	; 0x21
    3502:	92 a3       	std	Z+34, r25	; 0x22
    3504:	a3 a3       	std	Z+35, r26	; 0x23
    3506:	b4 a3       	std	Z+36, r27	; 0x24
		}
		taskEXIT_CRITICAL();
    3508:	0f 90       	pop	r0
    350a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    350c:	89 81       	ldd	r24, Y+1	; 0x01
    350e:	9a 81       	ldd	r25, Y+2	; 0x02
    3510:	ab 81       	ldd	r26, Y+3	; 0x03
    3512:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3514:	bc 01       	movw	r22, r24
    3516:	cd 01       	movw	r24, r26
    3518:	2e 96       	adiw	r28, 0x0e	; 14
    351a:	0f b6       	in	r0, 0x3f	; 63
    351c:	f8 94       	cli
    351e:	de bf       	out	0x3e, r29	; 62
    3520:	0f be       	out	0x3f, r0	; 63
    3522:	cd bf       	out	0x3d, r28	; 61
    3524:	cf 91       	pop	r28
    3526:	df 91       	pop	r29
    3528:	08 95       	ret

0000352a <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    352a:	df 93       	push	r29
    352c:	cf 93       	push	r28
    352e:	cd b7       	in	r28, 0x3d	; 61
    3530:	de b7       	in	r29, 0x3e	; 62
    3532:	27 97       	sbiw	r28, 0x07	; 7
    3534:	0f b6       	in	r0, 0x3f	; 63
    3536:	f8 94       	cli
    3538:	de bf       	out	0x3e, r29	; 62
    353a:	0f be       	out	0x3f, r0	; 63
    353c:	cd bf       	out	0x3d, r28	; 61
    353e:	9e 83       	std	Y+6, r25	; 0x06
    3540:	8d 83       	std	Y+5, r24	; 0x05
    3542:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3544:	80 91 56 04 	lds	r24, 0x0456
    3548:	90 91 57 04 	lds	r25, 0x0457
    354c:	9a 83       	std	Y+2, r25	; 0x02
    354e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3550:	80 91 52 04 	lds	r24, 0x0452
    3554:	90 91 53 04 	lds	r25, 0x0453
    3558:	02 96       	adiw	r24, 0x02	; 2
    355a:	0e 94 af 01 	call	0x35e	; 0x35e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    355e:	8d 81       	ldd	r24, Y+5	; 0x05
    3560:	9e 81       	ldd	r25, Y+6	; 0x06
    3562:	2f ef       	ldi	r18, 0xFF	; 255
    3564:	8f 3f       	cpi	r24, 0xFF	; 255
    3566:	92 07       	cpc	r25, r18
    3568:	81 f4       	brne	.+32     	; 0x358a <prvAddCurrentTaskToDelayedList+0x60>
    356a:	8f 81       	ldd	r24, Y+7	; 0x07
    356c:	88 23       	and	r24, r24
    356e:	69 f0       	breq	.+26     	; 0x358a <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3570:	80 91 52 04 	lds	r24, 0x0452
    3574:	90 91 53 04 	lds	r25, 0x0453
    3578:	9c 01       	movw	r18, r24
    357a:	2e 5f       	subi	r18, 0xFE	; 254
    357c:	3f 4f       	sbci	r19, 0xFF	; 255
    357e:	89 eb       	ldi	r24, 0xB9	; 185
    3580:	94 e0       	ldi	r25, 0x04	; 4
    3582:	b9 01       	movw	r22, r18
    3584:	0e 94 ff 00 	call	0x1fe	; 0x1fe <vListInsertEnd>
    3588:	43 c0       	rjmp	.+134    	; 0x3610 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    358a:	29 81       	ldd	r18, Y+1	; 0x01
    358c:	3a 81       	ldd	r19, Y+2	; 0x02
    358e:	8d 81       	ldd	r24, Y+5	; 0x05
    3590:	9e 81       	ldd	r25, Y+6	; 0x06
    3592:	82 0f       	add	r24, r18
    3594:	93 1f       	adc	r25, r19
    3596:	9c 83       	std	Y+4, r25	; 0x04
    3598:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    359a:	e0 91 52 04 	lds	r30, 0x0452
    359e:	f0 91 53 04 	lds	r31, 0x0453
    35a2:	8b 81       	ldd	r24, Y+3	; 0x03
    35a4:	9c 81       	ldd	r25, Y+4	; 0x04
    35a6:	93 83       	std	Z+3, r25	; 0x03
    35a8:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    35aa:	2b 81       	ldd	r18, Y+3	; 0x03
    35ac:	3c 81       	ldd	r19, Y+4	; 0x04
    35ae:	89 81       	ldd	r24, Y+1	; 0x01
    35b0:	9a 81       	ldd	r25, Y+2	; 0x02
    35b2:	28 17       	cp	r18, r24
    35b4:	39 07       	cpc	r19, r25
    35b6:	70 f4       	brcc	.+28     	; 0x35d4 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    35b8:	80 91 a5 04 	lds	r24, 0x04A5
    35bc:	90 91 a6 04 	lds	r25, 0x04A6
    35c0:	20 91 52 04 	lds	r18, 0x0452
    35c4:	30 91 53 04 	lds	r19, 0x0453
    35c8:	2e 5f       	subi	r18, 0xFE	; 254
    35ca:	3f 4f       	sbci	r19, 0xFF	; 255
    35cc:	b9 01       	movw	r22, r18
    35ce:	0e 94 43 01 	call	0x286	; 0x286 <vListInsert>
    35d2:	1e c0       	rjmp	.+60     	; 0x3610 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    35d4:	40 91 a3 04 	lds	r20, 0x04A3
    35d8:	50 91 a4 04 	lds	r21, 0x04A4
    35dc:	80 91 52 04 	lds	r24, 0x0452
    35e0:	90 91 53 04 	lds	r25, 0x0453
    35e4:	9c 01       	movw	r18, r24
    35e6:	2e 5f       	subi	r18, 0xFE	; 254
    35e8:	3f 4f       	sbci	r19, 0xFF	; 255
    35ea:	ca 01       	movw	r24, r20
    35ec:	b9 01       	movw	r22, r18
    35ee:	0e 94 43 01 	call	0x286	; 0x286 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    35f2:	20 91 5f 04 	lds	r18, 0x045F
    35f6:	30 91 60 04 	lds	r19, 0x0460
    35fa:	8b 81       	ldd	r24, Y+3	; 0x03
    35fc:	9c 81       	ldd	r25, Y+4	; 0x04
    35fe:	82 17       	cp	r24, r18
    3600:	93 07       	cpc	r25, r19
    3602:	30 f4       	brcc	.+12     	; 0x3610 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    3604:	8b 81       	ldd	r24, Y+3	; 0x03
    3606:	9c 81       	ldd	r25, Y+4	; 0x04
    3608:	90 93 60 04 	sts	0x0460, r25
    360c:	80 93 5f 04 	sts	0x045F, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3610:	27 96       	adiw	r28, 0x07	; 7
    3612:	0f b6       	in	r0, 0x3f	; 63
    3614:	f8 94       	cli
    3616:	de bf       	out	0x3e, r29	; 62
    3618:	0f be       	out	0x3f, r0	; 63
    361a:	cd bf       	out	0x3d, r28	; 61
    361c:	cf 91       	pop	r28
    361e:	df 91       	pop	r29
    3620:	08 95       	ret

00003622 <GPIO_voidSetPinValue>:

#include "GPIO_Interface.h"
#include "GPIO_Private.h"

void GPIO_voidSetPinValue(u8 port_id , u8 pin , u8 value)
{
    3622:	df 93       	push	r29
    3624:	cf 93       	push	r28
    3626:	cd b7       	in	r28, 0x3d	; 61
    3628:	de b7       	in	r29, 0x3e	; 62
    362a:	27 97       	sbiw	r28, 0x07	; 7
    362c:	0f b6       	in	r0, 0x3f	; 63
    362e:	f8 94       	cli
    3630:	de bf       	out	0x3e, r29	; 62
    3632:	0f be       	out	0x3f, r0	; 63
    3634:	cd bf       	out	0x3d, r28	; 61
    3636:	89 83       	std	Y+1, r24	; 0x01
    3638:	6a 83       	std	Y+2, r22	; 0x02
    363a:	4b 83       	std	Y+3, r20	; 0x03
	if (value == HIGH)
    363c:	8b 81       	ldd	r24, Y+3	; 0x03
    363e:	81 30       	cpi	r24, 0x01	; 1
    3640:	09 f0       	breq	.+2      	; 0x3644 <GPIO_voidSetPinValue+0x22>
    3642:	6f c0       	rjmp	.+222    	; 0x3722 <GPIO_voidSetPinValue+0x100>
	{
		switch (port_id)
    3644:	89 81       	ldd	r24, Y+1	; 0x01
    3646:	28 2f       	mov	r18, r24
    3648:	30 e0       	ldi	r19, 0x00	; 0
    364a:	3f 83       	std	Y+7, r19	; 0x07
    364c:	2e 83       	std	Y+6, r18	; 0x06
    364e:	8e 81       	ldd	r24, Y+6	; 0x06
    3650:	9f 81       	ldd	r25, Y+7	; 0x07
    3652:	81 30       	cpi	r24, 0x01	; 1
    3654:	91 05       	cpc	r25, r1
    3656:	49 f1       	breq	.+82     	; 0x36aa <GPIO_voidSetPinValue+0x88>
    3658:	2e 81       	ldd	r18, Y+6	; 0x06
    365a:	3f 81       	ldd	r19, Y+7	; 0x07
    365c:	22 30       	cpi	r18, 0x02	; 2
    365e:	31 05       	cpc	r19, r1
    3660:	2c f4       	brge	.+10     	; 0x366c <GPIO_voidSetPinValue+0x4a>
    3662:	8e 81       	ldd	r24, Y+6	; 0x06
    3664:	9f 81       	ldd	r25, Y+7	; 0x07
    3666:	00 97       	sbiw	r24, 0x00	; 0
    3668:	61 f0       	breq	.+24     	; 0x3682 <GPIO_voidSetPinValue+0x60>
    366a:	d2 c0       	rjmp	.+420    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
    366c:	2e 81       	ldd	r18, Y+6	; 0x06
    366e:	3f 81       	ldd	r19, Y+7	; 0x07
    3670:	22 30       	cpi	r18, 0x02	; 2
    3672:	31 05       	cpc	r19, r1
    3674:	71 f1       	breq	.+92     	; 0x36d2 <GPIO_voidSetPinValue+0xb0>
    3676:	8e 81       	ldd	r24, Y+6	; 0x06
    3678:	9f 81       	ldd	r25, Y+7	; 0x07
    367a:	83 30       	cpi	r24, 0x03	; 3
    367c:	91 05       	cpc	r25, r1
    367e:	e9 f1       	breq	.+122    	; 0x36fa <GPIO_voidSetPinValue+0xd8>
    3680:	c7 c0       	rjmp	.+398    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
		{
			case PORT_A :
			SET_BIT (GPIO_PORTA , pin);
    3682:	ab e3       	ldi	r26, 0x3B	; 59
    3684:	b0 e0       	ldi	r27, 0x00	; 0
    3686:	eb e3       	ldi	r30, 0x3B	; 59
    3688:	f0 e0       	ldi	r31, 0x00	; 0
    368a:	80 81       	ld	r24, Z
    368c:	48 2f       	mov	r20, r24
    368e:	8a 81       	ldd	r24, Y+2	; 0x02
    3690:	28 2f       	mov	r18, r24
    3692:	30 e0       	ldi	r19, 0x00	; 0
    3694:	81 e0       	ldi	r24, 0x01	; 1
    3696:	90 e0       	ldi	r25, 0x00	; 0
    3698:	02 2e       	mov	r0, r18
    369a:	02 c0       	rjmp	.+4      	; 0x36a0 <GPIO_voidSetPinValue+0x7e>
    369c:	88 0f       	add	r24, r24
    369e:	99 1f       	adc	r25, r25
    36a0:	0a 94       	dec	r0
    36a2:	e2 f7       	brpl	.-8      	; 0x369c <GPIO_voidSetPinValue+0x7a>
    36a4:	84 2b       	or	r24, r20
    36a6:	8c 93       	st	X, r24
    36a8:	b3 c0       	rjmp	.+358    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_B :
			SET_BIT (GPIO_PORTB , pin);
    36aa:	a8 e3       	ldi	r26, 0x38	; 56
    36ac:	b0 e0       	ldi	r27, 0x00	; 0
    36ae:	e8 e3       	ldi	r30, 0x38	; 56
    36b0:	f0 e0       	ldi	r31, 0x00	; 0
    36b2:	80 81       	ld	r24, Z
    36b4:	48 2f       	mov	r20, r24
    36b6:	8a 81       	ldd	r24, Y+2	; 0x02
    36b8:	28 2f       	mov	r18, r24
    36ba:	30 e0       	ldi	r19, 0x00	; 0
    36bc:	81 e0       	ldi	r24, 0x01	; 1
    36be:	90 e0       	ldi	r25, 0x00	; 0
    36c0:	02 2e       	mov	r0, r18
    36c2:	02 c0       	rjmp	.+4      	; 0x36c8 <GPIO_voidSetPinValue+0xa6>
    36c4:	88 0f       	add	r24, r24
    36c6:	99 1f       	adc	r25, r25
    36c8:	0a 94       	dec	r0
    36ca:	e2 f7       	brpl	.-8      	; 0x36c4 <GPIO_voidSetPinValue+0xa2>
    36cc:	84 2b       	or	r24, r20
    36ce:	8c 93       	st	X, r24
    36d0:	9f c0       	rjmp	.+318    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_C :
			SET_BIT (GPIO_PORTC , pin);
    36d2:	a5 e3       	ldi	r26, 0x35	; 53
    36d4:	b0 e0       	ldi	r27, 0x00	; 0
    36d6:	e5 e3       	ldi	r30, 0x35	; 53
    36d8:	f0 e0       	ldi	r31, 0x00	; 0
    36da:	80 81       	ld	r24, Z
    36dc:	48 2f       	mov	r20, r24
    36de:	8a 81       	ldd	r24, Y+2	; 0x02
    36e0:	28 2f       	mov	r18, r24
    36e2:	30 e0       	ldi	r19, 0x00	; 0
    36e4:	81 e0       	ldi	r24, 0x01	; 1
    36e6:	90 e0       	ldi	r25, 0x00	; 0
    36e8:	02 2e       	mov	r0, r18
    36ea:	02 c0       	rjmp	.+4      	; 0x36f0 <GPIO_voidSetPinValue+0xce>
    36ec:	88 0f       	add	r24, r24
    36ee:	99 1f       	adc	r25, r25
    36f0:	0a 94       	dec	r0
    36f2:	e2 f7       	brpl	.-8      	; 0x36ec <GPIO_voidSetPinValue+0xca>
    36f4:	84 2b       	or	r24, r20
    36f6:	8c 93       	st	X, r24
    36f8:	8b c0       	rjmp	.+278    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_D :
			SET_BIT (GPIO_PORTD , pin);
    36fa:	a2 e3       	ldi	r26, 0x32	; 50
    36fc:	b0 e0       	ldi	r27, 0x00	; 0
    36fe:	e2 e3       	ldi	r30, 0x32	; 50
    3700:	f0 e0       	ldi	r31, 0x00	; 0
    3702:	80 81       	ld	r24, Z
    3704:	48 2f       	mov	r20, r24
    3706:	8a 81       	ldd	r24, Y+2	; 0x02
    3708:	28 2f       	mov	r18, r24
    370a:	30 e0       	ldi	r19, 0x00	; 0
    370c:	81 e0       	ldi	r24, 0x01	; 1
    370e:	90 e0       	ldi	r25, 0x00	; 0
    3710:	02 2e       	mov	r0, r18
    3712:	02 c0       	rjmp	.+4      	; 0x3718 <GPIO_voidSetPinValue+0xf6>
    3714:	88 0f       	add	r24, r24
    3716:	99 1f       	adc	r25, r25
    3718:	0a 94       	dec	r0
    371a:	e2 f7       	brpl	.-8      	; 0x3714 <GPIO_voidSetPinValue+0xf2>
    371c:	84 2b       	or	r24, r20
    371e:	8c 93       	st	X, r24
    3720:	77 c0       	rjmp	.+238    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>

			default:
			break;
		}
	}
	else if (value == LOW)
    3722:	8b 81       	ldd	r24, Y+3	; 0x03
    3724:	88 23       	and	r24, r24
    3726:	09 f0       	breq	.+2      	; 0x372a <GPIO_voidSetPinValue+0x108>
    3728:	73 c0       	rjmp	.+230    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
	{
		switch (port_id)
    372a:	89 81       	ldd	r24, Y+1	; 0x01
    372c:	28 2f       	mov	r18, r24
    372e:	30 e0       	ldi	r19, 0x00	; 0
    3730:	3d 83       	std	Y+5, r19	; 0x05
    3732:	2c 83       	std	Y+4, r18	; 0x04
    3734:	8c 81       	ldd	r24, Y+4	; 0x04
    3736:	9d 81       	ldd	r25, Y+5	; 0x05
    3738:	81 30       	cpi	r24, 0x01	; 1
    373a:	91 05       	cpc	r25, r1
    373c:	59 f1       	breq	.+86     	; 0x3794 <GPIO_voidSetPinValue+0x172>
    373e:	2c 81       	ldd	r18, Y+4	; 0x04
    3740:	3d 81       	ldd	r19, Y+5	; 0x05
    3742:	22 30       	cpi	r18, 0x02	; 2
    3744:	31 05       	cpc	r19, r1
    3746:	2c f4       	brge	.+10     	; 0x3752 <GPIO_voidSetPinValue+0x130>
    3748:	8c 81       	ldd	r24, Y+4	; 0x04
    374a:	9d 81       	ldd	r25, Y+5	; 0x05
    374c:	00 97       	sbiw	r24, 0x00	; 0
    374e:	69 f0       	breq	.+26     	; 0x376a <GPIO_voidSetPinValue+0x148>
    3750:	5f c0       	rjmp	.+190    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
    3752:	2c 81       	ldd	r18, Y+4	; 0x04
    3754:	3d 81       	ldd	r19, Y+5	; 0x05
    3756:	22 30       	cpi	r18, 0x02	; 2
    3758:	31 05       	cpc	r19, r1
    375a:	89 f1       	breq	.+98     	; 0x37be <GPIO_voidSetPinValue+0x19c>
    375c:	8c 81       	ldd	r24, Y+4	; 0x04
    375e:	9d 81       	ldd	r25, Y+5	; 0x05
    3760:	83 30       	cpi	r24, 0x03	; 3
    3762:	91 05       	cpc	r25, r1
    3764:	09 f4       	brne	.+2      	; 0x3768 <GPIO_voidSetPinValue+0x146>
    3766:	40 c0       	rjmp	.+128    	; 0x37e8 <GPIO_voidSetPinValue+0x1c6>
    3768:	53 c0       	rjmp	.+166    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
		{
			case PORT_A :
			CLR_BIT (GPIO_PORTA , pin);
    376a:	ab e3       	ldi	r26, 0x3B	; 59
    376c:	b0 e0       	ldi	r27, 0x00	; 0
    376e:	eb e3       	ldi	r30, 0x3B	; 59
    3770:	f0 e0       	ldi	r31, 0x00	; 0
    3772:	80 81       	ld	r24, Z
    3774:	48 2f       	mov	r20, r24
    3776:	8a 81       	ldd	r24, Y+2	; 0x02
    3778:	28 2f       	mov	r18, r24
    377a:	30 e0       	ldi	r19, 0x00	; 0
    377c:	81 e0       	ldi	r24, 0x01	; 1
    377e:	90 e0       	ldi	r25, 0x00	; 0
    3780:	02 2e       	mov	r0, r18
    3782:	02 c0       	rjmp	.+4      	; 0x3788 <GPIO_voidSetPinValue+0x166>
    3784:	88 0f       	add	r24, r24
    3786:	99 1f       	adc	r25, r25
    3788:	0a 94       	dec	r0
    378a:	e2 f7       	brpl	.-8      	; 0x3784 <GPIO_voidSetPinValue+0x162>
    378c:	80 95       	com	r24
    378e:	84 23       	and	r24, r20
    3790:	8c 93       	st	X, r24
    3792:	3e c0       	rjmp	.+124    	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_B :
			CLR_BIT (GPIO_PORTB , pin);
    3794:	a8 e3       	ldi	r26, 0x38	; 56
    3796:	b0 e0       	ldi	r27, 0x00	; 0
    3798:	e8 e3       	ldi	r30, 0x38	; 56
    379a:	f0 e0       	ldi	r31, 0x00	; 0
    379c:	80 81       	ld	r24, Z
    379e:	48 2f       	mov	r20, r24
    37a0:	8a 81       	ldd	r24, Y+2	; 0x02
    37a2:	28 2f       	mov	r18, r24
    37a4:	30 e0       	ldi	r19, 0x00	; 0
    37a6:	81 e0       	ldi	r24, 0x01	; 1
    37a8:	90 e0       	ldi	r25, 0x00	; 0
    37aa:	02 2e       	mov	r0, r18
    37ac:	02 c0       	rjmp	.+4      	; 0x37b2 <GPIO_voidSetPinValue+0x190>
    37ae:	88 0f       	add	r24, r24
    37b0:	99 1f       	adc	r25, r25
    37b2:	0a 94       	dec	r0
    37b4:	e2 f7       	brpl	.-8      	; 0x37ae <GPIO_voidSetPinValue+0x18c>
    37b6:	80 95       	com	r24
    37b8:	84 23       	and	r24, r20
    37ba:	8c 93       	st	X, r24
    37bc:	29 c0       	rjmp	.+82     	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_C :
			CLR_BIT (GPIO_PORTC , pin);
    37be:	a5 e3       	ldi	r26, 0x35	; 53
    37c0:	b0 e0       	ldi	r27, 0x00	; 0
    37c2:	e5 e3       	ldi	r30, 0x35	; 53
    37c4:	f0 e0       	ldi	r31, 0x00	; 0
    37c6:	80 81       	ld	r24, Z
    37c8:	48 2f       	mov	r20, r24
    37ca:	8a 81       	ldd	r24, Y+2	; 0x02
    37cc:	28 2f       	mov	r18, r24
    37ce:	30 e0       	ldi	r19, 0x00	; 0
    37d0:	81 e0       	ldi	r24, 0x01	; 1
    37d2:	90 e0       	ldi	r25, 0x00	; 0
    37d4:	02 2e       	mov	r0, r18
    37d6:	02 c0       	rjmp	.+4      	; 0x37dc <GPIO_voidSetPinValue+0x1ba>
    37d8:	88 0f       	add	r24, r24
    37da:	99 1f       	adc	r25, r25
    37dc:	0a 94       	dec	r0
    37de:	e2 f7       	brpl	.-8      	; 0x37d8 <GPIO_voidSetPinValue+0x1b6>
    37e0:	80 95       	com	r24
    37e2:	84 23       	and	r24, r20
    37e4:	8c 93       	st	X, r24
    37e6:	14 c0       	rjmp	.+40     	; 0x3810 <GPIO_voidSetPinValue+0x1ee>
			break;

			case PORT_D :
			CLR_BIT (GPIO_PORTD , pin);
    37e8:	a2 e3       	ldi	r26, 0x32	; 50
    37ea:	b0 e0       	ldi	r27, 0x00	; 0
    37ec:	e2 e3       	ldi	r30, 0x32	; 50
    37ee:	f0 e0       	ldi	r31, 0x00	; 0
    37f0:	80 81       	ld	r24, Z
    37f2:	48 2f       	mov	r20, r24
    37f4:	8a 81       	ldd	r24, Y+2	; 0x02
    37f6:	28 2f       	mov	r18, r24
    37f8:	30 e0       	ldi	r19, 0x00	; 0
    37fa:	81 e0       	ldi	r24, 0x01	; 1
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	02 2e       	mov	r0, r18
    3800:	02 c0       	rjmp	.+4      	; 0x3806 <GPIO_voidSetPinValue+0x1e4>
    3802:	88 0f       	add	r24, r24
    3804:	99 1f       	adc	r25, r25
    3806:	0a 94       	dec	r0
    3808:	e2 f7       	brpl	.-8      	; 0x3802 <GPIO_voidSetPinValue+0x1e0>
    380a:	80 95       	com	r24
    380c:	84 23       	and	r24, r20
    380e:	8c 93       	st	X, r24
	{
		/* Should not be here */
	}


}
    3810:	27 96       	adiw	r28, 0x07	; 7
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	f8 94       	cli
    3816:	de bf       	out	0x3e, r29	; 62
    3818:	0f be       	out	0x3f, r0	; 63
    381a:	cd bf       	out	0x3d, r28	; 61
    381c:	cf 91       	pop	r28
    381e:	df 91       	pop	r29
    3820:	08 95       	ret

00003822 <GPIO_voidSetPinDirection>:

void GPIO_voidSetPinDirection(u8 port_id , u8 pin , u8 dirc )
{
    3822:	df 93       	push	r29
    3824:	cf 93       	push	r28
    3826:	cd b7       	in	r28, 0x3d	; 61
    3828:	de b7       	in	r29, 0x3e	; 62
    382a:	27 97       	sbiw	r28, 0x07	; 7
    382c:	0f b6       	in	r0, 0x3f	; 63
    382e:	f8 94       	cli
    3830:	de bf       	out	0x3e, r29	; 62
    3832:	0f be       	out	0x3f, r0	; 63
    3834:	cd bf       	out	0x3d, r28	; 61
    3836:	89 83       	std	Y+1, r24	; 0x01
    3838:	6a 83       	std	Y+2, r22	; 0x02
    383a:	4b 83       	std	Y+3, r20	; 0x03
	if (dirc == OUTPUT)
    383c:	8b 81       	ldd	r24, Y+3	; 0x03
    383e:	81 30       	cpi	r24, 0x01	; 1
    3840:	09 f0       	breq	.+2      	; 0x3844 <GPIO_voidSetPinDirection+0x22>
    3842:	6f c0       	rjmp	.+222    	; 0x3922 <GPIO_voidSetPinDirection+0x100>
	{
		switch (port_id)
    3844:	89 81       	ldd	r24, Y+1	; 0x01
    3846:	28 2f       	mov	r18, r24
    3848:	30 e0       	ldi	r19, 0x00	; 0
    384a:	3f 83       	std	Y+7, r19	; 0x07
    384c:	2e 83       	std	Y+6, r18	; 0x06
    384e:	8e 81       	ldd	r24, Y+6	; 0x06
    3850:	9f 81       	ldd	r25, Y+7	; 0x07
    3852:	81 30       	cpi	r24, 0x01	; 1
    3854:	91 05       	cpc	r25, r1
    3856:	49 f1       	breq	.+82     	; 0x38aa <GPIO_voidSetPinDirection+0x88>
    3858:	2e 81       	ldd	r18, Y+6	; 0x06
    385a:	3f 81       	ldd	r19, Y+7	; 0x07
    385c:	22 30       	cpi	r18, 0x02	; 2
    385e:	31 05       	cpc	r19, r1
    3860:	2c f4       	brge	.+10     	; 0x386c <GPIO_voidSetPinDirection+0x4a>
    3862:	8e 81       	ldd	r24, Y+6	; 0x06
    3864:	9f 81       	ldd	r25, Y+7	; 0x07
    3866:	00 97       	sbiw	r24, 0x00	; 0
    3868:	61 f0       	breq	.+24     	; 0x3882 <GPIO_voidSetPinDirection+0x60>
    386a:	d2 c0       	rjmp	.+420    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
    386c:	2e 81       	ldd	r18, Y+6	; 0x06
    386e:	3f 81       	ldd	r19, Y+7	; 0x07
    3870:	22 30       	cpi	r18, 0x02	; 2
    3872:	31 05       	cpc	r19, r1
    3874:	71 f1       	breq	.+92     	; 0x38d2 <GPIO_voidSetPinDirection+0xb0>
    3876:	8e 81       	ldd	r24, Y+6	; 0x06
    3878:	9f 81       	ldd	r25, Y+7	; 0x07
    387a:	83 30       	cpi	r24, 0x03	; 3
    387c:	91 05       	cpc	r25, r1
    387e:	e9 f1       	breq	.+122    	; 0x38fa <GPIO_voidSetPinDirection+0xd8>
    3880:	c7 c0       	rjmp	.+398    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
		{
			case PORT_A :
			SET_BIT (GPIO_DDRA , pin);
    3882:	aa e3       	ldi	r26, 0x3A	; 58
    3884:	b0 e0       	ldi	r27, 0x00	; 0
    3886:	ea e3       	ldi	r30, 0x3A	; 58
    3888:	f0 e0       	ldi	r31, 0x00	; 0
    388a:	80 81       	ld	r24, Z
    388c:	48 2f       	mov	r20, r24
    388e:	8a 81       	ldd	r24, Y+2	; 0x02
    3890:	28 2f       	mov	r18, r24
    3892:	30 e0       	ldi	r19, 0x00	; 0
    3894:	81 e0       	ldi	r24, 0x01	; 1
    3896:	90 e0       	ldi	r25, 0x00	; 0
    3898:	02 2e       	mov	r0, r18
    389a:	02 c0       	rjmp	.+4      	; 0x38a0 <GPIO_voidSetPinDirection+0x7e>
    389c:	88 0f       	add	r24, r24
    389e:	99 1f       	adc	r25, r25
    38a0:	0a 94       	dec	r0
    38a2:	e2 f7       	brpl	.-8      	; 0x389c <GPIO_voidSetPinDirection+0x7a>
    38a4:	84 2b       	or	r24, r20
    38a6:	8c 93       	st	X, r24
    38a8:	b3 c0       	rjmp	.+358    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_B :
			SET_BIT (GPIO_DDRB , pin);
    38aa:	a7 e3       	ldi	r26, 0x37	; 55
    38ac:	b0 e0       	ldi	r27, 0x00	; 0
    38ae:	e7 e3       	ldi	r30, 0x37	; 55
    38b0:	f0 e0       	ldi	r31, 0x00	; 0
    38b2:	80 81       	ld	r24, Z
    38b4:	48 2f       	mov	r20, r24
    38b6:	8a 81       	ldd	r24, Y+2	; 0x02
    38b8:	28 2f       	mov	r18, r24
    38ba:	30 e0       	ldi	r19, 0x00	; 0
    38bc:	81 e0       	ldi	r24, 0x01	; 1
    38be:	90 e0       	ldi	r25, 0x00	; 0
    38c0:	02 2e       	mov	r0, r18
    38c2:	02 c0       	rjmp	.+4      	; 0x38c8 <GPIO_voidSetPinDirection+0xa6>
    38c4:	88 0f       	add	r24, r24
    38c6:	99 1f       	adc	r25, r25
    38c8:	0a 94       	dec	r0
    38ca:	e2 f7       	brpl	.-8      	; 0x38c4 <GPIO_voidSetPinDirection+0xa2>
    38cc:	84 2b       	or	r24, r20
    38ce:	8c 93       	st	X, r24
    38d0:	9f c0       	rjmp	.+318    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_C :
			SET_BIT (GPIO_DDRC , pin);
    38d2:	a4 e3       	ldi	r26, 0x34	; 52
    38d4:	b0 e0       	ldi	r27, 0x00	; 0
    38d6:	e4 e3       	ldi	r30, 0x34	; 52
    38d8:	f0 e0       	ldi	r31, 0x00	; 0
    38da:	80 81       	ld	r24, Z
    38dc:	48 2f       	mov	r20, r24
    38de:	8a 81       	ldd	r24, Y+2	; 0x02
    38e0:	28 2f       	mov	r18, r24
    38e2:	30 e0       	ldi	r19, 0x00	; 0
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	90 e0       	ldi	r25, 0x00	; 0
    38e8:	02 2e       	mov	r0, r18
    38ea:	02 c0       	rjmp	.+4      	; 0x38f0 <GPIO_voidSetPinDirection+0xce>
    38ec:	88 0f       	add	r24, r24
    38ee:	99 1f       	adc	r25, r25
    38f0:	0a 94       	dec	r0
    38f2:	e2 f7       	brpl	.-8      	; 0x38ec <GPIO_voidSetPinDirection+0xca>
    38f4:	84 2b       	or	r24, r20
    38f6:	8c 93       	st	X, r24
    38f8:	8b c0       	rjmp	.+278    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_D :
			SET_BIT (GPIO_DDRD , pin);
    38fa:	a1 e3       	ldi	r26, 0x31	; 49
    38fc:	b0 e0       	ldi	r27, 0x00	; 0
    38fe:	e1 e3       	ldi	r30, 0x31	; 49
    3900:	f0 e0       	ldi	r31, 0x00	; 0
    3902:	80 81       	ld	r24, Z
    3904:	48 2f       	mov	r20, r24
    3906:	8a 81       	ldd	r24, Y+2	; 0x02
    3908:	28 2f       	mov	r18, r24
    390a:	30 e0       	ldi	r19, 0x00	; 0
    390c:	81 e0       	ldi	r24, 0x01	; 1
    390e:	90 e0       	ldi	r25, 0x00	; 0
    3910:	02 2e       	mov	r0, r18
    3912:	02 c0       	rjmp	.+4      	; 0x3918 <GPIO_voidSetPinDirection+0xf6>
    3914:	88 0f       	add	r24, r24
    3916:	99 1f       	adc	r25, r25
    3918:	0a 94       	dec	r0
    391a:	e2 f7       	brpl	.-8      	; 0x3914 <GPIO_voidSetPinDirection+0xf2>
    391c:	84 2b       	or	r24, r20
    391e:	8c 93       	st	X, r24
    3920:	77 c0       	rjmp	.+238    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>

			default:
			break;
		}
	}
	else if (dirc == INPUT)
    3922:	8b 81       	ldd	r24, Y+3	; 0x03
    3924:	88 23       	and	r24, r24
    3926:	09 f0       	breq	.+2      	; 0x392a <GPIO_voidSetPinDirection+0x108>
    3928:	73 c0       	rjmp	.+230    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
	{
		switch (port_id)
    392a:	89 81       	ldd	r24, Y+1	; 0x01
    392c:	28 2f       	mov	r18, r24
    392e:	30 e0       	ldi	r19, 0x00	; 0
    3930:	3d 83       	std	Y+5, r19	; 0x05
    3932:	2c 83       	std	Y+4, r18	; 0x04
    3934:	8c 81       	ldd	r24, Y+4	; 0x04
    3936:	9d 81       	ldd	r25, Y+5	; 0x05
    3938:	81 30       	cpi	r24, 0x01	; 1
    393a:	91 05       	cpc	r25, r1
    393c:	59 f1       	breq	.+86     	; 0x3994 <GPIO_voidSetPinDirection+0x172>
    393e:	2c 81       	ldd	r18, Y+4	; 0x04
    3940:	3d 81       	ldd	r19, Y+5	; 0x05
    3942:	22 30       	cpi	r18, 0x02	; 2
    3944:	31 05       	cpc	r19, r1
    3946:	2c f4       	brge	.+10     	; 0x3952 <GPIO_voidSetPinDirection+0x130>
    3948:	8c 81       	ldd	r24, Y+4	; 0x04
    394a:	9d 81       	ldd	r25, Y+5	; 0x05
    394c:	00 97       	sbiw	r24, 0x00	; 0
    394e:	69 f0       	breq	.+26     	; 0x396a <GPIO_voidSetPinDirection+0x148>
    3950:	5f c0       	rjmp	.+190    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
    3952:	2c 81       	ldd	r18, Y+4	; 0x04
    3954:	3d 81       	ldd	r19, Y+5	; 0x05
    3956:	22 30       	cpi	r18, 0x02	; 2
    3958:	31 05       	cpc	r19, r1
    395a:	89 f1       	breq	.+98     	; 0x39be <GPIO_voidSetPinDirection+0x19c>
    395c:	8c 81       	ldd	r24, Y+4	; 0x04
    395e:	9d 81       	ldd	r25, Y+5	; 0x05
    3960:	83 30       	cpi	r24, 0x03	; 3
    3962:	91 05       	cpc	r25, r1
    3964:	09 f4       	brne	.+2      	; 0x3968 <GPIO_voidSetPinDirection+0x146>
    3966:	40 c0       	rjmp	.+128    	; 0x39e8 <GPIO_voidSetPinDirection+0x1c6>
    3968:	53 c0       	rjmp	.+166    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
		{
			case PORT_A :
			CLR_BIT (GPIO_DDRA , pin);
    396a:	aa e3       	ldi	r26, 0x3A	; 58
    396c:	b0 e0       	ldi	r27, 0x00	; 0
    396e:	ea e3       	ldi	r30, 0x3A	; 58
    3970:	f0 e0       	ldi	r31, 0x00	; 0
    3972:	80 81       	ld	r24, Z
    3974:	48 2f       	mov	r20, r24
    3976:	8a 81       	ldd	r24, Y+2	; 0x02
    3978:	28 2f       	mov	r18, r24
    397a:	30 e0       	ldi	r19, 0x00	; 0
    397c:	81 e0       	ldi	r24, 0x01	; 1
    397e:	90 e0       	ldi	r25, 0x00	; 0
    3980:	02 2e       	mov	r0, r18
    3982:	02 c0       	rjmp	.+4      	; 0x3988 <GPIO_voidSetPinDirection+0x166>
    3984:	88 0f       	add	r24, r24
    3986:	99 1f       	adc	r25, r25
    3988:	0a 94       	dec	r0
    398a:	e2 f7       	brpl	.-8      	; 0x3984 <GPIO_voidSetPinDirection+0x162>
    398c:	80 95       	com	r24
    398e:	84 23       	and	r24, r20
    3990:	8c 93       	st	X, r24
    3992:	3e c0       	rjmp	.+124    	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_B :
			CLR_BIT (GPIO_DDRB , pin);
    3994:	a7 e3       	ldi	r26, 0x37	; 55
    3996:	b0 e0       	ldi	r27, 0x00	; 0
    3998:	e7 e3       	ldi	r30, 0x37	; 55
    399a:	f0 e0       	ldi	r31, 0x00	; 0
    399c:	80 81       	ld	r24, Z
    399e:	48 2f       	mov	r20, r24
    39a0:	8a 81       	ldd	r24, Y+2	; 0x02
    39a2:	28 2f       	mov	r18, r24
    39a4:	30 e0       	ldi	r19, 0x00	; 0
    39a6:	81 e0       	ldi	r24, 0x01	; 1
    39a8:	90 e0       	ldi	r25, 0x00	; 0
    39aa:	02 2e       	mov	r0, r18
    39ac:	02 c0       	rjmp	.+4      	; 0x39b2 <GPIO_voidSetPinDirection+0x190>
    39ae:	88 0f       	add	r24, r24
    39b0:	99 1f       	adc	r25, r25
    39b2:	0a 94       	dec	r0
    39b4:	e2 f7       	brpl	.-8      	; 0x39ae <GPIO_voidSetPinDirection+0x18c>
    39b6:	80 95       	com	r24
    39b8:	84 23       	and	r24, r20
    39ba:	8c 93       	st	X, r24
    39bc:	29 c0       	rjmp	.+82     	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_C :
			CLR_BIT (GPIO_DDRC , pin);
    39be:	a4 e3       	ldi	r26, 0x34	; 52
    39c0:	b0 e0       	ldi	r27, 0x00	; 0
    39c2:	e4 e3       	ldi	r30, 0x34	; 52
    39c4:	f0 e0       	ldi	r31, 0x00	; 0
    39c6:	80 81       	ld	r24, Z
    39c8:	48 2f       	mov	r20, r24
    39ca:	8a 81       	ldd	r24, Y+2	; 0x02
    39cc:	28 2f       	mov	r18, r24
    39ce:	30 e0       	ldi	r19, 0x00	; 0
    39d0:	81 e0       	ldi	r24, 0x01	; 1
    39d2:	90 e0       	ldi	r25, 0x00	; 0
    39d4:	02 2e       	mov	r0, r18
    39d6:	02 c0       	rjmp	.+4      	; 0x39dc <GPIO_voidSetPinDirection+0x1ba>
    39d8:	88 0f       	add	r24, r24
    39da:	99 1f       	adc	r25, r25
    39dc:	0a 94       	dec	r0
    39de:	e2 f7       	brpl	.-8      	; 0x39d8 <GPIO_voidSetPinDirection+0x1b6>
    39e0:	80 95       	com	r24
    39e2:	84 23       	and	r24, r20
    39e4:	8c 93       	st	X, r24
    39e6:	14 c0       	rjmp	.+40     	; 0x3a10 <GPIO_voidSetPinDirection+0x1ee>
			break;

			case PORT_D :
			CLR_BIT (GPIO_DDRD , pin);
    39e8:	a1 e3       	ldi	r26, 0x31	; 49
    39ea:	b0 e0       	ldi	r27, 0x00	; 0
    39ec:	e1 e3       	ldi	r30, 0x31	; 49
    39ee:	f0 e0       	ldi	r31, 0x00	; 0
    39f0:	80 81       	ld	r24, Z
    39f2:	48 2f       	mov	r20, r24
    39f4:	8a 81       	ldd	r24, Y+2	; 0x02
    39f6:	28 2f       	mov	r18, r24
    39f8:	30 e0       	ldi	r19, 0x00	; 0
    39fa:	81 e0       	ldi	r24, 0x01	; 1
    39fc:	90 e0       	ldi	r25, 0x00	; 0
    39fe:	02 2e       	mov	r0, r18
    3a00:	02 c0       	rjmp	.+4      	; 0x3a06 <GPIO_voidSetPinDirection+0x1e4>
    3a02:	88 0f       	add	r24, r24
    3a04:	99 1f       	adc	r25, r25
    3a06:	0a 94       	dec	r0
    3a08:	e2 f7       	brpl	.-8      	; 0x3a02 <GPIO_voidSetPinDirection+0x1e0>
    3a0a:	80 95       	com	r24
    3a0c:	84 23       	and	r24, r20
    3a0e:	8c 93       	st	X, r24
	}
	else
	{
		/* Should not be here */
	}
}
    3a10:	27 96       	adiw	r28, 0x07	; 7
    3a12:	0f b6       	in	r0, 0x3f	; 63
    3a14:	f8 94       	cli
    3a16:	de bf       	out	0x3e, r29	; 62
    3a18:	0f be       	out	0x3f, r0	; 63
    3a1a:	cd bf       	out	0x3d, r28	; 61
    3a1c:	cf 91       	pop	r28
    3a1e:	df 91       	pop	r29
    3a20:	08 95       	ret

00003a22 <GPIO_voidSetPortValue>:

void GPIO_voidSetPortValue(u8 port_id , u8 value)
{
    3a22:	df 93       	push	r29
    3a24:	cf 93       	push	r28
    3a26:	00 d0       	rcall	.+0      	; 0x3a28 <GPIO_voidSetPortValue+0x6>
    3a28:	00 d0       	rcall	.+0      	; 0x3a2a <GPIO_voidSetPortValue+0x8>
    3a2a:	cd b7       	in	r28, 0x3d	; 61
    3a2c:	de b7       	in	r29, 0x3e	; 62
    3a2e:	89 83       	std	Y+1, r24	; 0x01
    3a30:	6a 83       	std	Y+2, r22	; 0x02
	switch (port_id){
    3a32:	89 81       	ldd	r24, Y+1	; 0x01
    3a34:	28 2f       	mov	r18, r24
    3a36:	30 e0       	ldi	r19, 0x00	; 0
    3a38:	3c 83       	std	Y+4, r19	; 0x04
    3a3a:	2b 83       	std	Y+3, r18	; 0x03
    3a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a40:	81 30       	cpi	r24, 0x01	; 1
    3a42:	91 05       	cpc	r25, r1
    3a44:	d1 f0       	breq	.+52     	; 0x3a7a <GPIO_voidSetPortValue+0x58>
    3a46:	2b 81       	ldd	r18, Y+3	; 0x03
    3a48:	3c 81       	ldd	r19, Y+4	; 0x04
    3a4a:	22 30       	cpi	r18, 0x02	; 2
    3a4c:	31 05       	cpc	r19, r1
    3a4e:	2c f4       	brge	.+10     	; 0x3a5a <GPIO_voidSetPortValue+0x38>
    3a50:	8b 81       	ldd	r24, Y+3	; 0x03
    3a52:	9c 81       	ldd	r25, Y+4	; 0x04
    3a54:	00 97       	sbiw	r24, 0x00	; 0
    3a56:	61 f0       	breq	.+24     	; 0x3a70 <GPIO_voidSetPortValue+0x4e>
    3a58:	1e c0       	rjmp	.+60     	; 0x3a96 <GPIO_voidSetPortValue+0x74>
    3a5a:	2b 81       	ldd	r18, Y+3	; 0x03
    3a5c:	3c 81       	ldd	r19, Y+4	; 0x04
    3a5e:	22 30       	cpi	r18, 0x02	; 2
    3a60:	31 05       	cpc	r19, r1
    3a62:	81 f0       	breq	.+32     	; 0x3a84 <GPIO_voidSetPortValue+0x62>
    3a64:	8b 81       	ldd	r24, Y+3	; 0x03
    3a66:	9c 81       	ldd	r25, Y+4	; 0x04
    3a68:	83 30       	cpi	r24, 0x03	; 3
    3a6a:	91 05       	cpc	r25, r1
    3a6c:	81 f0       	breq	.+32     	; 0x3a8e <GPIO_voidSetPortValue+0x6c>
    3a6e:	13 c0       	rjmp	.+38     	; 0x3a96 <GPIO_voidSetPortValue+0x74>
		case PORT_A :
			GPIO_PORTA = value ;
    3a70:	eb e3       	ldi	r30, 0x3B	; 59
    3a72:	f0 e0       	ldi	r31, 0x00	; 0
    3a74:	8a 81       	ldd	r24, Y+2	; 0x02
    3a76:	80 83       	st	Z, r24
    3a78:	0e c0       	rjmp	.+28     	; 0x3a96 <GPIO_voidSetPortValue+0x74>
			break;

		case PORT_B :
			GPIO_PORTB = value ;
    3a7a:	e8 e3       	ldi	r30, 0x38	; 56
    3a7c:	f0 e0       	ldi	r31, 0x00	; 0
    3a7e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a80:	80 83       	st	Z, r24
    3a82:	09 c0       	rjmp	.+18     	; 0x3a96 <GPIO_voidSetPortValue+0x74>
			break;

		case PORT_C :
			GPIO_PORTC = value ;
    3a84:	e5 e3       	ldi	r30, 0x35	; 53
    3a86:	f0 e0       	ldi	r31, 0x00	; 0
    3a88:	8a 81       	ldd	r24, Y+2	; 0x02
    3a8a:	80 83       	st	Z, r24
    3a8c:	04 c0       	rjmp	.+8      	; 0x3a96 <GPIO_voidSetPortValue+0x74>
			break;

		case PORT_D :
			GPIO_PORTD = value ;
    3a8e:	e2 e3       	ldi	r30, 0x32	; 50
    3a90:	f0 e0       	ldi	r31, 0x00	; 0
    3a92:	8a 81       	ldd	r24, Y+2	; 0x02
    3a94:	80 83       	st	Z, r24
			break;

		default:
			break;
	}
}
    3a96:	0f 90       	pop	r0
    3a98:	0f 90       	pop	r0
    3a9a:	0f 90       	pop	r0
    3a9c:	0f 90       	pop	r0
    3a9e:	cf 91       	pop	r28
    3aa0:	df 91       	pop	r29
    3aa2:	08 95       	ret

00003aa4 <GPIO_voidSetPortDirection>:

void GPIO_voidSetPortDirection(u8 port_id , u8 dirc)
{
    3aa4:	df 93       	push	r29
    3aa6:	cf 93       	push	r28
    3aa8:	00 d0       	rcall	.+0      	; 0x3aaa <GPIO_voidSetPortDirection+0x6>
    3aaa:	00 d0       	rcall	.+0      	; 0x3aac <GPIO_voidSetPortDirection+0x8>
    3aac:	00 d0       	rcall	.+0      	; 0x3aae <GPIO_voidSetPortDirection+0xa>
    3aae:	cd b7       	in	r28, 0x3d	; 61
    3ab0:	de b7       	in	r29, 0x3e	; 62
    3ab2:	89 83       	std	Y+1, r24	; 0x01
    3ab4:	6a 83       	std	Y+2, r22	; 0x02
	if (dirc == OUTPUT)
    3ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ab8:	81 30       	cpi	r24, 0x01	; 1
    3aba:	99 f5       	brne	.+102    	; 0x3b22 <GPIO_voidSetPortDirection+0x7e>
	{
		switch (port_id){
    3abc:	89 81       	ldd	r24, Y+1	; 0x01
    3abe:	28 2f       	mov	r18, r24
    3ac0:	30 e0       	ldi	r19, 0x00	; 0
    3ac2:	3e 83       	std	Y+6, r19	; 0x06
    3ac4:	2d 83       	std	Y+5, r18	; 0x05
    3ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ac8:	9e 81       	ldd	r25, Y+6	; 0x06
    3aca:	81 30       	cpi	r24, 0x01	; 1
    3acc:	91 05       	cpc	r25, r1
    3ace:	d1 f0       	breq	.+52     	; 0x3b04 <GPIO_voidSetPortDirection+0x60>
    3ad0:	2d 81       	ldd	r18, Y+5	; 0x05
    3ad2:	3e 81       	ldd	r19, Y+6	; 0x06
    3ad4:	22 30       	cpi	r18, 0x02	; 2
    3ad6:	31 05       	cpc	r19, r1
    3ad8:	2c f4       	brge	.+10     	; 0x3ae4 <GPIO_voidSetPortDirection+0x40>
    3ada:	8d 81       	ldd	r24, Y+5	; 0x05
    3adc:	9e 81       	ldd	r25, Y+6	; 0x06
    3ade:	00 97       	sbiw	r24, 0x00	; 0
    3ae0:	61 f0       	breq	.+24     	; 0x3afa <GPIO_voidSetPortDirection+0x56>
    3ae2:	50 c0       	rjmp	.+160    	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
    3ae4:	2d 81       	ldd	r18, Y+5	; 0x05
    3ae6:	3e 81       	ldd	r19, Y+6	; 0x06
    3ae8:	22 30       	cpi	r18, 0x02	; 2
    3aea:	31 05       	cpc	r19, r1
    3aec:	81 f0       	breq	.+32     	; 0x3b0e <GPIO_voidSetPortDirection+0x6a>
    3aee:	8d 81       	ldd	r24, Y+5	; 0x05
    3af0:	9e 81       	ldd	r25, Y+6	; 0x06
    3af2:	83 30       	cpi	r24, 0x03	; 3
    3af4:	91 05       	cpc	r25, r1
    3af6:	81 f0       	breq	.+32     	; 0x3b18 <GPIO_voidSetPortDirection+0x74>
    3af8:	45 c0       	rjmp	.+138    	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
			case PORT_A :
				GPIO_DDRA = 255;
    3afa:	ea e3       	ldi	r30, 0x3A	; 58
    3afc:	f0 e0       	ldi	r31, 0x00	; 0
    3afe:	8f ef       	ldi	r24, 0xFF	; 255
    3b00:	80 83       	st	Z, r24
    3b02:	40 c0       	rjmp	.+128    	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;
			case PORT_B :
				GPIO_DDRB = 255;
    3b04:	e7 e3       	ldi	r30, 0x37	; 55
    3b06:	f0 e0       	ldi	r31, 0x00	; 0
    3b08:	8f ef       	ldi	r24, 0xFF	; 255
    3b0a:	80 83       	st	Z, r24
    3b0c:	3b c0       	rjmp	.+118    	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;
			case PORT_C :
				GPIO_DDRC = 255;
    3b0e:	e4 e3       	ldi	r30, 0x34	; 52
    3b10:	f0 e0       	ldi	r31, 0x00	; 0
    3b12:	8f ef       	ldi	r24, 0xFF	; 255
    3b14:	80 83       	st	Z, r24
    3b16:	36 c0       	rjmp	.+108    	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;
			case PORT_D :
				GPIO_DDRD = 255;
    3b18:	e1 e3       	ldi	r30, 0x31	; 49
    3b1a:	f0 e0       	ldi	r31, 0x00	; 0
    3b1c:	8f ef       	ldi	r24, 0xFF	; 255
    3b1e:	80 83       	st	Z, r24
    3b20:	31 c0       	rjmp	.+98     	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;
			default:
				break;
		}
	}
	else if (dirc == INPUT)
    3b22:	8a 81       	ldd	r24, Y+2	; 0x02
    3b24:	88 23       	and	r24, r24
    3b26:	71 f5       	brne	.+92     	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
	{
		switch (port_id){
    3b28:	89 81       	ldd	r24, Y+1	; 0x01
    3b2a:	28 2f       	mov	r18, r24
    3b2c:	30 e0       	ldi	r19, 0x00	; 0
    3b2e:	3c 83       	std	Y+4, r19	; 0x04
    3b30:	2b 83       	std	Y+3, r18	; 0x03
    3b32:	8b 81       	ldd	r24, Y+3	; 0x03
    3b34:	9c 81       	ldd	r25, Y+4	; 0x04
    3b36:	81 30       	cpi	r24, 0x01	; 1
    3b38:	91 05       	cpc	r25, r1
    3b3a:	c9 f0       	breq	.+50     	; 0x3b6e <GPIO_voidSetPortDirection+0xca>
    3b3c:	2b 81       	ldd	r18, Y+3	; 0x03
    3b3e:	3c 81       	ldd	r19, Y+4	; 0x04
    3b40:	22 30       	cpi	r18, 0x02	; 2
    3b42:	31 05       	cpc	r19, r1
    3b44:	2c f4       	brge	.+10     	; 0x3b50 <GPIO_voidSetPortDirection+0xac>
    3b46:	8b 81       	ldd	r24, Y+3	; 0x03
    3b48:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4a:	00 97       	sbiw	r24, 0x00	; 0
    3b4c:	61 f0       	breq	.+24     	; 0x3b66 <GPIO_voidSetPortDirection+0xc2>
    3b4e:	1a c0       	rjmp	.+52     	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
    3b50:	2b 81       	ldd	r18, Y+3	; 0x03
    3b52:	3c 81       	ldd	r19, Y+4	; 0x04
    3b54:	22 30       	cpi	r18, 0x02	; 2
    3b56:	31 05       	cpc	r19, r1
    3b58:	71 f0       	breq	.+28     	; 0x3b76 <GPIO_voidSetPortDirection+0xd2>
    3b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b5e:	83 30       	cpi	r24, 0x03	; 3
    3b60:	91 05       	cpc	r25, r1
    3b62:	69 f0       	breq	.+26     	; 0x3b7e <GPIO_voidSetPortDirection+0xda>
    3b64:	0f c0       	rjmp	.+30     	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
			case PORT_A :
				GPIO_DDRA = 0;
    3b66:	ea e3       	ldi	r30, 0x3A	; 58
    3b68:	f0 e0       	ldi	r31, 0x00	; 0
    3b6a:	10 82       	st	Z, r1
    3b6c:	0b c0       	rjmp	.+22     	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;

			case PORT_B :
				GPIO_DDRB = 0;
    3b6e:	e7 e3       	ldi	r30, 0x37	; 55
    3b70:	f0 e0       	ldi	r31, 0x00	; 0
    3b72:	10 82       	st	Z, r1
    3b74:	07 c0       	rjmp	.+14     	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;

			case PORT_C :
				GPIO_DDRC = 0;
    3b76:	e4 e3       	ldi	r30, 0x34	; 52
    3b78:	f0 e0       	ldi	r31, 0x00	; 0
    3b7a:	10 82       	st	Z, r1
    3b7c:	03 c0       	rjmp	.+6      	; 0x3b84 <GPIO_voidSetPortDirection+0xe0>
				break;

			case PORT_D :
				GPIO_DDRD = 0;
    3b7e:	e1 e3       	ldi	r30, 0x31	; 49
    3b80:	f0 e0       	ldi	r31, 0x00	; 0
    3b82:	10 82       	st	Z, r1
		}
	}
	else {

	}
}
    3b84:	26 96       	adiw	r28, 0x06	; 6
    3b86:	0f b6       	in	r0, 0x3f	; 63
    3b88:	f8 94       	cli
    3b8a:	de bf       	out	0x3e, r29	; 62
    3b8c:	0f be       	out	0x3f, r0	; 63
    3b8e:	cd bf       	out	0x3d, r28	; 61
    3b90:	cf 91       	pop	r28
    3b92:	df 91       	pop	r29
    3b94:	08 95       	ret

00003b96 <GPIO_u8GetPinValue>:

u8 GPIO_u8GetPinValue(u8 port_id , u8 pin)
{
    3b96:	df 93       	push	r29
    3b98:	cf 93       	push	r28
    3b9a:	00 d0       	rcall	.+0      	; 0x3b9c <GPIO_u8GetPinValue+0x6>
    3b9c:	00 d0       	rcall	.+0      	; 0x3b9e <GPIO_u8GetPinValue+0x8>
    3b9e:	0f 92       	push	r0
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	8a 83       	std	Y+2, r24	; 0x02
    3ba6:	6b 83       	std	Y+3, r22	; 0x03
	u8 value ;
	switch (port_id)
    3ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    3baa:	28 2f       	mov	r18, r24
    3bac:	30 e0       	ldi	r19, 0x00	; 0
    3bae:	3d 83       	std	Y+5, r19	; 0x05
    3bb0:	2c 83       	std	Y+4, r18	; 0x04
    3bb2:	4c 81       	ldd	r20, Y+4	; 0x04
    3bb4:	5d 81       	ldd	r21, Y+5	; 0x05
    3bb6:	41 30       	cpi	r20, 0x01	; 1
    3bb8:	51 05       	cpc	r21, r1
    3bba:	41 f1       	breq	.+80     	; 0x3c0c <GPIO_u8GetPinValue+0x76>
    3bbc:	8c 81       	ldd	r24, Y+4	; 0x04
    3bbe:	9d 81       	ldd	r25, Y+5	; 0x05
    3bc0:	82 30       	cpi	r24, 0x02	; 2
    3bc2:	91 05       	cpc	r25, r1
    3bc4:	34 f4       	brge	.+12     	; 0x3bd2 <GPIO_u8GetPinValue+0x3c>
    3bc6:	2c 81       	ldd	r18, Y+4	; 0x04
    3bc8:	3d 81       	ldd	r19, Y+5	; 0x05
    3bca:	21 15       	cp	r18, r1
    3bcc:	31 05       	cpc	r19, r1
    3bce:	61 f0       	breq	.+24     	; 0x3be8 <GPIO_u8GetPinValue+0x52>
    3bd0:	52 c0       	rjmp	.+164    	; 0x3c76 <GPIO_u8GetPinValue+0xe0>
    3bd2:	4c 81       	ldd	r20, Y+4	; 0x04
    3bd4:	5d 81       	ldd	r21, Y+5	; 0x05
    3bd6:	42 30       	cpi	r20, 0x02	; 2
    3bd8:	51 05       	cpc	r21, r1
    3bda:	51 f1       	breq	.+84     	; 0x3c30 <GPIO_u8GetPinValue+0x9a>
    3bdc:	8c 81       	ldd	r24, Y+4	; 0x04
    3bde:	9d 81       	ldd	r25, Y+5	; 0x05
    3be0:	83 30       	cpi	r24, 0x03	; 3
    3be2:	91 05       	cpc	r25, r1
    3be4:	b9 f1       	breq	.+110    	; 0x3c54 <GPIO_u8GetPinValue+0xbe>
    3be6:	47 c0       	rjmp	.+142    	; 0x3c76 <GPIO_u8GetPinValue+0xe0>
	{
		case PORT_A :
		value = GET_BIT(GPIO_PINA , pin);
    3be8:	e9 e3       	ldi	r30, 0x39	; 57
    3bea:	f0 e0       	ldi	r31, 0x00	; 0
    3bec:	80 81       	ld	r24, Z
    3bee:	28 2f       	mov	r18, r24
    3bf0:	30 e0       	ldi	r19, 0x00	; 0
    3bf2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf4:	88 2f       	mov	r24, r24
    3bf6:	90 e0       	ldi	r25, 0x00	; 0
    3bf8:	a9 01       	movw	r20, r18
    3bfa:	02 c0       	rjmp	.+4      	; 0x3c00 <GPIO_u8GetPinValue+0x6a>
    3bfc:	55 95       	asr	r21
    3bfe:	47 95       	ror	r20
    3c00:	8a 95       	dec	r24
    3c02:	e2 f7       	brpl	.-8      	; 0x3bfc <GPIO_u8GetPinValue+0x66>
    3c04:	ca 01       	movw	r24, r20
    3c06:	81 70       	andi	r24, 0x01	; 1
    3c08:	89 83       	std	Y+1, r24	; 0x01
    3c0a:	35 c0       	rjmp	.+106    	; 0x3c76 <GPIO_u8GetPinValue+0xe0>
		break;

		case PORT_B :
		value = GET_BIT(GPIO_PINB , pin);
    3c0c:	e6 e3       	ldi	r30, 0x36	; 54
    3c0e:	f0 e0       	ldi	r31, 0x00	; 0
    3c10:	80 81       	ld	r24, Z
    3c12:	28 2f       	mov	r18, r24
    3c14:	30 e0       	ldi	r19, 0x00	; 0
    3c16:	8b 81       	ldd	r24, Y+3	; 0x03
    3c18:	88 2f       	mov	r24, r24
    3c1a:	90 e0       	ldi	r25, 0x00	; 0
    3c1c:	a9 01       	movw	r20, r18
    3c1e:	02 c0       	rjmp	.+4      	; 0x3c24 <GPIO_u8GetPinValue+0x8e>
    3c20:	55 95       	asr	r21
    3c22:	47 95       	ror	r20
    3c24:	8a 95       	dec	r24
    3c26:	e2 f7       	brpl	.-8      	; 0x3c20 <GPIO_u8GetPinValue+0x8a>
    3c28:	ca 01       	movw	r24, r20
    3c2a:	81 70       	andi	r24, 0x01	; 1
    3c2c:	89 83       	std	Y+1, r24	; 0x01
    3c2e:	23 c0       	rjmp	.+70     	; 0x3c76 <GPIO_u8GetPinValue+0xe0>
		break;

		case PORT_C :
		value = GET_BIT(GPIO_PINC , pin);
    3c30:	e3 e3       	ldi	r30, 0x33	; 51
    3c32:	f0 e0       	ldi	r31, 0x00	; 0
    3c34:	80 81       	ld	r24, Z
    3c36:	28 2f       	mov	r18, r24
    3c38:	30 e0       	ldi	r19, 0x00	; 0
    3c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c3c:	88 2f       	mov	r24, r24
    3c3e:	90 e0       	ldi	r25, 0x00	; 0
    3c40:	a9 01       	movw	r20, r18
    3c42:	02 c0       	rjmp	.+4      	; 0x3c48 <GPIO_u8GetPinValue+0xb2>
    3c44:	55 95       	asr	r21
    3c46:	47 95       	ror	r20
    3c48:	8a 95       	dec	r24
    3c4a:	e2 f7       	brpl	.-8      	; 0x3c44 <GPIO_u8GetPinValue+0xae>
    3c4c:	ca 01       	movw	r24, r20
    3c4e:	81 70       	andi	r24, 0x01	; 1
    3c50:	89 83       	std	Y+1, r24	; 0x01
    3c52:	11 c0       	rjmp	.+34     	; 0x3c76 <GPIO_u8GetPinValue+0xe0>
		break;

		case PORT_D :
		value = GET_BIT(GPIO_PIND , pin);
    3c54:	e0 e3       	ldi	r30, 0x30	; 48
    3c56:	f0 e0       	ldi	r31, 0x00	; 0
    3c58:	80 81       	ld	r24, Z
    3c5a:	28 2f       	mov	r18, r24
    3c5c:	30 e0       	ldi	r19, 0x00	; 0
    3c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c60:	88 2f       	mov	r24, r24
    3c62:	90 e0       	ldi	r25, 0x00	; 0
    3c64:	a9 01       	movw	r20, r18
    3c66:	02 c0       	rjmp	.+4      	; 0x3c6c <GPIO_u8GetPinValue+0xd6>
    3c68:	55 95       	asr	r21
    3c6a:	47 95       	ror	r20
    3c6c:	8a 95       	dec	r24
    3c6e:	e2 f7       	brpl	.-8      	; 0x3c68 <GPIO_u8GetPinValue+0xd2>
    3c70:	ca 01       	movw	r24, r20
    3c72:	81 70       	andi	r24, 0x01	; 1
    3c74:	89 83       	std	Y+1, r24	; 0x01
		break;

		default:
		break;
	}
	return value ;
    3c76:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	0f 90       	pop	r0
    3c7e:	0f 90       	pop	r0
    3c80:	0f 90       	pop	r0
    3c82:	cf 91       	pop	r28
    3c84:	df 91       	pop	r29
    3c86:	08 95       	ret

00003c88 <main>:
void Task2 (void *p);
void Task3 (void *p);
void Task4 (void *p);

void main ()
{
    3c88:	ef 92       	push	r14
    3c8a:	ff 92       	push	r15
    3c8c:	0f 93       	push	r16
    3c8e:	df 93       	push	r29
    3c90:	cf 93       	push	r28
    3c92:	cd b7       	in	r28, 0x3d	; 61
    3c94:	de b7       	in	r29, 0x3e	; 62
	GPIO_voidSetPortDirection(PORT_D , OUTPUT);
    3c96:	83 e0       	ldi	r24, 0x03	; 3
    3c98:	61 e0       	ldi	r22, 0x01	; 1
    3c9a:	0e 94 52 1d 	call	0x3aa4	; 0x3aa4 <GPIO_voidSetPortDirection>

	xTaskCreate(Task1  /* Function address */
    3c9e:	86 e8       	ldi	r24, 0x86	; 134
    3ca0:	9e e1       	ldi	r25, 0x1E	; 30
    3ca2:	60 e0       	ldi	r22, 0x00	; 0
    3ca4:	70 e0       	ldi	r23, 0x00	; 0
    3ca6:	44 e6       	ldi	r20, 0x64	; 100
    3ca8:	50 e0       	ldi	r21, 0x00	; 0
    3caa:	20 e0       	ldi	r18, 0x00	; 0
    3cac:	30 e0       	ldi	r19, 0x00	; 0
    3cae:	01 e0       	ldi	r16, 0x01	; 1
    3cb0:	ee 24       	eor	r14, r14
    3cb2:	ff 24       	eor	r15, r15
    3cb4:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskCreate>
				, 100 /* Stack depth */
				, NULL /* Pointer to void, will be passed to the task */
				, 1  /* Priority */
				, NULL); /* Handle task used with other funcions like delete task */

	xTaskCreate(Task2  /* Function address */
    3cb8:	81 ea       	ldi	r24, 0xA1	; 161
    3cba:	9e e1       	ldi	r25, 0x1E	; 30
    3cbc:	60 e0       	ldi	r22, 0x00	; 0
    3cbe:	70 e0       	ldi	r23, 0x00	; 0
    3cc0:	44 e6       	ldi	r20, 0x64	; 100
    3cc2:	50 e0       	ldi	r21, 0x00	; 0
    3cc4:	20 e0       	ldi	r18, 0x00	; 0
    3cc6:	30 e0       	ldi	r19, 0x00	; 0
    3cc8:	00 e0       	ldi	r16, 0x00	; 0
    3cca:	ee 24       	eor	r14, r14
    3ccc:	ff 24       	eor	r15, r15
    3cce:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskCreate>
					, 100 /* Stack depth */
					, NULL /* Pointer to void, will be passed to the task */
					, 0  /* Priority */
					, NULL); /* Handle task used with other funcions like delete task */

	xTaskCreate(Task3  /* Function address */
    3cd2:	8c eb       	ldi	r24, 0xBC	; 188
    3cd4:	9e e1       	ldi	r25, 0x1E	; 30
    3cd6:	60 e0       	ldi	r22, 0x00	; 0
    3cd8:	70 e0       	ldi	r23, 0x00	; 0
    3cda:	44 e6       	ldi	r20, 0x64	; 100
    3cdc:	50 e0       	ldi	r21, 0x00	; 0
    3cde:	20 e0       	ldi	r18, 0x00	; 0
    3ce0:	30 e0       	ldi	r19, 0x00	; 0
    3ce2:	00 e0       	ldi	r16, 0x00	; 0
    3ce4:	ee 24       	eor	r14, r14
    3ce6:	ff 24       	eor	r15, r15
    3ce8:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskCreate>
					, 100 /* Stack depth */
					, NULL /* Pointer to void, will be passed to the task */
					, 0  /* Priority */
					, NULL); /* Handle task used with other funcions like delete task */

	xTaskCreate(Task4  /* Function address */
    3cec:	87 ed       	ldi	r24, 0xD7	; 215
    3cee:	9e e1       	ldi	r25, 0x1E	; 30
    3cf0:	60 e0       	ldi	r22, 0x00	; 0
    3cf2:	70 e0       	ldi	r23, 0x00	; 0
    3cf4:	44 e6       	ldi	r20, 0x64	; 100
    3cf6:	50 e0       	ldi	r21, 0x00	; 0
    3cf8:	20 e0       	ldi	r18, 0x00	; 0
    3cfa:	30 e0       	ldi	r19, 0x00	; 0
    3cfc:	00 e0       	ldi	r16, 0x00	; 0
    3cfe:	ee 24       	eor	r14, r14
    3d00:	ff 24       	eor	r15, r15
    3d02:	0e 94 ef 0b 	call	0x17de	; 0x17de <xTaskCreate>
					, NULL /* Pointer to void, will be passed to the task */
					, 0  /* Priority */
					, NULL); /* Handle task used with other funcions like delete task */


	vTaskStartScheduler();
    3d06:	0e 94 2c 11 	call	0x2258	; 0x2258 <vTaskStartScheduler>
    3d0a:	ff cf       	rjmp	.-2      	; 0x3d0a <main+0x82>

00003d0c <Task1>:
	}

}

void Task1 (void *p)
{
    3d0c:	df 93       	push	r29
    3d0e:	cf 93       	push	r28
    3d10:	00 d0       	rcall	.+0      	; 0x3d12 <Task1+0x6>
    3d12:	00 d0       	rcall	.+0      	; 0x3d14 <Task1+0x8>
    3d14:	cd b7       	in	r28, 0x3d	; 61
    3d16:	de b7       	in	r29, 0x3e	; 62
    3d18:	9b 83       	std	Y+3, r25	; 0x03
    3d1a:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 0 ;
    3d1c:	19 82       	std	Y+1, r1	; 0x01
	while (1)
	{
		GPIO_voidSetPinValue(PORT_D , PIN0 , state);
    3d1e:	83 e0       	ldi	r24, 0x03	; 3
    3d20:	60 e0       	ldi	r22, 0x00	; 0
    3d22:	49 81       	ldd	r20, Y+1	; 0x01
    3d24:	0e 94 11 1b 	call	0x3622	; 0x3622 <GPIO_voidSetPinValue>
		vTaskDelay( pdMS_TO_TICKS(200) ); /* Delay for how many tick */
    3d28:	83 e0       	ldi	r24, 0x03	; 3
    3d2a:	90 e0       	ldi	r25, 0x00	; 0
    3d2c:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <vTaskDelay>
		state = !state ;
    3d30:	1c 82       	std	Y+4, r1	; 0x04
    3d32:	89 81       	ldd	r24, Y+1	; 0x01
    3d34:	88 23       	and	r24, r24
    3d36:	11 f4       	brne	.+4      	; 0x3d3c <Task1+0x30>
    3d38:	81 e0       	ldi	r24, 0x01	; 1
    3d3a:	8c 83       	std	Y+4, r24	; 0x04
    3d3c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d3e:	89 83       	std	Y+1, r24	; 0x01
    3d40:	ee cf       	rjmp	.-36     	; 0x3d1e <Task1+0x12>

00003d42 <Task2>:
	}

}

void Task2 (void *p)
{
    3d42:	df 93       	push	r29
    3d44:	cf 93       	push	r28
    3d46:	00 d0       	rcall	.+0      	; 0x3d48 <Task2+0x6>
    3d48:	00 d0       	rcall	.+0      	; 0x3d4a <Task2+0x8>
    3d4a:	cd b7       	in	r28, 0x3d	; 61
    3d4c:	de b7       	in	r29, 0x3e	; 62
    3d4e:	9b 83       	std	Y+3, r25	; 0x03
    3d50:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 0 ;
    3d52:	19 82       	std	Y+1, r1	; 0x01
	while (1)
	{
		GPIO_voidSetPinValue(PORT_D , PIN1 , state);
    3d54:	83 e0       	ldi	r24, 0x03	; 3
    3d56:	61 e0       	ldi	r22, 0x01	; 1
    3d58:	49 81       	ldd	r20, Y+1	; 0x01
    3d5a:	0e 94 11 1b 	call	0x3622	; 0x3622 <GPIO_voidSetPinValue>
		vTaskDelay(400);
    3d5e:	80 e9       	ldi	r24, 0x90	; 144
    3d60:	91 e0       	ldi	r25, 0x01	; 1
    3d62:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <vTaskDelay>
		state = !state ;
    3d66:	1c 82       	std	Y+4, r1	; 0x04
    3d68:	89 81       	ldd	r24, Y+1	; 0x01
    3d6a:	88 23       	and	r24, r24
    3d6c:	11 f4       	brne	.+4      	; 0x3d72 <Task2+0x30>
    3d6e:	81 e0       	ldi	r24, 0x01	; 1
    3d70:	8c 83       	std	Y+4, r24	; 0x04
    3d72:	8c 81       	ldd	r24, Y+4	; 0x04
    3d74:	89 83       	std	Y+1, r24	; 0x01
    3d76:	ee cf       	rjmp	.-36     	; 0x3d54 <Task2+0x12>

00003d78 <Task3>:
	}
}

void Task3 (void *p)
{
    3d78:	df 93       	push	r29
    3d7a:	cf 93       	push	r28
    3d7c:	00 d0       	rcall	.+0      	; 0x3d7e <Task3+0x6>
    3d7e:	00 d0       	rcall	.+0      	; 0x3d80 <Task3+0x8>
    3d80:	cd b7       	in	r28, 0x3d	; 61
    3d82:	de b7       	in	r29, 0x3e	; 62
    3d84:	9b 83       	std	Y+3, r25	; 0x03
    3d86:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 0 ;
    3d88:	19 82       	std	Y+1, r1	; 0x01
	while (1)
	{
		GPIO_voidSetPinValue(PORT_D , PIN2 , state);
    3d8a:	83 e0       	ldi	r24, 0x03	; 3
    3d8c:	62 e0       	ldi	r22, 0x02	; 2
    3d8e:	49 81       	ldd	r20, Y+1	; 0x01
    3d90:	0e 94 11 1b 	call	0x3622	; 0x3622 <GPIO_voidSetPinValue>
		vTaskDelay(800);
    3d94:	80 e2       	ldi	r24, 0x20	; 32
    3d96:	93 e0       	ldi	r25, 0x03	; 3
    3d98:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <vTaskDelay>
		state = !state ;
    3d9c:	1c 82       	std	Y+4, r1	; 0x04
    3d9e:	89 81       	ldd	r24, Y+1	; 0x01
    3da0:	88 23       	and	r24, r24
    3da2:	11 f4       	brne	.+4      	; 0x3da8 <Task3+0x30>
    3da4:	81 e0       	ldi	r24, 0x01	; 1
    3da6:	8c 83       	std	Y+4, r24	; 0x04
    3da8:	8c 81       	ldd	r24, Y+4	; 0x04
    3daa:	89 83       	std	Y+1, r24	; 0x01
    3dac:	ee cf       	rjmp	.-36     	; 0x3d8a <Task3+0x12>

00003dae <Task4>:
	}
}

void Task4 (void *p)
{
    3dae:	df 93       	push	r29
    3db0:	cf 93       	push	r28
    3db2:	00 d0       	rcall	.+0      	; 0x3db4 <Task4+0x6>
    3db4:	00 d0       	rcall	.+0      	; 0x3db6 <Task4+0x8>
    3db6:	cd b7       	in	r28, 0x3d	; 61
    3db8:	de b7       	in	r29, 0x3e	; 62
    3dba:	9b 83       	std	Y+3, r25	; 0x03
    3dbc:	8a 83       	std	Y+2, r24	; 0x02
	u8 state = 0 ;
    3dbe:	19 82       	std	Y+1, r1	; 0x01
	while (1)
	{
		GPIO_voidSetPinValue(PORT_D , PIN3 , state);
    3dc0:	83 e0       	ldi	r24, 0x03	; 3
    3dc2:	63 e0       	ldi	r22, 0x03	; 3
    3dc4:	49 81       	ldd	r20, Y+1	; 0x01
    3dc6:	0e 94 11 1b 	call	0x3622	; 0x3622 <GPIO_voidSetPinValue>
		vTaskDelay(1600);
    3dca:	80 e4       	ldi	r24, 0x40	; 64
    3dcc:	96 e0       	ldi	r25, 0x06	; 6
    3dce:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <vTaskDelay>
		state = !state ;
    3dd2:	1c 82       	std	Y+4, r1	; 0x04
    3dd4:	89 81       	ldd	r24, Y+1	; 0x01
    3dd6:	88 23       	and	r24, r24
    3dd8:	11 f4       	brne	.+4      	; 0x3dde <Task4+0x30>
    3dda:	81 e0       	ldi	r24, 0x01	; 1
    3ddc:	8c 83       	std	Y+4, r24	; 0x04
    3dde:	8c 81       	ldd	r24, Y+4	; 0x04
    3de0:	89 83       	std	Y+1, r24	; 0x01
    3de2:	ee cf       	rjmp	.-36     	; 0x3dc0 <Task4+0x12>

00003de4 <memcpy>:
    3de4:	fb 01       	movw	r30, r22
    3de6:	dc 01       	movw	r26, r24
    3de8:	02 c0       	rjmp	.+4      	; 0x3dee <memcpy+0xa>
    3dea:	01 90       	ld	r0, Z+
    3dec:	0d 92       	st	X+, r0
    3dee:	41 50       	subi	r20, 0x01	; 1
    3df0:	50 40       	sbci	r21, 0x00	; 0
    3df2:	d8 f7       	brcc	.-10     	; 0x3dea <memcpy+0x6>
    3df4:	08 95       	ret

00003df6 <_exit>:
    3df6:	f8 94       	cli

00003df8 <__stop_program>:
    3df8:	ff cf       	rjmp	.-2      	; 0x3df8 <__stop_program>
